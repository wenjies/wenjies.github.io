{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.6.4.min.js","path":"js/jquery-3.6.4.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","path":"fancybox/jquery.fancybox.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","path":"fancybox/jquery.fancybox.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1},{"_id":"source/images/20160221P1.jpg","path":"images/20160221P1.jpg","modified":0,"renderable":0},{"_id":"source/images/zk/zk_1.jpg","path":"images/zk/zk_1.jpg","modified":0,"renderable":0},{"_id":"source/images/zk/zk_wa.png","path":"images/zk/zk_wa.png","modified":0,"renderable":0},{"_id":"source/images/mysql/7-join-r1.png","path":"images/mysql/7-join-r1.png","modified":0,"renderable":0},{"_id":"source/images/mysql/7-join-r2.png","path":"images/mysql/7-join-r2.png","modified":0,"renderable":0},{"_id":"source/images/mysql/7-join-r3.png","path":"images/mysql/7-join-r3.png","modified":0,"renderable":0},{"_id":"source/images/mysql/idx_.jpg","path":"images/mysql/idx_.jpg","modified":0,"renderable":0},{"_id":"source/images/mysql/index_lose.png","path":"images/mysql/index_lose.png","modified":0,"renderable":0},{"_id":"source/images/mysql/7-join-r4.png","path":"images/mysql/7-join-r4.png","modified":0,"renderable":0},{"_id":"source/images/mysql/7-join.png","path":"images/mysql/7-join.png","modified":0,"renderable":0},{"_id":"source/images/mysql/result1.jpg","path":"images/mysql/result1.jpg","modified":0,"renderable":0},{"_id":"source/images/mysql/result2.jpg","path":"images/mysql/result2.jpg","modified":0,"renderable":0},{"_id":"source/images/mysql/sql_slow.jpg","path":"images/mysql/sql_slow.jpg","modified":0,"renderable":0},{"_id":"source/images/mysql/y_h_1.jpg","path":"images/mysql/y_h_1.jpg","modified":0,"renderable":0},{"_id":"source/images/mysql/y_h_10.jpg","path":"images/mysql/y_h_10.jpg","modified":0,"renderable":0},{"_id":"source/images/mysql/y_h_11.jpg","path":"images/mysql/y_h_11.jpg","modified":0,"renderable":0},{"_id":"source/images/mysql/y_h_2.jpg","path":"images/mysql/y_h_2.jpg","modified":0,"renderable":0},{"_id":"source/images/mysql/y_h_3.jpg","path":"images/mysql/y_h_3.jpg","modified":0,"renderable":0},{"_id":"source/images/mysql/y_h_4.jpg","path":"images/mysql/y_h_4.jpg","modified":0,"renderable":0},{"_id":"source/images/mysql/y_h_5.jpg","path":"images/mysql/y_h_5.jpg","modified":0,"renderable":0},{"_id":"source/images/mysql/y_h_6.jpg","path":"images/mysql/y_h_6.jpg","modified":0,"renderable":0},{"_id":"source/images/mysql/y_h_7.jpg","path":"images/mysql/y_h_7.jpg","modified":0,"renderable":0},{"_id":"source/images/mysql/y_h_8.jpg","path":"images/mysql/y_h_8.jpg","modified":0,"renderable":0},{"_id":"source/images/mysql/y_h_9.jpg","path":"images/mysql/y_h_9.jpg","modified":0,"renderable":0},{"_id":"source/images/20160515P2.jpg","path":"images/20160515P2.jpg","modified":0,"renderable":0},{"_id":"source/images/20160515P3.jpg","path":"images/20160515P3.jpg","modified":0,"renderable":0},{"_id":"source/images/20160515P1.jpg","path":"images/20160515P1.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1732595594228},{"_id":"node_modules/hexo-theme-landscape/languages/de-DE.yml","hash":"d29d1c4256b7ed9df42f511c2ff0a23ad5fd6c1f","modified":1732595712822},{"_id":"node_modules/hexo-theme-landscape/package.json","hash":"4bf95d52f77edf811f23f6d264a7493311a8d078","modified":1732595712805},{"_id":"node_modules/hexo-theme-landscape/_config.yml","hash":"b608c1f1322760dce9805285a602a95832730a2e","modified":1732595712822},{"_id":"node_modules/hexo-theme-landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1732595712658},{"_id":"node_modules/hexo-theme-landscape/README.md","hash":"1a9b279e6dd29fd19245f913f0c4a316ffaa62db","modified":1732595712810},{"_id":"node_modules/hexo-theme-landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1732595712822},{"_id":"node_modules/hexo-theme-landscape/languages/en-GB.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1732595712822},{"_id":"node_modules/hexo-theme-landscape/languages/en.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1732595712826},{"_id":"node_modules/hexo-theme-landscape/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1732595712822},{"_id":"node_modules/hexo-theme-landscape/languages/en-US.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1732595712826},{"_id":"node_modules/hexo-theme-landscape/languages/es-ES.yml","hash":"7008a8fc91f18d2a735864817b8ebda30c7a2c66","modified":1732595712826},{"_id":"node_modules/hexo-theme-landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1732595712826},{"_id":"node_modules/hexo-theme-landscape/languages/fr-FR.yml","hash":"8d09dbdab00a30a2870b56f7c0a7ca7deafa7b88","modified":1732595712826},{"_id":"node_modules/hexo-theme-landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1732595712826},{"_id":"node_modules/hexo-theme-landscape/languages/it-IT.yml","hash":"2cb6dc2fab9bd2dbe1c8bb869a9e8bf85a564fdd","modified":1732595712830},{"_id":"node_modules/hexo-theme-landscape/languages/hu-HU.yml","hash":"712d18664898fa21ba38d4973e90ef41a324ea25","modified":1732595712830},{"_id":"node_modules/hexo-theme-landscape/languages/it.yml","hash":"89b7d91306b2c1a0f3ac023b657bf974f798a1e8","modified":1732595712830},{"_id":"node_modules/hexo-theme-landscape/languages/hu.yml","hash":"284d557130bf54a74e7dcef9d42096130e4d9550","modified":1732595712830},{"_id":"node_modules/hexo-theme-landscape/languages/ja-JP.yml","hash":"08481267e0c112e1f6855620f2837ec4c4a98bbd","modified":1732595712830},{"_id":"node_modules/hexo-theme-landscape/languages/ko-KR.yml","hash":"19209ad8f9d4057e8df808937f950eb265e1db69","modified":1732595712834},{"_id":"node_modules/hexo-theme-landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1732595712834},{"_id":"node_modules/hexo-theme-landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1732595712838},{"_id":"node_modules/hexo-theme-landscape/languages/mn-MN.yml","hash":"b9e5f3e7c0c2f779cf2cfded6db847b5941637ca","modified":1732595712838},{"_id":"node_modules/hexo-theme-landscape/languages/mn.yml","hash":"2e7523951072a9403ead3840ad823edd1084c116","modified":1732595712838},{"_id":"node_modules/hexo-theme-landscape/languages/nl-NL.yml","hash":"5ebbc30021f05d99938f96dfff280392df7f91f0","modified":1732595712838},{"_id":"node_modules/hexo-theme-landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1732595712843},{"_id":"node_modules/hexo-theme-landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1732595712838},{"_id":"node_modules/hexo-theme-landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1732595712838},{"_id":"node_modules/hexo-theme-landscape/languages/pt-PT.yml","hash":"0f852b6b228e6ea59aa3540574bb89b233f2a098","modified":1732595712843},{"_id":"node_modules/hexo-theme-landscape/languages/ru-RU.yml","hash":"360d11a28bb768afb1dd15f63fa7fd3a8cc547ee","modified":1732595712843},{"_id":"node_modules/hexo-theme-landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1732595712847},{"_id":"node_modules/hexo-theme-landscape/languages/th.yml","hash":"84a55b00aa01f03982be294e43c33a20e6d32862","modified":1732595712847},{"_id":"node_modules/hexo-theme-landscape/languages/th-TH.yml","hash":"ebfdba9bc4842c829473c1e6e4544344f182724d","modified":1732595712847},{"_id":"node_modules/hexo-theme-landscape/languages/zh-CN.yml","hash":"1efd95774f401c80193eac6ee3f1794bfe93dc5a","modified":1732595712847},{"_id":"node_modules/hexo-theme-landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1732595712847},{"_id":"node_modules/hexo-theme-landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1732595712670},{"_id":"node_modules/hexo-theme-landscape/languages/tr.yml","hash":"a1cdbfa17682d7a971de8ab8588bf57c74224b5b","modified":1732595712847},{"_id":"node_modules/hexo-theme-landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1732595712703},{"_id":"node_modules/hexo-theme-landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1732595712683},{"_id":"node_modules/hexo-theme-landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1732595712695},{"_id":"node_modules/hexo-theme-landscape/scripts/fancybox.js","hash":"c857d7a5e4a5d71c743a009c5932bf84229db428","modified":1732595712797},{"_id":"node_modules/hexo-theme-landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1732595712703},{"_id":"node_modules/hexo-theme-landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1732595712711},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1732595712670},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/recent_posts.ejs","hash":"60c4b012dcc656438ff59997e60367e5a21ab746","modified":1732595712707},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1732595712679},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1732595712711},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1732595712666},{"_id":"node_modules/hexo-theme-landscape/layout/layout.ejs","hash":"0d1765036e4874500e68256fedb7470e96eeb6ee","modified":1732595712695},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1732595712715},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/footer.ejs","hash":"3656eb692254346671abc03cb3ba1459829e0dce","modified":1732595712683},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/after-footer.ejs","hash":"377d257d5d16e0158a4405c72401517b074fd7ff","modified":1732595712663},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/article.ejs","hash":"56597e951203dd662a6d2c817c7c4f1c920d4a25","modified":1732595712675},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive.ejs","hash":"7cb70a7a54f8c7ae49b10d1f37c0a9b74eab8826","modified":1732595712666},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/google-analytics.ejs","hash":"2ea7442ea1e1a8ab4e41e26c563f58413b59a3d0","modified":1732595712691},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/header.ejs","hash":"6a5033d189554c9a6d42e2ef7952ae5c9742648e","modified":1732595712691},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1732595712699},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/gauges-analytics.ejs","hash":"21a1e2a3907d1a3dad1cd0ab855fe6735f233c74","modified":1732595712687},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1732595712707},{"_id":"node_modules/hexo-theme-landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1732595712810},{"_id":"node_modules/hexo-theme-landscape/source/css/_variables.styl","hash":"ca28281423ae57d76b6c1eb91cd845fd4e518bd6","modified":1732595712810},{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","hash":"e55a1d92954ed20f6887f92dc727bb995a010a43","modified":1732595712818},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/head.ejs","hash":"f05bced793b0314d4f2ef0c993b3a51d0b7d203a","modified":1732595712691},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","hash":"49773efcb2221bbdf2d86f3f5c5ff2d841b528cc","modified":1732595712805},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1732595712661},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/date.ejs","hash":"f1458584b679545830b75bef2526e2f3eb931045","modified":1732595712683},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1732595712675},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1732595712687},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1732595712703},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/title.ejs","hash":"4d7e62574ddf46de9b41605fe3140d77b5ddb26d","modified":1732595712715},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1732595712707},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/article.styl","hash":"2d1f6f79ebf9cb55ebdb3865a2474437eb2b37c6","modified":1732595712810},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/header.styl","hash":"268d2989acb06e2ddd06cc36a6918c6cd865476b","modified":1732595712814},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1732595712814},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1732595712810},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1732595712814},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/highlight.styl","hash":"9cc3b2927d814f2f6e8e188f9d3657b94f4c6ef3","modified":1732595712814},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1732595712818},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1732595712818},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1732595712818},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1732595712814},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1732595712818},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1732595712818},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.6.4.min.js","hash":"eda46747c71d38a880bee44f9a439c3858bb8f99","modified":1732595712801},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1732595712797},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1732595712805},{"_id":"public/2024/11/26/hello-world/index.html","hash":"7bb721f0bbec07227f4a419a4f4d93d2da97b63c","modified":1732625629470},{"_id":"public/archives/index.html","hash":"f6d38dc8776a946f07691a02d2d3f19dd19c7ebe","modified":1732684611258},{"_id":"public/archives/2024/index.html","hash":"50c6f5bf013aedfdad0c7dc014ff9c8abda7e142","modified":1732684611258},{"_id":"public/archives/2024/11/index.html","hash":"168a8de3f58a472fb574e608f11b52cb035ff972","modified":1732684611258},{"_id":"public/index.html","hash":"6f89e956e16bdc1f32955e26db3ce465b7d33fbf","modified":1732684611258},{"_id":"public/js/script.js","hash":"49773efcb2221bbdf2d86f3f5c5ff2d841b528cc","modified":1732625629470},{"_id":"public/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1732625629470},{"_id":"public/css/style.css","hash":"ddb3792605d744ab3d9f0a649c82b62e9b16daa6","modified":1732625629470},{"_id":"public/js/jquery-3.6.4.min.js","hash":"eda46747c71d38a880bee44f9a439c3858bb8f99","modified":1732625629470},{"_id":"public/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1732625629470},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1732625629470},{"_id":"source/_posts/2016-02-21-JAVA abstract class VS interface.md","hash":"ae2f4820e49658d36c523af3df858898dbdc5947","modified":1732674522323},{"_id":"source/_posts/2016-03-15-The concept of strong reference, soft reference, weak reference, virtual reference.md","hash":"796b52f008d1d03d6451dc2612a3b1d38b73c177","modified":1732624680060},{"_id":"source/_posts/2016-02-22-The pits you trod on in those years.md","hash":"04112747ff0e5997838dfdf2f4d0c9c0230a1544","modified":1732624680060},{"_id":"source/_posts/2016-08-02-mysql-7-join.md","hash":"b03ab8a67988e06fd6b7720f3bfef775e0ba6cfa","modified":1732624680060},{"_id":"source/_posts/2016-05-01-spring-task.md","hash":"1386e9e0c96e2cca1fa880ff522a619876e35a7d","modified":1732624680060},{"_id":"source/_posts/2016-08-01-mysql-index.md","hash":"b74785a2f52b50a974ee650ebde46c1110eb235a","modified":1732624680060},{"_id":"source/_posts/2016-08-03-mysql-youhua.md","hash":"d5f231e9d09e4e11b00bc89c3e707cce327204b8","modified":1732624680060},{"_id":"source/_posts/2016-08-11-mysql-procedure.md","hash":"28fe0984f4f799eb58a9a291f6c9b58c6d6ee4be","modified":1732624680060},{"_id":"source/_posts/2016-08-12-mysql-function.md","hash":"12ef4210af03f1a3f5dabbe8541d76101a4e83a4","modified":1732624680060},{"_id":"source/_posts/2016-08-13-mysql-view.md","hash":"7842b23647e375aae9fd59ff550aca7bb40a5d25","modified":1732624680060},{"_id":"source/_posts/2016-10-01-spring-di-bean.md","hash":"0d0a8ab0344e875c3b3b4eb4675766cd198777d4","modified":1732624680061},{"_id":"source/_posts/2016-08-14-mysql-trigger.md","hash":"67504d28f1d7904e23ff21ef864b8acf91e7dad0","modified":1732624680061},{"_id":"source/_posts/2016-11-16-windows-install-redis.md","hash":"faf7b87e63893112d6944f4c517d498a98ffba02","modified":1732624680061},{"_id":"source/_posts/2016-12-13-spring-ActiveMQ .md","hash":"a3ef0d5a848e0c5f12439721689d74694b69b418","modified":1732624680061},{"_id":"source/_posts/2016-08-15-mysql-event.md","hash":"798bc4e089b1b22759ea0d12874a04a7c2e25b68","modified":1732624680061},{"_id":"source/_posts/2017-05-02-JAVA interview summary.md","hash":"a1a4c68bf64b9206c5068f33f5548255fdbe9d35","modified":1732624680061},{"_id":"source/_posts/2017-05-23-Spring-Some-of-the-characteristics-of-a-transaction.md","hash":"c9d8da3006305036f38584d9d7d7b109421be302","modified":1732624680061},{"_id":"source/_posts/2017-05-22-spring-extend.md","hash":"33efb6b5501b76c6b31757e3888daa352c457202","modified":1732624680061},{"_id":"source/_posts/2017-08-24-Some-summaries-of-multithreading.md","hash":"a78ba5c2c684c24abe8028886df2b7106c7f472e","modified":1732624680061},{"_id":"source/_posts/2017-09-11-distributed.md","hash":"e67a5b8081a52cfc608d33df94e628886ee680f2","modified":1732624680063},{"_id":"source/_posts/2017-09-08-RocketMQ.md","hash":"ab380c87537de72dea557727bcb86d84fec2b823","modified":1732624680063},{"_id":"source/_posts/2017-09-13-aop.md","hash":"3b988d50356335a6869268cbb6a5e37abe2adfd9","modified":1732624680063},{"_id":"source/_posts/2017-09-14-spring-Interceptor.md","hash":"54b0a017fb271086fb1053899f186d978fa0fb3c","modified":1732624680063},{"_id":"source/_posts/2017-09-14-ControllerAdvice.md","hash":"19ad77d9cb0fd6ffffd1c21aa8e9a6184bff8e55","modified":1732624680063},{"_id":"source/_posts/2017-09-16-jsonp.md","hash":"23ead5384d693c145390554efa8f36b9cc835f00","modified":1732624680063},{"_id":"source/_posts/2017-09-15-mybatis.md","hash":"b9c28a6386ab2aee8dc42b18cbffc88832a7b0d3","modified":1732624680063},{"_id":"source/_posts/2017-09-12-zookeeper.md","hash":"35644e0295526343d0e6a77868d1e57b0026417a","modified":1732624680063},{"_id":"source/_posts/2017-10-17-spring-test.md","hash":"66e058eeba6d84ed832001ecb723a467926512d2","modified":1732624680063},{"_id":"source/_posts/hexo使用.md","hash":"05396cc2939965ad4f68892c444a42996d0bc489","modified":1732678468029},{"_id":"source/images/msql/7-join-r1.png","hash":"bed0630aad9e935cee2d8983d46c604a5d90708f","modified":1732624680070},{"_id":"source/images/msql/7-join-r3.png","hash":"d5e42c7c60c696d1c7ce0f351d2ec55e8909071b","modified":1732624680070},{"_id":"source/images/msql/7-join-r2.png","hash":"31fab5a7e254b0806f4c6679b9bd55e726e89947","modified":1732624680070},{"_id":"source/images/msql/7-join-r4.png","hash":"9d3aa35cb3bca75bbf0fa6d4e5da854b86d7c2f1","modified":1732624680071},{"_id":"source/images/msql/result2.jpg","hash":"0212696a1f282e920188c5af473188cee346af00","modified":1732624680077},{"_id":"source/images/msql/y_h_1.jpg","hash":"282422086e4576366c70081c579d164588157fe6","modified":1732624680079},{"_id":"source/images/msql/y_h_4.jpg","hash":"7c155fa2e002a875c2455ee6bba6e48e19d53ac6","modified":1732624680082},{"_id":"source/images/msql/y_h_2.jpg","hash":"81f997bb0c2a3fd5f60b6f709da5247f4db1ac66","modified":1732624680082},{"_id":"source/images/msql/y_h_3.jpg","hash":"65b2d6d4fd32309f777aad14ca0df397f22d97db","modified":1732624680082},{"_id":"source/images/msql/y_h_7.jpg","hash":"fee5e690d685cd6f49b0c73f08b28ccb86481122","modified":1732624680083},{"_id":"source/images/msql/y_h_6.jpg","hash":"43fade3c1a4498a935077a7604a9503f1c6e2700","modified":1732624680083},{"_id":"source/images/msql/y_h_8.jpg","hash":"247712daa95f1cf659453aaecf3ccd46061c36db","modified":1732624680084},{"_id":"source/images/msql/y_h_5.jpg","hash":"f7bf7912d33cd798358abd72d6c6f171ca657b07","modified":1732624680083},{"_id":"source/images/msql/y_h_9.jpg","hash":"13fbdf0702a11e28456d2ddc582ff29600edf92a","modified":1732624680084},{"_id":"source/images/zk/zk_1.jpg","hash":"d122fcac106bc7683d39df78e0cdfd9872ffdce2","modified":1732624680084},{"_id":"source/images/zk/zk_wa.png","hash":"4aad2714e358718fec89b9c3f9503bd836fc1fb3","modified":1732624680084},{"_id":"source/images/msql/result1.jpg","hash":"44e1d2988eb71381a32113f336d9d353db5990e7","modified":1732624680077},{"_id":"source/images/msql/index_lose.png","hash":"368a590ccc2e5e37a4b5e95009158bac7e216984","modified":1732624680076},{"_id":"source/images/msql/y_h_10.jpg","hash":"41188c6582e695ada3c89ef126b3573f08f3e5e7","modified":1732624680080},{"_id":"source/images/msql/sql_slow.jpg","hash":"d1bd04758000e99c30c5cf6e83fd39354876ea9c","modified":1732624680079},{"_id":"source/images/20160221P1.jpg","hash":"157018030dcdc470896ee06e91012f8f2015f8a1","modified":1732624680066},{"_id":"source/images/msql/y_h_11.jpg","hash":"c1f9d616c324e81a69d42b335fa27ccbfc63b3b9","modified":1732624680081},{"_id":"source/images/msql/idx_.jpg","hash":"1dbc5b414961ace213d27a5474587cb4342865f1","modified":1732624680075},{"_id":"source/images/msql/7-join.png","hash":"828106957011c19d07d2719d7d062ae609e79ded","modified":1732624680073},{"_id":"node_modules/hexo-theme-icarus/layout/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1732671749489},{"_id":"node_modules/hexo-theme-icarus/layout/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1732671749491},{"_id":"node_modules/hexo-theme-icarus/layout/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1732671749490},{"_id":"node_modules/hexo-theme-icarus/layout/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1732671749495},{"_id":"node_modules/hexo-theme-icarus/layout/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1732671749492},{"_id":"node_modules/hexo-theme-icarus/include/schema/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1732671749485},{"_id":"node_modules/hexo-theme-icarus/include/schema/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1732671749482},{"_id":"node_modules/hexo-theme-icarus/include/schema/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1732671749486},{"_id":"node_modules/hexo-theme-icarus/include/schema/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1732671749484},{"_id":"node_modules/hexo-theme-icarus/include/schema/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1732671749487},{"_id":"node_modules/hexo-theme-icarus/include/config.js","hash":"4b8a3096137e0d879fb17972a69630bde38d8212","modified":1732671749498},{"_id":"node_modules/hexo-theme-icarus/package.json","hash":"b8e4e9cb53fa6de24255c423a092dd2f109ed937","modified":1732671749513},{"_id":"node_modules/hexo-theme-icarus/include/register.js","hash":"040fed1d0d7e4d8003446d1541bc15a2c4b4e500","modified":1732671749503},{"_id":"node_modules/hexo-theme-icarus/include/dependency.js","hash":"e02471f80db87db43aa7d527176e195b60dc4b99","modified":1732671749500},{"_id":"node_modules/hexo-theme-icarus/CONTRIBUTING.md","hash":"70254c6778c1e41bb2ff222bbf3a70b2239b9bc1","modified":1732671749535},{"_id":"node_modules/hexo-theme-icarus/languages/de.yml","hash":"78421f09961ca0b24756a0688fb2cb2e2696e25f","modified":1732671749557},{"_id":"node_modules/hexo-theme-icarus/LICENSE","hash":"86037e5335a49321fa73b7815cab542057fac944","modified":1732671749495},{"_id":"node_modules/hexo-theme-icarus/README.md","hash":"32f9f4fc8cd7ec60b30544bd2e558b593519ae5d","modified":1732671749536},{"_id":"node_modules/hexo-theme-icarus/languages/fr.yml","hash":"b992b68705f5050a99de926525b3cb40d95c4769","modified":1732671749559},{"_id":"node_modules/hexo-theme-icarus/languages/es.yml","hash":"38579b8fad4b6997362acc770615bcd85ff20f68","modified":1732671749558},{"_id":"node_modules/hexo-theme-icarus/languages/en.yml","hash":"3d674204d9f723c829226da745afddd180c1131d","modified":1732671749558},{"_id":"node_modules/hexo-theme-icarus/languages/id.yml","hash":"5e48b1d62378cadeb64b88349477726a5c1bae47","modified":1732671749559},{"_id":"node_modules/hexo-theme-icarus/languages/ja.yml","hash":"801d9930fef48d6a3f80470d5bed4f3eb78147e6","modified":1732671749560},{"_id":"node_modules/hexo-theme-icarus/languages/pl.yml","hash":"2e7debb44cd91096f30efc87bf8d6b1d0d0214c9","modified":1732671749562},{"_id":"node_modules/hexo-theme-icarus/languages/it.yml","hash":"b76999994cda6b08b53d34c3dd67947f164de655","modified":1732671749559},{"_id":"node_modules/hexo-theme-icarus/languages/pt-BR.yml","hash":"ee8f73350e4c6e2f63b7fc72b34472a6b1e21244","modified":1732671749562},{"_id":"node_modules/hexo-theme-icarus/languages/ru.yml","hash":"9d91358c2acbe7a0f2a25daf7f65b999ff32d068","modified":1732671749562},{"_id":"node_modules/hexo-theme-icarus/languages/ko.yml","hash":"e3374265377809c1518114cf352b595840c0b416","modified":1732671749560},{"_id":"node_modules/hexo-theme-icarus/languages/sv.yml","hash":"b12eee168c52aac855ffce9f78fe5fd5d6e3970c","modified":1732671749563},{"_id":"node_modules/hexo-theme-icarus/layout/archive.jsx","hash":"daf8eca64197709a9dc4a4792c403a32d78bdfae","modified":1732671749522},{"_id":"node_modules/hexo-theme-icarus/languages/tk.yml","hash":"ca583168bd2025124a1cd0e977da475d7a7496fd","modified":1732671749563},{"_id":"node_modules/hexo-theme-icarus/layout/categories.jsx","hash":"b8ad43e28a4990d222bfbb95b032f88555492347","modified":1732671749524},{"_id":"node_modules/hexo-theme-icarus/layout/category.jsx","hash":"fd15e4eac32de9ac8687aeb3dbe179ab61375700","modified":1732671749524},{"_id":"node_modules/hexo-theme-icarus/layout/index.jsx","hash":"0a84a2348394fa9fc5080dd396bd28d357594f47","modified":1732671749528},{"_id":"node_modules/hexo-theme-icarus/languages/tr.yml","hash":"dd0a7bfe14848d6e1aa229198fe1db03e08e305e","modified":1732671749564},{"_id":"node_modules/hexo-theme-icarus/layout/layout.jsx","hash":"ac7c4e3465a116c7f05f8c2e09ee6d6b9467abf1","modified":1732671749528},{"_id":"node_modules/hexo-theme-icarus/layout/page.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":1732671749529},{"_id":"node_modules/hexo-theme-icarus/layout/post.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":1732671749530},{"_id":"node_modules/hexo-theme-icarus/layout/tag.jsx","hash":"d2f18cac32ca2725d34ccff3f2051c623be6c892","modified":1732671749533},{"_id":"node_modules/hexo-theme-icarus/layout/tags.jsx","hash":"2c42cb64778235dd220c563a27a92108ddc50cc4","modified":1732671749534},{"_id":"node_modules/hexo-theme-icarus/scripts/index.js","hash":"93a79969c7eb47cfac097893cda36368db56902c","modified":1732671749502},{"_id":"node_modules/hexo-theme-icarus/include/schema/config.json","hash":"f233678cd656c0e300181ca79dd30cb42fc213b3","modified":1732671749510},{"_id":"node_modules/hexo-theme-icarus/include/migration/head.js","hash":"7189efe33d18927d3790e8afb06642fb293b8603","modified":1732671749500},{"_id":"node_modules/hexo-theme-icarus/include/migration/v2_v3.js","hash":"a46da71c20fa9d73c1bac26fda77717abae1b308","modified":1732671749504},{"_id":"node_modules/hexo-theme-icarus/include/migration/v3_v4.js","hash":"9faf2184d7fe87debfbe007f3fc9079dcbcafcfe","modified":1732671749504},{"_id":"node_modules/hexo-theme-icarus/include/migration/v5_v5.1.js","hash":"073f22bd16e34b56f016633b1676dab2e7d8843d","modified":1732671749506},{"_id":"node_modules/hexo-theme-icarus/include/migration/v4_v5.js","hash":"6342310892d113763b5544789b45d44c0ccf2854","modified":1732671749504},{"_id":"node_modules/hexo-theme-icarus/languages/zh-CN.yml","hash":"02475ba14afc70dfeaf5678467cee307835e4efa","modified":1732671749567},{"_id":"node_modules/hexo-theme-icarus/languages/vn.yml","hash":"5f2fffa642110c81d8f529949711c9d19ad6bbbe","modified":1732671749566},{"_id":"node_modules/hexo-theme-icarus/languages/zh-TW.yml","hash":"a6826e0c8cdb9ad286324b682b466a9e2ad78e6f","modified":1732671749567},{"_id":"node_modules/hexo-theme-icarus/include/style/article.styl","hash":"105c983871b6c9148d97a0f756886e56411572bd","modified":1732671749541},{"_id":"node_modules/hexo-theme-icarus/include/style/button.styl","hash":"0fb35b4786be1b387c751fa2849bc71523fcedd4","modified":1732671749542},{"_id":"node_modules/hexo-theme-icarus/include/style/codeblock.styl","hash":"ec54dc24eb4d9802d8fefc44c210558bc1641109","modified":1732671749543},{"_id":"node_modules/hexo-theme-icarus/include/style/card.styl","hash":"f78674422eb408cd17c17bbdc3ee1ebe4a453e05","modified":1732671749542},{"_id":"node_modules/hexo-theme-icarus/include/style/footer.styl","hash":"a4ad715dee38b249538ac6cce94efc9b355a904b","modified":1732671749549},{"_id":"node_modules/hexo-theme-icarus/include/style/base.styl","hash":"2bca6ad099949d52236c87db8db1002ffb99774c","modified":1732671749541},{"_id":"node_modules/hexo-theme-icarus/include/style/donate.styl","hash":"8d0af00628c13134b5f30a558608e7bebf18c2ec","modified":1732671749547},{"_id":"node_modules/hexo-theme-icarus/include/style/helper.styl","hash":"9f3393e6122cc9f351091bfab960674e962da343","modified":1732671749549},{"_id":"node_modules/hexo-theme-icarus/include/style/pagination.styl","hash":"b81bcd7ff915b4e9299533addc01bc4575ec35e3","modified":1732671749549},{"_id":"node_modules/hexo-theme-icarus/include/style/plugin.styl","hash":"084843d5a522029e0f84a4fe791fbcb2cabd4c36","modified":1732671749550},{"_id":"node_modules/hexo-theme-icarus/include/util/console.js","hash":"59cf9d277d3ac85a496689bd811b1c316001641d","modified":1732671749499},{"_id":"node_modules/hexo-theme-icarus/include/style/navbar.styl","hash":"34f09b144cb46a25ec2cc7260a6c207dd34ff1fe","modified":1732671749549},{"_id":"node_modules/hexo-theme-icarus/layout/common/comment.jsx","hash":"0610cadb3976954c6f299d30320a93a1bd2a151c","modified":1732671749525},{"_id":"node_modules/hexo-theme-icarus/layout/common/article.jsx","hash":"c4fc3c016de42c50614f70538a23359eee905ed3","modified":1732671749522},{"_id":"node_modules/hexo-theme-icarus/layout/common/footer.jsx","hash":"de966666f1e4ef80e0d15081b2709c3065b246dd","modified":1732671749526},{"_id":"node_modules/hexo-theme-icarus/layout/common/donates.jsx","hash":"fd52330d582fd122db7f55444c2f3368ff4bd8d7","modified":1732671749526},{"_id":"node_modules/hexo-theme-icarus/layout/common/head.jsx","hash":"bf783d5ef6d58924150472637c6c17782c83e102","modified":1732671749528},{"_id":"node_modules/hexo-theme-icarus/include/style/timeline.styl","hash":"ea61798a09bffdda07efb93c2ff800b63bddc4c4","modified":1732671749554},{"_id":"node_modules/hexo-theme-icarus/layout/common/navbar.jsx","hash":"d96e501e52861056474659f96ee0206588d8c93a","modified":1732671749528},{"_id":"node_modules/hexo-theme-icarus/layout/common/plugins.jsx","hash":"2e27800b2a8a87112c96778db858c3419d890b79","modified":1732671749529},{"_id":"node_modules/hexo-theme-icarus/layout/common/scripts.jsx","hash":"5d07312406b401e8d4e9584b4d41ed7377993935","modified":1732671749532},{"_id":"node_modules/hexo-theme-icarus/layout/common/share.jsx","hash":"0fad6f8a91bb5cf678b9ff2d66d2162d61625074","modified":1732671749533},{"_id":"node_modules/hexo-theme-icarus/layout/common/widgets.jsx","hash":"7a89ac72a988d13b4714ab78a6dfd5cd8de85d47","modified":1732671749535},{"_id":"node_modules/hexo-theme-icarus/layout/common/search.jsx","hash":"1409627d98a92b4f5b2ab829f8e6b50b75d60e53","modified":1732671749532},{"_id":"node_modules/hexo-theme-icarus/layout/plugin/animejs.jsx","hash":"e2aa27c3501a58ef1e91e511557b77395c2c02aa","modified":1732671749522},{"_id":"node_modules/hexo-theme-icarus/layout/plugin/pjax.jsx","hash":"65956102d5faabcedaaafb14b0201548f15e60ce","modified":1732671749529},{"_id":"node_modules/hexo-theme-icarus/layout/plugin/back_to_top.jsx","hash":"f86a0bae3a92bc07bd674f03a046fb1b6c1b48af","modified":1732671749524},{"_id":"node_modules/hexo-theme-icarus/layout/widget/profile.jsx","hash":"feb70ec2c849f0e08dadccbfbaa4b0940b878de2","modified":1732671749530},{"_id":"node_modules/hexo-theme-icarus/include/style/responsive.styl","hash":"207083fe287612cddee6608b541861b14ac8de81","modified":1732671749551},{"_id":"node_modules/hexo-theme-icarus/include/style/widget.styl","hash":"c746902251136544eb3fe523235b3183f4189460","modified":1732671749554},{"_id":"node_modules/hexo-theme-icarus/include/style/search.styl","hash":"416737e1da4e7e907bd03609b0fee9e2aacfe56c","modified":1732671749553},{"_id":"node_modules/hexo-theme-icarus/source/css/default.styl","hash":"b01da3028e5a1267a40aaae5c86a11187a2259e3","modified":1732671749547},{"_id":"node_modules/hexo-theme-icarus/source/img/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1732671749537},{"_id":"node_modules/hexo-theme-icarus/source/css/style.styl","hash":"5b9815586e993a6ccbe8cdcfc0c65ea38fc315ac","modified":1732671749553},{"_id":"node_modules/hexo-theme-icarus/source/js/animation.js","hash":"0a8e361c353daa3194f4de3d646b96025d128e1a","modified":1732671749496},{"_id":"node_modules/hexo-theme-icarus/source/img/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":1732671749554},{"_id":"node_modules/hexo-theme-icarus/source/js/back_to_top.js","hash":"d91f10c08c726135a13dfa1f422c49d8764ef03f","modified":1732671749497},{"_id":"node_modules/hexo-theme-icarus/source/css/cyberpunk.styl","hash":"ae17d3528df0c3f089df14a06b7bd82f1bc5fed9","modified":1732671749546},{"_id":"node_modules/hexo-theme-icarus/source/js/column.js","hash":"0baee024ab67474c073a4c41b495f3e7f0df4505","modified":1732671749498},{"_id":"node_modules/hexo-theme-icarus/source/js/main.js","hash":"37f3b16fbd9668b9496d5f2d9bd9fb22fc6cee27","modified":1732671749503},{"_id":"node_modules/hexo-theme-icarus/source/js/pjax.js","hash":"b41aa64aa965201740505376bcebbdedf607a2d4","modified":1732671749503},{"_id":"node_modules/hexo-theme-icarus/source/img/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1732671749539},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/article.json","hash":"e2502c39045c6a26ccd8e880858f93e78c7bda35","modified":1732671749507},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/comment.json","hash":"265120b80df9808358df3ff7c4eada8a66512a4b","modified":1732671749508},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/donates.json","hash":"ae86e6f177bedf4afbe638502c12635027539305","modified":1732671749510},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/head.json","hash":"98889f059c635e6bdbd51effd04cf1cf44968a66","modified":1732671749511},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/footer.json","hash":"e85c9d7f2579805beb252a1b6345d5a668a13baa","modified":1732671749511},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/plugins.json","hash":"04c0738dc0a3ed89aecae2aee4ab60173f09e66b","modified":1732671749514},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/search.json","hash":"985fbcbf47054af714ead1a124869d54f2a8b607","modified":1732671749518},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/providers.json","hash":"97ec953d497fb53594227ae98acaef8a8baa91da","modified":1732671749517},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/share.json","hash":"cf4f9ff4fb27c3541b35f57db355c228fa6873e4","modified":1732671749520},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/navbar.json","hash":"6691e587284c4cf450e0288680d5ff0f3565f090","modified":1732671749513},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/sidebar.json","hash":"eb241beaec4c73e3085dfb3139ce72e827e20549","modified":1732671749521},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/widgets.json","hash":"cadd9dc942740ecd5037d3943e72f8b6a8399bbe","modified":1732671749521},{"_id":"node_modules/hexo-theme-icarus/include/schema/plugin/animejs.json","hash":"e62ab6e20bd8862efa1ed32e7c0db0f8acbcfdec","modified":1732671749507},{"_id":"node_modules/hexo-theme-icarus/include/schema/plugin/back_to_top.json","hash":"dc0febab7e7b67075d0ad3f80f5ec8b798b68dea","modified":1732671749508},{"_id":"node_modules/hexo-theme-icarus/include/schema/plugin/pjax.json","hash":"1f6218016569eb9cd354a06a9537c7110efb5f17","modified":1732671749513},{"_id":"node_modules/hexo-theme-icarus/include/schema/widget/profile.json","hash":"690ee1b0791cab47ea03cf42b5b4932ed2aa5675","modified":1732671749515},{"_id":"node_modules/hexo-theme-icarus/source/img/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1732671749555},{"_id":"node_modules/hexo-theme-icarus/source/img/razor-top-black.svg","hash":"201f1171a43ce667a39091fe47c0f278857f18f0","modified":1732671749557},{"_id":"node_modules/hexo-theme-icarus/source/img/razor-bottom-black.svg","hash":"a3eda07b1c605b456da9cdf335a1075db5e5d72c","modified":1732671749555},{"_id":"source/_posts/java抽象类vs接口.md","hash":"c7962423f33607703817d4770ada2c2d2c14576e","modified":1732677800873},{"_id":"source/_posts/ControllerAdvice.md","hash":"1be9e923b3ce2b603f32ec9ae51dd5a690dd8132","modified":1732677635267},{"_id":"source/_posts/Spring中事务的一些特性.md","hash":"90f19de69a752c35c80a5b809a1adc7093fa59f5","modified":1732677635213},{"_id":"source/_posts/SpringMVC的Interceptor.md","hash":"82be735033fa3912d8387e2b768bed2956c097eb","modified":1732677635231},{"_id":"source/_posts/Spring扩展.md","hash":"22ee916e04ae8528b754314ef6066c26f2d90e5e","modified":1732677635258},{"_id":"source/_posts/java中强引用，软引用，弱引用，虚引用概念比较.md","hash":"7d06e473b41c8878942a024214be151bf536c279","modified":1732681214153},{"_id":"source/_posts/java多线程的一些总结.md","hash":"e2532c72aa2426424e4b93fe6e6a2ddaa2fd087b","modified":1732677635235},{"_id":"source/_posts/join的7种方式.md","hash":"8f97d7f5351912bb65d6c7a8eae1cd4b2d8d94c5","modified":1732677635204},{"_id":"source/_posts/java面试总结.md","hash":"44ec2bd6e55d4319b760f201cc4547be8ed33169","modified":1732676993019},{"_id":"source/_posts/mysql存储过程.md","hash":"a94d1c8077ac961e8b403ecd1486c5a96c6c9dad","modified":1732677635291},{"_id":"source/_posts/jsonp跨域请求.md","hash":"81404296af9935ccb67e9724db019e8e0b734403","modified":1732677635276},{"_id":"source/_posts/mybatis初步使用.md","hash":"7df6aebf23486df43322fe7ed74dfc4b00670800","modified":1732677635272},{"_id":"source/_posts/mysql事件.md","hash":"85e7f015530120b0ce7a2073d619355bd3191d3a","modified":1732677635248},{"_id":"source/_posts/mysql的索引.md","hash":"bc4eae0c247f9c3295c242f09b2b90bffc7ec7ac","modified":1732678392286},{"_id":"source/_posts/mysql的sql优化.md","hash":"0012c5a74d2420c79f9fd31a85716c275876a9f4","modified":1732677635280},{"_id":"source/_posts/mysql触发器.md","hash":"3d954fc423906b555b5011bce23ab528c506028b","modified":1732677635288},{"_id":"source/_posts/mysql自定义函数.md","hash":"bba9b1d485851bee37d89a3c7749af3c100d41d4","modified":1732678425046},{"_id":"source/_posts/spring单元测试.md","hash":"17891c09737242c874da8bc5b57507156082cd8d","modified":1732677635295},{"_id":"source/_posts/mysql视图.md","hash":"b72149cd621b64920b13ef6f8f5c8c98333e4a74","modified":1732677635284},{"_id":"source/_posts/spring定时任务.md","hash":"12725aa1e46d3b91ae4ab572b56f8d7444340148","modified":1732677741049},{"_id":"source/_posts/spring整合ActiveMQ.md","hash":"2a06be24977bac1c41377bbd28888a1aa465c520","modified":1732677635244},{"_id":"source/_posts/windows下安装redis.md","hash":"5bb69d71576312017a81faae7f15284188c8d70d","modified":1732677635222},{"_id":"source/_posts/了解aop.md","hash":"edf09c42a195e4f33e92ab815d8af5f46b4f0fe1","modified":1732677635253},{"_id":"source/_posts/了解RocketMQ.md","hash":"5a6ee6a19c58cfc29b03271aa596d825716455f1","modified":1732677635298},{"_id":"source/_posts/解决分布式事务常用的3种实现方式.md","hash":"0525ed647a5ec13841f9eadf3425a5679e9cb9ac","modified":1732677635227},{"_id":"source/_posts/获取spring中的bean.md","hash":"2b4612c17b724bac633c8c41a06fac53fb9d1fbc","modified":1732677635209},{"_id":"source/_posts/了解zookeeper.md","hash":"40712cb8186e9c9e1162506f6a41ab5f53318b15","modified":1732677635240},{"_id":"source/_posts/那些年踩过的坑——持续更新中.md","hash":"a0d6e3210d0c124e2b7b6d05eb33b8f1da8e54ca","modified":1732677825191},{"_id":"source/images/mysql/7-join-r1.png","hash":"bed0630aad9e935cee2d8983d46c604a5d90708f","modified":1732674132246},{"_id":"source/images/mysql/7-join-r2.png","hash":"31fab5a7e254b0806f4c6679b9bd55e726e89947","modified":1732674132246},{"_id":"source/images/mysql/7-join-r3.png","hash":"d5e42c7c60c696d1c7ce0f351d2ec55e8909071b","modified":1732674132246},{"_id":"source/images/mysql/result2.jpg","hash":"0212696a1f282e920188c5af473188cee346af00","modified":1732674132255},{"_id":"source/images/mysql/7-join-r4.png","hash":"9d3aa35cb3bca75bbf0fa6d4e5da854b86d7c2f1","modified":1732674132246},{"_id":"source/images/mysql/y_h_1.jpg","hash":"282422086e4576366c70081c579d164588157fe6","modified":1732674132256},{"_id":"source/images/mysql/y_h_2.jpg","hash":"81f997bb0c2a3fd5f60b6f709da5247f4db1ac66","modified":1732674132259},{"_id":"source/images/mysql/y_h_5.jpg","hash":"f7bf7912d33cd798358abd72d6c6f171ca657b07","modified":1732674132259},{"_id":"source/images/mysql/y_h_3.jpg","hash":"65b2d6d4fd32309f777aad14ca0df397f22d97db","modified":1732674132259},{"_id":"source/images/mysql/y_h_6.jpg","hash":"43fade3c1a4498a935077a7604a9503f1c6e2700","modified":1732674132260},{"_id":"source/images/mysql/y_h_7.jpg","hash":"fee5e690d685cd6f49b0c73f08b28ccb86481122","modified":1732674132260},{"_id":"source/images/mysql/y_h_8.jpg","hash":"247712daa95f1cf659453aaecf3ccd46061c36db","modified":1732674132260},{"_id":"source/images/mysql/y_h_9.jpg","hash":"13fbdf0702a11e28456d2ddc582ff29600edf92a","modified":1732674132260},{"_id":"source/images/mysql/y_h_4.jpg","hash":"7c155fa2e002a875c2455ee6bba6e48e19d53ac6","modified":1732674132259},{"_id":"source/images/mysql/result1.jpg","hash":"44e1d2988eb71381a32113f336d9d353db5990e7","modified":1732674132254},{"_id":"source/images/mysql/index_lose.png","hash":"368a590ccc2e5e37a4b5e95009158bac7e216984","modified":1732674132254},{"_id":"source/images/mysql/y_h_10.jpg","hash":"41188c6582e695ada3c89ef126b3573f08f3e5e7","modified":1732674132257},{"_id":"source/images/mysql/sql_slow.jpg","hash":"d1bd04758000e99c30c5cf6e83fd39354876ea9c","modified":1732674132256},{"_id":"source/images/mysql/y_h_11.jpg","hash":"c1f9d616c324e81a69d42b335fa27ccbfc63b3b9","modified":1732674132259},{"_id":"source/images/mysql/idx_.jpg","hash":"1dbc5b414961ace213d27a5474587cb4342865f1","modified":1732674132251},{"_id":"source/images/mysql/7-join.png","hash":"828106957011c19d07d2719d7d062ae609e79ded","modified":1732674132249},{"_id":"source/_data/menu.yml","hash":"3c047776441f4e70b4117bfe53e5e4cd4586a37e","modified":1732678802986},{"_id":"source/_posts/AOP初步学习.md","hash":"373bdc7b093b3868716c6c52eb738d4f3c458106","modified":1732678972239},{"_id":"source/_posts/rocketmq初步学习.md","hash":"7bd01c77027b58d148962b5dc609467cbabd035a","modified":1732678942231},{"_id":"source/_posts/zookeeper初步学习.md","hash":"1b338ea85abc72427584ccea6476942ca321d720","modified":1732678843069},{"_id":"source/images/20160515P2.jpg","hash":"79527cd6d64cfcb02d09fa35b8a12489834ab330","modified":1556037252000},{"_id":"source/images/20160515P1.jpg","hash":"20e29dc08a52655e280f29db719ce430825b97d4","modified":1556037252000},{"_id":"source/images/20160515P3.jpg","hash":"027bdfebf91cd7f263b1abd18300c25aa3d7c183","modified":1556037252000},{"_id":"public/2024/11/27/hexo使用/index.html","hash":"dbf677aa307a5a02ec182de0a52b064cdfae6677","modified":1732684611258},{"_id":"public/2017/10/17/spring单元测试/index.html","hash":"9cc8002a37853d5dcf7767993faa135fc605d03d","modified":1732684611258},{"_id":"public/2017/09/16/jsonp跨域请求/index.html","hash":"5b491e0bb8a1d3956acb7f1257e32065bdd87393","modified":1732684611258},{"_id":"public/2017/09/15/mybatis初步使用/index.html","hash":"92fe3d1491a6dbf5e3fc2df97d1ad25eb2d1ba6c","modified":1732684611258},{"_id":"public/2017/09/14/ControllerAdvice/index.html","hash":"3aea50733cc8621bf6dc449dc869a971c0cc263a","modified":1732684611258},{"_id":"public/2017/09/13/SpringMVC的Interceptor/index.html","hash":"e4fce0e02cabd3b2cd61006cd6a7df8bec125a1d","modified":1732684611258},{"_id":"public/2017/09/13/AOP初步学习/index.html","hash":"5805918a3c4fb442d9366f436412e62da9da31d9","modified":1732684611258},{"_id":"public/2017/09/12/zookeeper初步学习/index.html","hash":"cd8051a4ef1dbee56f70eb36bf075e55d67b84c1","modified":1732684611258},{"_id":"public/2017/09/11/解决分布式事务常用的3种实现方式/index.html","hash":"0823831d5d9f75ab543c0978031e1dbc146f479a","modified":1732684611258},{"_id":"public/2017/09/08/rocketmq初步学习/index.html","hash":"d56186781cc8ae926dfedfce66b81308d5dd98d9","modified":1732684611258},{"_id":"public/2017/07/24/java多线程的一些总结/index.html","hash":"1ed42352a9575c40132028304171d621c32afde4","modified":1732684611258},{"_id":"public/2017/05/23/Spring中事务的一些特性/index.html","hash":"c0ce0b6712ae5a8486a94cc106117760f18597fd","modified":1732684611258},{"_id":"public/2017/05/22/Spring扩展/index.html","hash":"466ee9d85af50b2319e882f462fbbd8319dceb0f","modified":1732684611258},{"_id":"public/2017/05/17/java面试总结/index.html","hash":"d0a407ef9fbe74f5841c24ebb07473bf2431828c","modified":1732684611258},{"_id":"public/2016/12/13/spring整合ActiveMQ/index.html","hash":"92b382b779200c3529fbe8ec375ace26605ba9f6","modified":1732684611258},{"_id":"public/2016/11/16/windows下安装redis/index.html","hash":"318d258525f6749eea5a1aa5a0d398a31b5b6fca","modified":1732684611258},{"_id":"public/2016/10/01/获取spring中的bean/index.html","hash":"8a985bca25aefd2ac67fe781db166e8f1af8fc2d","modified":1732684611258},{"_id":"public/2016/08/15/mysql事件/index.html","hash":"dbbab58ad3c7cff637a0cdd559c0d6c4663fec0b","modified":1732684611258},{"_id":"public/2016/08/14/mysql触发器/index.html","hash":"1d7137f98e66c48ed4200655f7f766db7e719b1d","modified":1732684611258},{"_id":"public/2016/08/13/mysql视图/index.html","hash":"6b2485fd606faedbf23b0c8813b6847645edc0ab","modified":1732684611258},{"_id":"public/2016/08/12/mysql存储过程/index.html","hash":"4855710fdc8eac3e0eadecef54c5a51d308d5dff","modified":1732684611258},{"_id":"public/2016/08/11/mysql自定义函数/index.html","hash":"9aacd16c008dc8027322cb0e14655107559e9630","modified":1732684611258},{"_id":"public/2016/08/03/mysql的sql优化/index.html","hash":"eb10593ed887b8c275059ba07d446d6e1393164f","modified":1732684611258},{"_id":"public/2016/08/02/join的7种方式/index.html","hash":"e38b19389e7db3838d1ab42f91a3d59438f51c3b","modified":1732684611258},{"_id":"public/2016/08/01/mysql的索引/index.html","hash":"6532b2421696bc36937b4424f5e7c9205ced35ce","modified":1732684611258},{"_id":"public/2016/05/01/spring定时任务/index.html","hash":"194bfd5d1da9ddc4d639dae77c9ce829346b6caa","modified":1732684611258},{"_id":"public/2016/03/15/java中强引用，软引用，弱引用，虚引用概念比较/index.html","hash":"21b117b290fbd8bf08c2860db99b17ad7fda212a","modified":1732684611258},{"_id":"public/2016/02/22/那些年踩过的坑——持续更新中/index.html","hash":"aa439425bf5b50b2e920f141154945215b2455fe","modified":1732684611258},{"_id":"public/archives/page/2/index.html","hash":"b9b0ade3f69dab51f627855694df82d95ebf377f","modified":1732684611258},{"_id":"public/archives/page/3/index.html","hash":"1d62f1b68a34a5dae078c30cde4ea9a50abc882e","modified":1732684611258},{"_id":"public/2016/02/21/java抽象类vs接口/index.html","hash":"0582bcc8a3734b3629f5a4b2936c835115a35640","modified":1732684611258},{"_id":"public/archives/2016/index.html","hash":"9dc93a6b4222d6f4ffc4274f1cba134a61d9f2c6","modified":1732684611258},{"_id":"public/archives/2016/page/2/index.html","hash":"9187eb85a78e61a738d55ab06944008d3d21e683","modified":1732684611258},{"_id":"public/archives/2016/02/index.html","hash":"cb97ec8177e1f20fae8cbb29572de0bfcc459c5c","modified":1732684611258},{"_id":"public/archives/2016/03/index.html","hash":"a21132408facd9248897fd1ac9b0a223d64e0c87","modified":1732684611258},{"_id":"public/archives/2016/05/index.html","hash":"505f5f70a0d9b191810568689357a03919834a5c","modified":1732684611258},{"_id":"public/archives/2016/08/index.html","hash":"72f7dca907b4e0d00c7060e7874e89eb2645efdb","modified":1732684611258},{"_id":"public/archives/2016/10/index.html","hash":"55ee314c416901bde0058bd1b527458f07b37b75","modified":1732684611258},{"_id":"public/archives/2016/11/index.html","hash":"5dd942c237f2dd5f76b54824cf20c830c17a3634","modified":1732684611258},{"_id":"public/archives/2016/12/index.html","hash":"3cf91344bcd1a74e06b12d0192ad6524b58ece65","modified":1732684611258},{"_id":"public/archives/2017/index.html","hash":"1755daaa23367a5eb44d7fa024309bb01cb83276","modified":1732684611258},{"_id":"public/archives/2017/page/2/index.html","hash":"983d29640c152aa126f5ebd1d84e7b3492c79d1c","modified":1732684611258},{"_id":"public/archives/2017/05/index.html","hash":"f382d29be4939a468f907d9ac25557d9601d71b7","modified":1732684611258},{"_id":"public/archives/2017/07/index.html","hash":"3237b71e3738007ec1ccee8dc095a0b07011acf3","modified":1732684611258},{"_id":"public/archives/2017/09/index.html","hash":"68caff3d59944aa20f765bbc5168ddb37ebf566d","modified":1732684611258},{"_id":"public/page/2/index.html","hash":"a3c64b54c4c2ba9a22b1458f8bca0f42f10596ce","modified":1732684611258},{"_id":"public/page/3/index.html","hash":"56e2dc8ceb48cb09ae8f61a2168b946644de2bca","modified":1732684611258},{"_id":"public/archives/2017/10/index.html","hash":"26216f34de9eaa64eb261497d971cd0bd32cd8c7","modified":1732684611258},{"_id":"public/categories/JAVA/index.html","hash":"b5dc2476e3dbe3bc924238b3e9eb0f9baee95d27","modified":1732684611258},{"_id":"public/categories/Spring/index.html","hash":"5be28e35ec2f83ed9ff9b5e5b014376d14fd8ca6","modified":1732684611258},{"_id":"public/categories/MQ/index.html","hash":"38ed91e1eb9e3faf8710d8eba4fe917340291f0f","modified":1732684611258},{"_id":"public/categories/Redis/index.html","hash":"f805b5f562aed342afa39ae0a6308c4b759a5932","modified":1732684611258},{"_id":"public/categories/分布式事务/index.html","hash":"00a3c283df41596efd150f99c2286fd2c4bf511e","modified":1732684611258},{"_id":"public/categories/zookeeper/index.html","hash":"d4891225d9183ca2cf4330fb634771ab3e8c6828","modified":1732684611258},{"_id":"public/categories/Mybatis/index.html","hash":"cdc07b35a0bf8a0ffff3ba92675178049cb11efb","modified":1732684611258},{"_id":"public/categories/AJAX/index.html","hash":"4bfa5d52cc365d567e211823ae32e277861354de","modified":1732684611258},{"_id":"public/categories/经验/index.html","hash":"8be1ede82726d9748c89465471438b77b9e6895f","modified":1732684611258},{"_id":"public/categories/spring/index.html","hash":"b122c14407e86c7b7b17549d956398d48eefadc6","modified":1732684611258},{"_id":"public/categories/工具/index.html","hash":"99f9d08bd017fb029d3ce5fc7e612a89595a46a3","modified":1732684611258},{"_id":"public/categories/数据库/index.html","hash":"5ab9360ef79a07643fc9014868180a9821b41d84","modified":1732684611258},{"_id":"public/tags/java/index.html","hash":"fbb7e6b9bec86ccb45f59ad6023a3a11fa98c1ad","modified":1732684611258},{"_id":"public/tags/mysql/index.html","hash":"713e5fa3c084b5c277739ae4d11785d5a15c60ce","modified":1732684611258},{"_id":"public/tags/bean/index.html","hash":"577f913763793b2fb4f193820e218868a4b08173","modified":1732684611258},{"_id":"public/tags/redis/index.html","hash":"8c194d702ee391f3a93dea84d920d468978b285f","modified":1732684611258},{"_id":"public/tags/rocketmq/index.html","hash":"5eb5d1e4ee5289cb13969a6a2020483215381c5f","modified":1732684611258},{"_id":"public/tags/分布式事务/index.html","hash":"3d0df3dd5b6456a2a15fc591dc211f6fc2a896dc","modified":1732684611258},{"_id":"public/tags/aop/index.html","hash":"7a76e70ca0bd796c91401502a3eb83e455abcaf5","modified":1732684611258},{"_id":"public/tags/zookeeper/index.html","hash":"f9d9eb8c5d9950139fb1a4d757c6b741a81552f4","modified":1732684611258},{"_id":"public/tags/mybatis/index.html","hash":"dd0795b74fe89425a46af41ca9b8c870d0ca26c1","modified":1732684611258},{"_id":"public/tags/js/index.html","hash":"a69a287dcc184611a3cca423501445d09369766e","modified":1732684611258},{"_id":"public/tags/mvc/index.html","hash":"068c2e1f41cb36c2dd2e55f7c1721d1fce7c23c8","modified":1732684611258},{"_id":"public/tags/hexo/index.html","hash":"ecffae1c2a1c7ed5cb4802c280e550bbe216b6ab","modified":1732684611258},{"_id":"public/tags/基础知识/index.html","hash":"e04ebec34524e50f25e47fd5dac89375824c4a0d","modified":1732684611258},{"_id":"public/tags/面试/index.html","hash":"7be1a0fa0db64496d3df99aed27a851ad120d9ac","modified":1732684611258},{"_id":"public/tags/事务/index.html","hash":"ae1313951a5ddf91d925b0b13c1ae42e8218d2c5","modified":1732684611258},{"_id":"public/tags/单元测试/index.html","hash":"ecc28f8dbd5e8ecd7c905faaa7b5dca1ea9d8c49","modified":1732684611258},{"_id":"public/tags/定时任务/index.html","hash":"049a7bffcf103d6c7c21465f68f88f3403a3b7c8","modified":1732684611258},{"_id":"public/tags/扩展/index.html","hash":"d3cdaae393c8acb973931f0befe0576afa4b8f11","modified":1732684611258},{"_id":"public/tags/整合/index.html","hash":"eb6c3664e111fd7512bad4944f8d947d1d8d5348","modified":1732684611258},{"_id":"public/images/zk/zk_wa.png","hash":"4aad2714e358718fec89b9c3f9503bd836fc1fb3","modified":1732684611258},{"_id":"public/images/zk/zk_1.jpg","hash":"d122fcac106bc7683d39df78e0cdfd9872ffdce2","modified":1732684611258},{"_id":"public/images/mysql/7-join-r1.png","hash":"bed0630aad9e935cee2d8983d46c604a5d90708f","modified":1732684611258},{"_id":"public/images/mysql/7-join-r2.png","hash":"31fab5a7e254b0806f4c6679b9bd55e726e89947","modified":1732684611258},{"_id":"public/images/mysql/7-join-r3.png","hash":"d5e42c7c60c696d1c7ce0f351d2ec55e8909071b","modified":1732684611258},{"_id":"public/images/mysql/7-join-r4.png","hash":"9d3aa35cb3bca75bbf0fa6d4e5da854b86d7c2f1","modified":1732684611258},{"_id":"public/images/mysql/y_h_1.jpg","hash":"282422086e4576366c70081c579d164588157fe6","modified":1732684611258},{"_id":"public/images/mysql/y_h_2.jpg","hash":"81f997bb0c2a3fd5f60b6f709da5247f4db1ac66","modified":1732684611258},{"_id":"public/images/mysql/y_h_3.jpg","hash":"65b2d6d4fd32309f777aad14ca0df397f22d97db","modified":1732684611258},{"_id":"public/images/mysql/y_h_4.jpg","hash":"7c155fa2e002a875c2455ee6bba6e48e19d53ac6","modified":1732684611258},{"_id":"public/images/mysql/y_h_5.jpg","hash":"f7bf7912d33cd798358abd72d6c6f171ca657b07","modified":1732684611258},{"_id":"public/images/mysql/y_h_6.jpg","hash":"43fade3c1a4498a935077a7604a9503f1c6e2700","modified":1732684611258},{"_id":"public/images/mysql/y_h_7.jpg","hash":"fee5e690d685cd6f49b0c73f08b28ccb86481122","modified":1732684611258},{"_id":"public/images/mysql/result2.jpg","hash":"0212696a1f282e920188c5af473188cee346af00","modified":1732684611258},{"_id":"public/images/mysql/y_h_8.jpg","hash":"247712daa95f1cf659453aaecf3ccd46061c36db","modified":1732684611258},{"_id":"public/images/mysql/y_h_9.jpg","hash":"13fbdf0702a11e28456d2ddc582ff29600edf92a","modified":1732684611258},{"_id":"public/images/20160515P2.jpg","hash":"79527cd6d64cfcb02d09fa35b8a12489834ab330","modified":1732684611258},{"_id":"public/images/20160515P1.jpg","hash":"20e29dc08a52655e280f29db719ce430825b97d4","modified":1732684611258},{"_id":"public/images/mysql/result1.jpg","hash":"44e1d2988eb71381a32113f336d9d353db5990e7","modified":1732684611258},{"_id":"public/images/20160515P3.jpg","hash":"027bdfebf91cd7f263b1abd18300c25aa3d7c183","modified":1732684611258},{"_id":"public/images/mysql/index_lose.png","hash":"368a590ccc2e5e37a4b5e95009158bac7e216984","modified":1732684611258},{"_id":"public/images/mysql/y_h_10.jpg","hash":"41188c6582e695ada3c89ef126b3573f08f3e5e7","modified":1732684611258},{"_id":"public/images/mysql/sql_slow.jpg","hash":"d1bd04758000e99c30c5cf6e83fd39354876ea9c","modified":1732684611258},{"_id":"public/images/20160221P1.jpg","hash":"157018030dcdc470896ee06e91012f8f2015f8a1","modified":1732684611258},{"_id":"public/images/mysql/y_h_11.jpg","hash":"c1f9d616c324e81a69d42b335fa27ccbfc63b3b9","modified":1732684611258},{"_id":"public/images/mysql/idx_.jpg","hash":"1dbc5b414961ace213d27a5474587cb4342865f1","modified":1732684611258},{"_id":"public/images/mysql/7-join.png","hash":"828106957011c19d07d2719d7d062ae609e79ded","modified":1732684611258}],"Category":[{"name":"JAVA","_id":"cm3ygho800002hsu68rrkagtl"},{"name":"MySQL","_id":"cm3ygho85000ihsu6f4ynbicv"},{"name":"Spring","_id":"cm3ygho88000whsu67izoaqb2"},{"name":"MQ","_id":"cm3ygho8d001yhsu6911veq6y"},{"name":"Redis","_id":"cm3ygho8e0026hsu60tqpezdt"},{"name":"面试","_id":"cm3ygho8f002ehsu66h0iddvy"},{"name":"RocketMq","_id":"cm3ygho8f002jhsu60m4bc337"},{"name":"分布式事务","_id":"cm3ygho8g002ohsu6bvul6ei2"},{"name":"aop","_id":"cm3ygho8g002shsu6fyxbbdky"},{"name":"zookeeper","_id":"cm3ygho8g002whsu6g3dz64gk"},{"name":"Mybatis","_id":"cm3ygho8h0030hsu6ba29ccx7"},{"name":"AJAX","_id":"cm3ygho8h0034hsu68s7a18uz"},{"name":"经验","_id":"cm3zb30x000025cu667370u97"},{"name":"spring","_id":"cm3zb3au400055cu611q4caar"},{"name":"工具","_id":"cm3zb3nwb000a5cu66zmt4zre"},{"name":"数据库","_id":"cm3zb58ei000p5cu6darv430y"}],"Data":[{"_id":"menu","data":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}],"Page":[],"Post":[{"title":"hexo使用","excerpt":"纯文本的页面摘要。 使用该插件来格式化文本","date":"2024-11-27T12:33:00.000Z","_content":"\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more\ninfo. If you get any problems when using Hexo, you can find the answer\nin [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me\non [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n\n{% post_link hexo使用 %}","source":"_posts/hexo使用.md","raw":"---\ntitle: hexo使用\nexcerpt: 纯文本的页面摘要。 使用该插件来格式化文本\ndate: 2024.11.27 20:33:00\ncategory: 工具\ntags:\n  - hexo\n---\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more\ninfo. If you get any problems when using Hexo, you can find the answer\nin [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me\non [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n\n{% post_link hexo使用 %}","slug":"hexo使用","published":1,"updated":"2024-11-27T03:34:28.029Z","_id":"cm3z7jir900001gu65vmyc2az","comments":1,"layout":"post","photos":[],"content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more<br>info. If you get any problems when using Hexo, you can find the answer<br>in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me<br>on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n<a href=\"/2024/11/27/hexo%E4%BD%BF%E7%94%A8/\" title=\"hexo使用\">hexo使用</a>","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more<br>info. If you get any problems when using Hexo, you can find the answer<br>in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me<br>on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n<a href=\"/2024/11/27/hexo%E4%BD%BF%E7%94%A8/\" title=\"hexo使用\">hexo使用</a>"},{"title":"java抽象类vs接口","date":"2016-02-21T12:33:00.000Z","_content":"\n### 1.JAVA抽象类:\n\n抽象类除了不能实例化以外，跟普通类没有任何区别。在《JAVA编程思想》一书中，将抽象类定义为“包含抽象方法的类”。\n\n### 2.JAVA接口:\n\n接口，英文称作interface，是对事物最高层次的抽象，用来供别人调用的方法或者函数。\n\n## JAVA抽象类和接口的主要区别如下图:\n\n![cmd-markdown-logo](../images/20160221P1.jpg)\n\n### 什么时候使用抽象类和接口\n\n首先，我们要先弄清楚抽象类和接口之间的关系：\n> * 类对事物的抽象，定义了事物的属性和行为。\n>* 抽象类是不完全的类，具有抽象方法。\n>* 接口则比类的抽象层次更高。\n\n所以，我们可以这样理解它们之间的关系：**类是对事物的抽象，抽象类是对类的抽象，接口是对抽象类的抽象**。\n\n在设计类的时候，首先考虑用接口抽象出类的特性，当你发现某些方法可以复用的时候，可以使用抽象类来复用代码。简单说，*\n*接口用于抽象事物的特性，抽象类用于代码复用。**","source":"_posts/java抽象类vs接口.md","raw":"---\ntitle: java抽象类vs接口\ndate: 2016.02.21 20:33:00\ncategory: JAVA\ntags:\n  - 基础知识\n---\n\n### 1.JAVA抽象类:\n\n抽象类除了不能实例化以外，跟普通类没有任何区别。在《JAVA编程思想》一书中，将抽象类定义为“包含抽象方法的类”。\n\n### 2.JAVA接口:\n\n接口，英文称作interface，是对事物最高层次的抽象，用来供别人调用的方法或者函数。\n\n## JAVA抽象类和接口的主要区别如下图:\n\n![cmd-markdown-logo](../images/20160221P1.jpg)\n\n### 什么时候使用抽象类和接口\n\n首先，我们要先弄清楚抽象类和接口之间的关系：\n> * 类对事物的抽象，定义了事物的属性和行为。\n>* 抽象类是不完全的类，具有抽象方法。\n>* 接口则比类的抽象层次更高。\n\n所以，我们可以这样理解它们之间的关系：**类是对事物的抽象，抽象类是对类的抽象，接口是对抽象类的抽象**。\n\n在设计类的时候，首先考虑用接口抽象出类的特性，当你发现某些方法可以复用的时候，可以使用抽象类来复用代码。简单说，*\n*接口用于抽象事物的特性，抽象类用于代码复用。**","slug":"java抽象类vs接口","published":1,"updated":"2024-11-27T03:23:20.873Z","_id":"cm3z9ugxj00044ou68da19syv","comments":1,"layout":"post","photos":[],"content":"<h3 id=\"1-JAVA抽象类\"><a href=\"#1-JAVA抽象类\" class=\"headerlink\" title=\"1.JAVA抽象类:\"></a>1.JAVA抽象类:</h3><p>抽象类除了不能实例化以外，跟普通类没有任何区别。在《JAVA编程思想》一书中，将抽象类定义为“包含抽象方法的类”。</p>\n<h3 id=\"2-JAVA接口\"><a href=\"#2-JAVA接口\" class=\"headerlink\" title=\"2.JAVA接口:\"></a>2.JAVA接口:</h3><p>接口，英文称作interface，是对事物最高层次的抽象，用来供别人调用的方法或者函数。</p>\n<h2 id=\"JAVA抽象类和接口的主要区别如下图\"><a href=\"#JAVA抽象类和接口的主要区别如下图\" class=\"headerlink\" title=\"JAVA抽象类和接口的主要区别如下图:\"></a>JAVA抽象类和接口的主要区别如下图:</h2><p><img src=\"/../images/20160221P1.jpg\" alt=\"cmd-markdown-logo\"></p>\n<h3 id=\"什么时候使用抽象类和接口\"><a href=\"#什么时候使用抽象类和接口\" class=\"headerlink\" title=\"什么时候使用抽象类和接口\"></a>什么时候使用抽象类和接口</h3><p>首先，我们要先弄清楚抽象类和接口之间的关系：</p>\n<blockquote>\n<ul>\n<li>类对事物的抽象，定义了事物的属性和行为。</li>\n<li>抽象类是不完全的类，具有抽象方法。</li>\n<li>接口则比类的抽象层次更高。</li>\n</ul>\n</blockquote>\n<p>所以，我们可以这样理解它们之间的关系：<strong>类是对事物的抽象，抽象类是对类的抽象，接口是对抽象类的抽象</strong>。</p>\n<p>在设计类的时候，首先考虑用接口抽象出类的特性，当你发现某些方法可以复用的时候，可以使用抽象类来复用代码。简单说，*<br><em>接口用于抽象事物的特性，抽象类用于代码复用。</em>*</p>\n","excerpt":"","more":"<h3 id=\"1-JAVA抽象类\"><a href=\"#1-JAVA抽象类\" class=\"headerlink\" title=\"1.JAVA抽象类:\"></a>1.JAVA抽象类:</h3><p>抽象类除了不能实例化以外，跟普通类没有任何区别。在《JAVA编程思想》一书中，将抽象类定义为“包含抽象方法的类”。</p>\n<h3 id=\"2-JAVA接口\"><a href=\"#2-JAVA接口\" class=\"headerlink\" title=\"2.JAVA接口:\"></a>2.JAVA接口:</h3><p>接口，英文称作interface，是对事物最高层次的抽象，用来供别人调用的方法或者函数。</p>\n<h2 id=\"JAVA抽象类和接口的主要区别如下图\"><a href=\"#JAVA抽象类和接口的主要区别如下图\" class=\"headerlink\" title=\"JAVA抽象类和接口的主要区别如下图:\"></a>JAVA抽象类和接口的主要区别如下图:</h2><p><img src=\"/../images/20160221P1.jpg\" alt=\"cmd-markdown-logo\"></p>\n<h3 id=\"什么时候使用抽象类和接口\"><a href=\"#什么时候使用抽象类和接口\" class=\"headerlink\" title=\"什么时候使用抽象类和接口\"></a>什么时候使用抽象类和接口</h3><p>首先，我们要先弄清楚抽象类和接口之间的关系：</p>\n<blockquote>\n<ul>\n<li>类对事物的抽象，定义了事物的属性和行为。</li>\n<li>抽象类是不完全的类，具有抽象方法。</li>\n<li>接口则比类的抽象层次更高。</li>\n</ul>\n</blockquote>\n<p>所以，我们可以这样理解它们之间的关系：<strong>类是对事物的抽象，抽象类是对类的抽象，接口是对抽象类的抽象</strong>。</p>\n<p>在设计类的时候，首先考虑用接口抽象出类的特性，当你发现某些方法可以复用的时候，可以使用抽象类来复用代码。简单说，*<br><em>接口用于抽象事物的特性，抽象类用于代码复用。</em>*</p>\n"},{"title":"spring mvc advice","date":"2017-09-14T01:00:00.000Z","_content":"\n## ControllerAdvice\n\n**`ControllerAdvice`**\n\n1. Controller的增强\n2. 每个请求都会进入\n3. @ExceptionHandler(Exception.class) 可以有多个但是，捕获的异常不能一样，@Controller中的 @ExceptionHandler覆盖\n   @ControllerAdvice中的 @ExceptionHandler可以看作就近原则。\n\n**`2.具体说明`**\n\n\t@ControllerAdvice\n\tpublic class ExceptionAdvice {\n\t\n\t\t@ModelAttribute\n\t\tpublic Object addObject() {\n\t\t\treturn new Object();\n\t\t}\n\t\n\t\t@InitBinder\n\t\tpublic void initBinder(WebDataBinder binder) {\n\t\t}\n\t\n\t\t@ExceptionHandler(Exception.class)\n\t\tpublic ModelAndView proceException(HttpServletRequest request, HttpServletResponse response,Exception ex) {\n\t\t\tex.printStackTrace();\n\t\t\tModelAndView modelAndView = new ModelAndView();\n\t\t\tif ((request.getHeader(\"accept\").contains(\"application/json\") || (request.getHeader(\"X-Requested-With\") != null && request.getHeader(\"X-Requested-With\").contains(\"XMLHttpRequest\")))) {\n\t\t\t\tresponse.setCharacterEncoding(\"UTF-8\");\n\t\t\t\ttry {\n\t\t\t\t\tresponse.getWriter().print(JSON.toJSONString(\" is ajax \"));\n\t\t\t\t\tresponse.flushBuffer();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\tmodelAndView.setViewName(\"err\");\n\t\t\t\treturn modelAndView;\n\t\t\t}\n\t\t}\n\t}\n","source":"_posts/ControllerAdvice.md","raw":"---\ntitle: \"spring mvc advice\"\ndate: 2017-09-14 09:00:00\ncategory: spring\ntags:\n  - mvc\n---\n\n## ControllerAdvice\n\n**`ControllerAdvice`**\n\n1. Controller的增强\n2. 每个请求都会进入\n3. @ExceptionHandler(Exception.class) 可以有多个但是，捕获的异常不能一样，@Controller中的 @ExceptionHandler覆盖\n   @ControllerAdvice中的 @ExceptionHandler可以看作就近原则。\n\n**`2.具体说明`**\n\n\t@ControllerAdvice\n\tpublic class ExceptionAdvice {\n\t\n\t\t@ModelAttribute\n\t\tpublic Object addObject() {\n\t\t\treturn new Object();\n\t\t}\n\t\n\t\t@InitBinder\n\t\tpublic void initBinder(WebDataBinder binder) {\n\t\t}\n\t\n\t\t@ExceptionHandler(Exception.class)\n\t\tpublic ModelAndView proceException(HttpServletRequest request, HttpServletResponse response,Exception ex) {\n\t\t\tex.printStackTrace();\n\t\t\tModelAndView modelAndView = new ModelAndView();\n\t\t\tif ((request.getHeader(\"accept\").contains(\"application/json\") || (request.getHeader(\"X-Requested-With\") != null && request.getHeader(\"X-Requested-With\").contains(\"XMLHttpRequest\")))) {\n\t\t\t\tresponse.setCharacterEncoding(\"UTF-8\");\n\t\t\t\ttry {\n\t\t\t\t\tresponse.getWriter().print(JSON.toJSONString(\" is ajax \"));\n\t\t\t\t\tresponse.flushBuffer();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\tmodelAndView.setViewName(\"err\");\n\t\t\t\treturn modelAndView;\n\t\t\t}\n\t\t}\n\t}\n","slug":"ControllerAdvice","published":1,"updated":"2024-11-27T03:20:35.267Z","_id":"cm3zaz9bx0000tgu6205z3lbj","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"ControllerAdvice\"><a href=\"#ControllerAdvice\" class=\"headerlink\" title=\"ControllerAdvice\"></a>ControllerAdvice</h2><p><strong><code>ControllerAdvice</code></strong></p>\n<ol>\n<li>Controller的增强</li>\n<li>每个请求都会进入</li>\n<li>@ExceptionHandler(Exception.class) 可以有多个但是，捕获的异常不能一样，@Controller中的 @ExceptionHandler覆盖<br>@ControllerAdvice中的 @ExceptionHandler可以看作就近原则。</li>\n</ol>\n<p><strong><code>2.具体说明</code></strong></p>\n<pre><code>@ControllerAdvice\npublic class ExceptionAdvice &#123;\n\n    @ModelAttribute\n    public Object addObject() &#123;\n        return new Object();\n    &#125;\n\n    @InitBinder\n    public void initBinder(WebDataBinder binder) &#123;\n    &#125;\n\n    @ExceptionHandler(Exception.class)\n    public ModelAndView proceException(HttpServletRequest request, HttpServletResponse response,Exception ex) &#123;\n        ex.printStackTrace();\n        ModelAndView modelAndView = new ModelAndView();\n        if ((request.getHeader(&quot;accept&quot;).contains(&quot;application/json&quot;) || (request.getHeader(&quot;X-Requested-With&quot;) != null &amp;&amp; request.getHeader(&quot;X-Requested-With&quot;).contains(&quot;XMLHttpRequest&quot;)))) &#123;\n            response.setCharacterEncoding(&quot;UTF-8&quot;);\n            try &#123;\n                response.getWriter().print(JSON.toJSONString(&quot; is ajax &quot;));\n                response.flushBuffer();\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n            return null;\n        &#125; else &#123;\n            modelAndView.setViewName(&quot;err&quot;);\n            return modelAndView;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n","excerpt":"","more":"<h2 id=\"ControllerAdvice\"><a href=\"#ControllerAdvice\" class=\"headerlink\" title=\"ControllerAdvice\"></a>ControllerAdvice</h2><p><strong><code>ControllerAdvice</code></strong></p>\n<ol>\n<li>Controller的增强</li>\n<li>每个请求都会进入</li>\n<li>@ExceptionHandler(Exception.class) 可以有多个但是，捕获的异常不能一样，@Controller中的 @ExceptionHandler覆盖<br>@ControllerAdvice中的 @ExceptionHandler可以看作就近原则。</li>\n</ol>\n<p><strong><code>2.具体说明</code></strong></p>\n<pre><code>@ControllerAdvice\npublic class ExceptionAdvice &#123;\n\n    @ModelAttribute\n    public Object addObject() &#123;\n        return new Object();\n    &#125;\n\n    @InitBinder\n    public void initBinder(WebDataBinder binder) &#123;\n    &#125;\n\n    @ExceptionHandler(Exception.class)\n    public ModelAndView proceException(HttpServletRequest request, HttpServletResponse response,Exception ex) &#123;\n        ex.printStackTrace();\n        ModelAndView modelAndView = new ModelAndView();\n        if ((request.getHeader(&quot;accept&quot;).contains(&quot;application/json&quot;) || (request.getHeader(&quot;X-Requested-With&quot;) != null &amp;&amp; request.getHeader(&quot;X-Requested-With&quot;).contains(&quot;XMLHttpRequest&quot;)))) &#123;\n            response.setCharacterEncoding(&quot;UTF-8&quot;);\n            try &#123;\n                response.getWriter().print(JSON.toJSONString(&quot; is ajax &quot;));\n                response.flushBuffer();\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n            return null;\n        &#125; else &#123;\n            modelAndView.setViewName(&quot;err&quot;);\n            return modelAndView;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"Spring中事务的一些特性","date":"2017-05-23T01:00:00.000Z","_content":" \n# 数据库的四大特性\n----------------\n\n### 特性\n\n1. 原子性（Atomicity): 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。\n\n2. 一致性（Consistency):\n   一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。\n\n3. 隔离性（Isolation):\n   隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。\n\n4. 持久性（Durability): 持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。\n\n### 几种问题\n\n1. 脏读: 是指在一个事务处理过程里读取了另一个未提交的事务中的数据。当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。\n2. 不可重复读:\n   不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题，例如对于同一个数据A和B依次查询就可能不同，A和B就可能打起来了……\n3. 虚读(幻读):\n   幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。\n\n# 五个事务隔级别\n----------------\n\n### 事务隔级别\n\n1. default 默认的事务隔离级别(Repeatable read)\n2. Read uncommitted (读未提交)：最低级别，任何情况都无法保证。\n3. Repeatable read (可重复读)：可避免脏读、不可重复读的发生。\n4. Read committed (读已提交)：可避免脏读的发生。\n6. Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。\n\n> * 隔离级别最高的是Serializable级别，最低的是Read uncommitted级别，当然级别越高，执行效率就越低。\n\n\n# 七个事务的传播行为\n----------------\n\n### 事务的传播行为\n\n1. propagation_required 如果一个事务存在，则支持当前事务，如果不存在，则创建新的事务。\n2. propagation_supports 如果一个事务存在，则支持当前事务，如果不存在，则非事务的方法运行。\n3. propagation_mendatory 如果一个事务存在，则支持当前事务，如果存在，则抛出异常。\n4. propagation_requires_new 总是要开启一个新的事务，如果事务存在，将该事务挂起。\n5. propagation_not_supported 总是非事务方法运行，并挂起所有的事务。\n6. propagation_never 总是非事务方法运行，如果事务存在则抛出异常\n7. propagation_nested 某一个事务存在，则运行在一个嵌套的事务中。\n\n> **配置方式** :\n\n\t<tx:method name=\"save*\" propagation=\"REQUIRED\" isolation=\"DEFAULT\" />\n\n\t@Transactional(propagation=Propagation.REQUIRED,isolation=Isolation.DEFAULT)\n","source":"_posts/Spring中事务的一些特性.md","raw":"---\ntitle: \"Spring中事务的一些特性\"\ndate: 2017-05-23 09:00:00\ncategories: Spring\ntags:\n  - 事务\n---\n \n# 数据库的四大特性\n----------------\n\n### 特性\n\n1. 原子性（Atomicity): 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。\n\n2. 一致性（Consistency):\n   一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。\n\n3. 隔离性（Isolation):\n   隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。\n\n4. 持久性（Durability): 持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。\n\n### 几种问题\n\n1. 脏读: 是指在一个事务处理过程里读取了另一个未提交的事务中的数据。当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。\n2. 不可重复读:\n   不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题，例如对于同一个数据A和B依次查询就可能不同，A和B就可能打起来了……\n3. 虚读(幻读):\n   幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。\n\n# 五个事务隔级别\n----------------\n\n### 事务隔级别\n\n1. default 默认的事务隔离级别(Repeatable read)\n2. Read uncommitted (读未提交)：最低级别，任何情况都无法保证。\n3. Repeatable read (可重复读)：可避免脏读、不可重复读的发生。\n4. Read committed (读已提交)：可避免脏读的发生。\n6. Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。\n\n> * 隔离级别最高的是Serializable级别，最低的是Read uncommitted级别，当然级别越高，执行效率就越低。\n\n\n# 七个事务的传播行为\n----------------\n\n### 事务的传播行为\n\n1. propagation_required 如果一个事务存在，则支持当前事务，如果不存在，则创建新的事务。\n2. propagation_supports 如果一个事务存在，则支持当前事务，如果不存在，则非事务的方法运行。\n3. propagation_mendatory 如果一个事务存在，则支持当前事务，如果存在，则抛出异常。\n4. propagation_requires_new 总是要开启一个新的事务，如果事务存在，将该事务挂起。\n5. propagation_not_supported 总是非事务方法运行，并挂起所有的事务。\n6. propagation_never 总是非事务方法运行，如果事务存在则抛出异常\n7. propagation_nested 某一个事务存在，则运行在一个嵌套的事务中。\n\n> **配置方式** :\n\n\t<tx:method name=\"save*\" propagation=\"REQUIRED\" isolation=\"DEFAULT\" />\n\n\t@Transactional(propagation=Propagation.REQUIRED,isolation=Isolation.DEFAULT)\n","slug":"Spring中事务的一些特性","published":1,"updated":"2024-11-27T03:20:35.213Z","_id":"cm3zaz9c00001tgu6ada21hmp","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"数据库的四大特性\"><a href=\"#数据库的四大特性\" class=\"headerlink\" title=\"数据库的四大特性\"></a>数据库的四大特性</h1><hr>\n<h3 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h3><ol>\n<li><p>原子性（Atomicity): 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p>\n</li>\n<li><p>一致性（Consistency):<br>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p>\n</li>\n<li><p>隔离性（Isolation):<br>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。</p>\n</li>\n<li><p>持久性（Durability): 持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>\n</li>\n</ol>\n<h3 id=\"几种问题\"><a href=\"#几种问题\" class=\"headerlink\" title=\"几种问题\"></a>几种问题</h3><ol>\n<li>脏读: 是指在一个事务处理过程里读取了另一个未提交的事务中的数据。当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。</li>\n<li>不可重复读:<br>不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题，例如对于同一个数据A和B依次查询就可能不同，A和B就可能打起来了……</li>\n<li>虚读(幻读):<br>幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。</li>\n</ol>\n<h1 id=\"五个事务隔级别\"><a href=\"#五个事务隔级别\" class=\"headerlink\" title=\"五个事务隔级别\"></a>五个事务隔级别</h1><hr>\n<h3 id=\"事务隔级别\"><a href=\"#事务隔级别\" class=\"headerlink\" title=\"事务隔级别\"></a>事务隔级别</h3><ol>\n<li>default 默认的事务隔离级别(Repeatable read)</li>\n<li>Read uncommitted (读未提交)：最低级别，任何情况都无法保证。</li>\n<li>Repeatable read (可重复读)：可避免脏读、不可重复读的发生。</li>\n<li>Read committed (读已提交)：可避免脏读的发生。</li>\n<li>Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。</li>\n</ol>\n<blockquote>\n<ul>\n<li>隔离级别最高的是Serializable级别，最低的是Read uncommitted级别，当然级别越高，执行效率就越低。</li>\n</ul>\n</blockquote>\n<h1 id=\"七个事务的传播行为\"><a href=\"#七个事务的传播行为\" class=\"headerlink\" title=\"七个事务的传播行为\"></a>七个事务的传播行为</h1><hr>\n<h3 id=\"事务的传播行为\"><a href=\"#事务的传播行为\" class=\"headerlink\" title=\"事务的传播行为\"></a>事务的传播行为</h3><ol>\n<li>propagation_required 如果一个事务存在，则支持当前事务，如果不存在，则创建新的事务。</li>\n<li>propagation_supports 如果一个事务存在，则支持当前事务，如果不存在，则非事务的方法运行。</li>\n<li>propagation_mendatory 如果一个事务存在，则支持当前事务，如果存在，则抛出异常。</li>\n<li>propagation_requires_new 总是要开启一个新的事务，如果事务存在，将该事务挂起。</li>\n<li>propagation_not_supported 总是非事务方法运行，并挂起所有的事务。</li>\n<li>propagation_never 总是非事务方法运行，如果事务存在则抛出异常</li>\n<li>propagation_nested 某一个事务存在，则运行在一个嵌套的事务中。</li>\n</ol>\n<blockquote>\n<p><strong>配置方式</strong> :</p>\n</blockquote>\n<pre><code>&lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot; isolation=&quot;DEFAULT&quot; /&gt;\n\n@Transactional(propagation=Propagation.REQUIRED,isolation=Isolation.DEFAULT)\n</code></pre>\n","excerpt":"","more":"<h1 id=\"数据库的四大特性\"><a href=\"#数据库的四大特性\" class=\"headerlink\" title=\"数据库的四大特性\"></a>数据库的四大特性</h1><hr>\n<h3 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h3><ol>\n<li><p>原子性（Atomicity): 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p>\n</li>\n<li><p>一致性（Consistency):<br>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p>\n</li>\n<li><p>隔离性（Isolation):<br>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。</p>\n</li>\n<li><p>持久性（Durability): 持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>\n</li>\n</ol>\n<h3 id=\"几种问题\"><a href=\"#几种问题\" class=\"headerlink\" title=\"几种问题\"></a>几种问题</h3><ol>\n<li>脏读: 是指在一个事务处理过程里读取了另一个未提交的事务中的数据。当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。</li>\n<li>不可重复读:<br>不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题，例如对于同一个数据A和B依次查询就可能不同，A和B就可能打起来了……</li>\n<li>虚读(幻读):<br>幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。</li>\n</ol>\n<h1 id=\"五个事务隔级别\"><a href=\"#五个事务隔级别\" class=\"headerlink\" title=\"五个事务隔级别\"></a>五个事务隔级别</h1><hr>\n<h3 id=\"事务隔级别\"><a href=\"#事务隔级别\" class=\"headerlink\" title=\"事务隔级别\"></a>事务隔级别</h3><ol>\n<li>default 默认的事务隔离级别(Repeatable read)</li>\n<li>Read uncommitted (读未提交)：最低级别，任何情况都无法保证。</li>\n<li>Repeatable read (可重复读)：可避免脏读、不可重复读的发生。</li>\n<li>Read committed (读已提交)：可避免脏读的发生。</li>\n<li>Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。</li>\n</ol>\n<blockquote>\n<ul>\n<li>隔离级别最高的是Serializable级别，最低的是Read uncommitted级别，当然级别越高，执行效率就越低。</li>\n</ul>\n</blockquote>\n<h1 id=\"七个事务的传播行为\"><a href=\"#七个事务的传播行为\" class=\"headerlink\" title=\"七个事务的传播行为\"></a>七个事务的传播行为</h1><hr>\n<h3 id=\"事务的传播行为\"><a href=\"#事务的传播行为\" class=\"headerlink\" title=\"事务的传播行为\"></a>事务的传播行为</h3><ol>\n<li>propagation_required 如果一个事务存在，则支持当前事务，如果不存在，则创建新的事务。</li>\n<li>propagation_supports 如果一个事务存在，则支持当前事务，如果不存在，则非事务的方法运行。</li>\n<li>propagation_mendatory 如果一个事务存在，则支持当前事务，如果存在，则抛出异常。</li>\n<li>propagation_requires_new 总是要开启一个新的事务，如果事务存在，将该事务挂起。</li>\n<li>propagation_not_supported 总是非事务方法运行，并挂起所有的事务。</li>\n<li>propagation_never 总是非事务方法运行，如果事务存在则抛出异常</li>\n<li>propagation_nested 某一个事务存在，则运行在一个嵌套的事务中。</li>\n</ol>\n<blockquote>\n<p><strong>配置方式</strong> :</p>\n</blockquote>\n<pre><code>&lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot; isolation=&quot;DEFAULT&quot; /&gt;\n\n@Transactional(propagation=Propagation.REQUIRED,isolation=Isolation.DEFAULT)\n</code></pre>\n"},{"title":"spring mvc的interceptor","date":"2017-09-13T01:00:00.000Z","_content":" \n## SpringMVC的Interceptor\n\n**`1.实现方式`**\n\n1. HandlerInterceptor\n2. WebRequestInterceptor\n\n**`2.具体说明`**\n\n1. preHandle (HttpServletRequest request, HttpServletResponse response, Object handle) 方法，顾名思义，该方法将在请求处理之前进行调用。SpringMVC\n   中的Interceptor 是链式的调用的，在一个应用中或者说是在一个请求中可以同时存在多个Interceptor 。每个Interceptor\n   的调用会依据它的声明顺序依次执行，而且最先执行的都是Interceptor 中的preHandle\n   方法，所以可以在这个方法中进行一些前置初始化操作或者是对当前请求的一个预处理，也可以在这个方法中进行一些判断来决定请求是否要继续进行下去。该方法的返回值是布尔值Boolean\n   类型的，当它返回为false 时，表示请求结束，后续的Interceptor 和Controller 都不会再执行；当返回值为true\n   时就会继续调用下一个Interceptor 的preHandle 方法，如果已经是最后一个Interceptor 的时候就会是调用当前请求的Controller\n   方法。\n2. postHandle (HttpServletRequest request, HttpServletResponse response, Object handle, ModelAndView modelAndView)\n   方法，由preHandle 方法的解释我们知道这个方法包括后面要说到的afterCompletion 方法都只能是在当前所属的Interceptor\n   的preHandle 方法的返回值为true 时才能被调用。postHandle 方法，顾名思义就是在当前请求进行处理之后，也就是Controller\n   方法调用之后执行，但是它会在DispatcherServlet 进行视图返回渲染之前被调用，所以我们可以在这个方法中对Controller\n   处理之后的ModelAndView 对象进行操作。postHandle 方法被调用的方向跟preHandle 是相反的，也就是说先声明的Interceptor\n   的postHandle 方法反而会后执行，这和Struts2 里面的Interceptor 的执行过程有点类型。Struts2 里面的Interceptor\n   的执行过程也是链式的，只是在Struts2 里面需要手动调用ActionInvocation 的invoke 方法来触发对下一个Interceptor 或者是Action\n   的调用，然后每一个Interceptor 中在invoke 方法调用之前的内容都是按照声明顺序执行的，而invoke 方法之后的内容就是反向的。\n3. afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handle, Exception ex)\n   方法，该方法也是需要当前对应的Interceptor 的preHandle 方法的返回值为true\n   时才会执行。顾名思义，该方法将在整个请求结束之后，也就是在DispatcherServlet 渲染了对应的视图之后执行。这个方法的主要作用是用于进行资源清理工作的。\n\n**`3.实现代码`**\n\n\t<mvc:interceptors>\n\t\t<!-- <bean class=\"com.base.common.permission.AllInterceptor\"/> -->\t<!-- 拦截所有url -->\n\t\t<mvc:interceptor>\n\t\t\t<mvc:mapping path=\"/**/*.htm\" />\t<!-- 只拦截htm后缀的路径  -->\n\t\t\t<bean class=\"com.base.common.permission.PermissionInterceptor\" />\n\t\t</mvc:interceptor>\n\t\t<mvc:interceptor>\n\t\t\t<mvc:mapping path=\"/**\" />\n\t\t\t<mvc:exclude-mapping path=\"/admin/login.htm\"/> \t<!-- 不拦截的url -->\n\t\t\t<bean class=\"com.base.common.permission.PermissionInterceptor\" />\n\t\t</mvc:interceptor>\n\t</mvc:interceptors>","source":"_posts/SpringMVC的Interceptor.md","raw":"---\ntitle: \"spring mvc的interceptor\"\ndate: 2017-09-13 09:00:00\ncategories: Spring\ntags:\n  - mvc\n---\n \n## SpringMVC的Interceptor\n\n**`1.实现方式`**\n\n1. HandlerInterceptor\n2. WebRequestInterceptor\n\n**`2.具体说明`**\n\n1. preHandle (HttpServletRequest request, HttpServletResponse response, Object handle) 方法，顾名思义，该方法将在请求处理之前进行调用。SpringMVC\n   中的Interceptor 是链式的调用的，在一个应用中或者说是在一个请求中可以同时存在多个Interceptor 。每个Interceptor\n   的调用会依据它的声明顺序依次执行，而且最先执行的都是Interceptor 中的preHandle\n   方法，所以可以在这个方法中进行一些前置初始化操作或者是对当前请求的一个预处理，也可以在这个方法中进行一些判断来决定请求是否要继续进行下去。该方法的返回值是布尔值Boolean\n   类型的，当它返回为false 时，表示请求结束，后续的Interceptor 和Controller 都不会再执行；当返回值为true\n   时就会继续调用下一个Interceptor 的preHandle 方法，如果已经是最后一个Interceptor 的时候就会是调用当前请求的Controller\n   方法。\n2. postHandle (HttpServletRequest request, HttpServletResponse response, Object handle, ModelAndView modelAndView)\n   方法，由preHandle 方法的解释我们知道这个方法包括后面要说到的afterCompletion 方法都只能是在当前所属的Interceptor\n   的preHandle 方法的返回值为true 时才能被调用。postHandle 方法，顾名思义就是在当前请求进行处理之后，也就是Controller\n   方法调用之后执行，但是它会在DispatcherServlet 进行视图返回渲染之前被调用，所以我们可以在这个方法中对Controller\n   处理之后的ModelAndView 对象进行操作。postHandle 方法被调用的方向跟preHandle 是相反的，也就是说先声明的Interceptor\n   的postHandle 方法反而会后执行，这和Struts2 里面的Interceptor 的执行过程有点类型。Struts2 里面的Interceptor\n   的执行过程也是链式的，只是在Struts2 里面需要手动调用ActionInvocation 的invoke 方法来触发对下一个Interceptor 或者是Action\n   的调用，然后每一个Interceptor 中在invoke 方法调用之前的内容都是按照声明顺序执行的，而invoke 方法之后的内容就是反向的。\n3. afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handle, Exception ex)\n   方法，该方法也是需要当前对应的Interceptor 的preHandle 方法的返回值为true\n   时才会执行。顾名思义，该方法将在整个请求结束之后，也就是在DispatcherServlet 渲染了对应的视图之后执行。这个方法的主要作用是用于进行资源清理工作的。\n\n**`3.实现代码`**\n\n\t<mvc:interceptors>\n\t\t<!-- <bean class=\"com.base.common.permission.AllInterceptor\"/> -->\t<!-- 拦截所有url -->\n\t\t<mvc:interceptor>\n\t\t\t<mvc:mapping path=\"/**/*.htm\" />\t<!-- 只拦截htm后缀的路径  -->\n\t\t\t<bean class=\"com.base.common.permission.PermissionInterceptor\" />\n\t\t</mvc:interceptor>\n\t\t<mvc:interceptor>\n\t\t\t<mvc:mapping path=\"/**\" />\n\t\t\t<mvc:exclude-mapping path=\"/admin/login.htm\"/> \t<!-- 不拦截的url -->\n\t\t\t<bean class=\"com.base.common.permission.PermissionInterceptor\" />\n\t\t</mvc:interceptor>\n\t</mvc:interceptors>","slug":"SpringMVC的Interceptor","published":1,"updated":"2024-11-27T03:20:35.231Z","_id":"cm3zaz9c10003tgu64howgfaj","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"SpringMVC的Interceptor\"><a href=\"#SpringMVC的Interceptor\" class=\"headerlink\" title=\"SpringMVC的Interceptor\"></a>SpringMVC的Interceptor</h2><p><strong><code>1.实现方式</code></strong></p>\n<ol>\n<li>HandlerInterceptor</li>\n<li>WebRequestInterceptor</li>\n</ol>\n<p><strong><code>2.具体说明</code></strong></p>\n<ol>\n<li>preHandle (HttpServletRequest request, HttpServletResponse response, Object handle) 方法，顾名思义，该方法将在请求处理之前进行调用。SpringMVC<br>中的Interceptor 是链式的调用的，在一个应用中或者说是在一个请求中可以同时存在多个Interceptor 。每个Interceptor<br>的调用会依据它的声明顺序依次执行，而且最先执行的都是Interceptor 中的preHandle<br>方法，所以可以在这个方法中进行一些前置初始化操作或者是对当前请求的一个预处理，也可以在这个方法中进行一些判断来决定请求是否要继续进行下去。该方法的返回值是布尔值Boolean<br>类型的，当它返回为false 时，表示请求结束，后续的Interceptor 和Controller 都不会再执行；当返回值为true<br>时就会继续调用下一个Interceptor 的preHandle 方法，如果已经是最后一个Interceptor 的时候就会是调用当前请求的Controller<br>方法。</li>\n<li>postHandle (HttpServletRequest request, HttpServletResponse response, Object handle, ModelAndView modelAndView)<br>方法，由preHandle 方法的解释我们知道这个方法包括后面要说到的afterCompletion 方法都只能是在当前所属的Interceptor<br>的preHandle 方法的返回值为true 时才能被调用。postHandle 方法，顾名思义就是在当前请求进行处理之后，也就是Controller<br>方法调用之后执行，但是它会在DispatcherServlet 进行视图返回渲染之前被调用，所以我们可以在这个方法中对Controller<br>处理之后的ModelAndView 对象进行操作。postHandle 方法被调用的方向跟preHandle 是相反的，也就是说先声明的Interceptor<br>的postHandle 方法反而会后执行，这和Struts2 里面的Interceptor 的执行过程有点类型。Struts2 里面的Interceptor<br>的执行过程也是链式的，只是在Struts2 里面需要手动调用ActionInvocation 的invoke 方法来触发对下一个Interceptor 或者是Action<br>的调用，然后每一个Interceptor 中在invoke 方法调用之前的内容都是按照声明顺序执行的，而invoke 方法之后的内容就是反向的。</li>\n<li>afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handle, Exception ex)<br>方法，该方法也是需要当前对应的Interceptor 的preHandle 方法的返回值为true<br>时才会执行。顾名思义，该方法将在整个请求结束之后，也就是在DispatcherServlet 渲染了对应的视图之后执行。这个方法的主要作用是用于进行资源清理工作的。</li>\n</ol>\n<p><strong><code>3.实现代码</code></strong></p>\n<pre><code>&lt;mvc:interceptors&gt;\n    &lt;!-- &lt;bean class=&quot;com.base.common.permission.AllInterceptor&quot;/&gt; --&gt;\t&lt;!-- 拦截所有url --&gt;\n    &lt;mvc:interceptor&gt;\n        &lt;mvc:mapping path=&quot;/**/*.htm&quot; /&gt;\t&lt;!-- 只拦截htm后缀的路径  --&gt;\n        &lt;bean class=&quot;com.base.common.permission.PermissionInterceptor&quot; /&gt;\n    &lt;/mvc:interceptor&gt;\n    &lt;mvc:interceptor&gt;\n        &lt;mvc:mapping path=&quot;/**&quot; /&gt;\n        &lt;mvc:exclude-mapping path=&quot;/admin/login.htm&quot;/&gt; \t&lt;!-- 不拦截的url --&gt;\n        &lt;bean class=&quot;com.base.common.permission.PermissionInterceptor&quot; /&gt;\n    &lt;/mvc:interceptor&gt;\n&lt;/mvc:interceptors&gt;\n</code></pre>\n","excerpt":"","more":"<h2 id=\"SpringMVC的Interceptor\"><a href=\"#SpringMVC的Interceptor\" class=\"headerlink\" title=\"SpringMVC的Interceptor\"></a>SpringMVC的Interceptor</h2><p><strong><code>1.实现方式</code></strong></p>\n<ol>\n<li>HandlerInterceptor</li>\n<li>WebRequestInterceptor</li>\n</ol>\n<p><strong><code>2.具体说明</code></strong></p>\n<ol>\n<li>preHandle (HttpServletRequest request, HttpServletResponse response, Object handle) 方法，顾名思义，该方法将在请求处理之前进行调用。SpringMVC<br>中的Interceptor 是链式的调用的，在一个应用中或者说是在一个请求中可以同时存在多个Interceptor 。每个Interceptor<br>的调用会依据它的声明顺序依次执行，而且最先执行的都是Interceptor 中的preHandle<br>方法，所以可以在这个方法中进行一些前置初始化操作或者是对当前请求的一个预处理，也可以在这个方法中进行一些判断来决定请求是否要继续进行下去。该方法的返回值是布尔值Boolean<br>类型的，当它返回为false 时，表示请求结束，后续的Interceptor 和Controller 都不会再执行；当返回值为true<br>时就会继续调用下一个Interceptor 的preHandle 方法，如果已经是最后一个Interceptor 的时候就会是调用当前请求的Controller<br>方法。</li>\n<li>postHandle (HttpServletRequest request, HttpServletResponse response, Object handle, ModelAndView modelAndView)<br>方法，由preHandle 方法的解释我们知道这个方法包括后面要说到的afterCompletion 方法都只能是在当前所属的Interceptor<br>的preHandle 方法的返回值为true 时才能被调用。postHandle 方法，顾名思义就是在当前请求进行处理之后，也就是Controller<br>方法调用之后执行，但是它会在DispatcherServlet 进行视图返回渲染之前被调用，所以我们可以在这个方法中对Controller<br>处理之后的ModelAndView 对象进行操作。postHandle 方法被调用的方向跟preHandle 是相反的，也就是说先声明的Interceptor<br>的postHandle 方法反而会后执行，这和Struts2 里面的Interceptor 的执行过程有点类型。Struts2 里面的Interceptor<br>的执行过程也是链式的，只是在Struts2 里面需要手动调用ActionInvocation 的invoke 方法来触发对下一个Interceptor 或者是Action<br>的调用，然后每一个Interceptor 中在invoke 方法调用之前的内容都是按照声明顺序执行的，而invoke 方法之后的内容就是反向的。</li>\n<li>afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handle, Exception ex)<br>方法，该方法也是需要当前对应的Interceptor 的preHandle 方法的返回值为true<br>时才会执行。顾名思义，该方法将在整个请求结束之后，也就是在DispatcherServlet 渲染了对应的视图之后执行。这个方法的主要作用是用于进行资源清理工作的。</li>\n</ol>\n<p><strong><code>3.实现代码</code></strong></p>\n<pre><code>&lt;mvc:interceptors&gt;\n    &lt;!-- &lt;bean class=&quot;com.base.common.permission.AllInterceptor&quot;/&gt; --&gt;\t&lt;!-- 拦截所有url --&gt;\n    &lt;mvc:interceptor&gt;\n        &lt;mvc:mapping path=&quot;/**/*.htm&quot; /&gt;\t&lt;!-- 只拦截htm后缀的路径  --&gt;\n        &lt;bean class=&quot;com.base.common.permission.PermissionInterceptor&quot; /&gt;\n    &lt;/mvc:interceptor&gt;\n    &lt;mvc:interceptor&gt;\n        &lt;mvc:mapping path=&quot;/**&quot; /&gt;\n        &lt;mvc:exclude-mapping path=&quot;/admin/login.htm&quot;/&gt; \t&lt;!-- 不拦截的url --&gt;\n        &lt;bean class=&quot;com.base.common.permission.PermissionInterceptor&quot; /&gt;\n    &lt;/mvc:interceptor&gt;\n&lt;/mvc:interceptors&gt;\n</code></pre>\n"},{"title":"Spring扩展","date":"2017-05-22T01:00:00.000Z","_content":" \n# Spring扩展\n----------------\n\n### 为什么要扩展\n\n1. 做java开发Spring是必须要用的而且用的很频繁。\n2. Spring的核心IOC和AOP是我们最想要的，但是有些时候需要把我们自定义的bean的生产过程，bean创建好之后再交给Spring容器。所以重点来了怎么交给它\n3. 其实Spring的设计早就考虑到这些问题了，只是平时没怎么使用而已，本文带你解开它神秘的面纱。\n\n# 理论加实践\n----------------\n\n### 1.使用Component注解\n\n1. 想让Spring扫描我们自定义的注解很简单。只需要在我们的注解上加上 @org.springframework.stereotype.Component 代码如下:\n\n```\n    @Component\n    @Retention(RetentionPolicy.RUNTIME)\n    @Target(ElementType.TYPE)\n    public @interface MyService {\n    \tString value() default \"\";// 必须要有\n    }\n```\n\n以上就可以让Spring扫描到我们的注解，作用和Spring的注解作用是一样的。 细心的同学可能已经发现\norg.springframework.stereotype.Controller 的注解不就是这样实现的嘛。\n让我们来看看这是为什么,在\norg.springframework.context.annotation.ClassPathScanningCandidateComponentProvider类中的registerDefaultFilters 方法中有\nthis.includeFilters.add(new AnnotationTypeFilter(Component.class))这样一句话，看到这里明白了吧 。代码如下：\n\n```\n@SuppressWarnings(\"unchecked\")\nprotected void registerDefaultFilters() {\n\tthis.includeFilters.add(new AnnotationTypeFilter(Component.class));\n\tClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader();\n\ttry {\n\t\tthis.includeFilters.add(new AnnotationTypeFilter(\n\t\t\t\t((Class<? extends Annotation>) ClassUtils.forName(\"javax.annotation.ManagedBean\", cl)), false));\n\t\tlogger.debug(\"JSR-250 'javax.annotation.ManagedBean' found and supported for component scanning\");\n\t}\n\tcatch (ClassNotFoundException ex) {\n\t\t// JSR-250 1.1 API (as included in Java EE 6) not available - simply skip.\n\t}\n\ttry {\n\t\tthis.includeFilters.add(new AnnotationTypeFilter(\n\t\t\t\t((Class<? extends Annotation>) ClassUtils.forName(\"javax.inject.Named\", cl)), false));\n\t\tlogger.debug(\"JSR-330 'javax.inject.Named' annotation found and supported for component scanning\");\n\t}\n\tcatch (ClassNotFoundException ex) {\n\t\t// JSR-330 API not available - simply skip.\n\t}\n}\n```\n\n你以为这样就完了嘛？如果仅仅是装个x确实完了，被他注解的类会被Spring管理。 但是对于我们来讲是不够滴，应为我们还要定义这个bean的生产过程呀！这才是真正的目的。代码如下：\n\n```\n@Component\npublic class MyBeanPostProcessor implements BeanPostProcessor {\n\tpublic Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n\t\tSystem.out.println(\"postProcessAfterInitialization  \"+ beanName);\n\t\treturn bean;\n\t}\n\n\tpublic Object postProcessBeforeInitialization(``````Object bean, String beanName) throws BeansException {\n\t\tSystem.out.println(\"postProcessBeforeInitialization \"+ beanName);\n\t\treturn bean;\n\t}\n}\n```\n\nBeanPostProcessor接口作用是：如果我们需要在Spring容器完成Bean的实例化、配置和其他的初始化前后添加一些自己的逻辑处理，我们就可以定义一个或者多个BeanPostProcessor接口的实现，然后注册到容器中。两个方法一个之前\n一个之后。注册到容器时两个方法都会调，获取的时会调postProcessBeforeInitialization方法。我们可以在这里把bean在定制一番,怎么定制就看个人需求啦不再讲述。听SpringMvc就是采用的这种策略，没去验证过。第一种方法就介绍完了。\n\n### 2.扫描包解析注解\n\n1. 先定义注解代码如下：\n\n``` \nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface Component {\n\tString value() default \"\";\n}\n\t\n```\n\n2. 扫描 既然用到了Spring那么就让Spring来帮我们扫描代码如下：\n\n```\nimport java.util.Set;\nimport org.springframework.beans.factory.annotation.AnnotatedBeanDefinition;\nimport org.springframework.beans.factory.config.BeanDefinitionHolder;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistry;\nimport org.springframework.beans.factory.support.GenericBeanDefinition;\nimport org.springframework.context.annotation.ClassPathBeanDefinitionScanner;\nimport org.springframework.core.type.filter.AnnotationTypeFilter;\n\npublic final class Scanner extends ClassPathBeanDefinitionScanner {\n\n\tpublic Scanner(BeanDefinitionRegistry registry) {\n\t\tsuper(registry);\n\t}\n\n\tpublic void registerDefaultFilters() {\n\t\tthis.addIncludeFilter(new AnnotationTypeFilter(Component.class));\n\t}\n\n\tpublic Set<BeanDefinitionHolder> doScan(String... basePackages) {\n\t\t//super.doScan(basePackages) 会把生成的bean 加入Spring容器\n\t\tSet<BeanDefinitionHolder> beanDefinitions = super.doScan(basePackages);\n\t\tfor (BeanDefinitionHolder holder : beanDefinitions) {\n\t\t\tGenericBeanDefinition definition = (GenericBeanDefinition) holder.getBeanDefinition();\n\t\t\t// beanClassName给FactoryBeanImpl使用，还以再加几个Property\n\t\t\tdefinition.getPropertyValues().add(\"beanClassName\", definition.getBeanClassName()); \n\t\t\tdefinition.setBeanClass(FactoryBeanImpl.class);\n\t\t}\n\t\treturn beanDefinitions;\n\t}\n\n\tpublic boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) {\n\t\treturn super.isCandidateComponent(beanDefinition) \n\t\t\t\t\t&& (beanDefinition.getMetadata().hasAnnotation(Component.class.getName()));\n\t}\n}\n```\n\n上面的代码就是扫描，解析后得到的BeanDefinitionHolder 然后指定工厂FactoryBeanImpl生产后加入容器 代码如下：\n\n```\nimport org.springframework.beans.factory.FactoryBean;\nimport org.springframework.beans.factory.InitializingBean;\nimport org.springframework.cglib.core.SpringNamingPolicy;\nimport org.springframework.cglib.proxy.Enhancer;\n\npublic class FactoryBeanImpl<T> implements InitializingBean, FactoryBean<T> {\n\tprivate String beanClassName;\n \n\tpublic void setBeanClassName(String beanClassName) {\n\t\tthis.beanClassName = beanClassName;\n\t}\n\n\tpublic T getObject() throws Exception {\n\t\tClass innerClass = Class.forName(beanClassName);\n\t\tif (innerClass.isInterface()) {//接口使用 jdk代理\n\t\t\treturn (T) InvocationHandlerImpl.newInstance(innerClass);\n\t\t} else {//类使用 cglib代理\n\t\t\tEnhancer enhancer = new Enhancer();\n\t\t\tenhancer.setSuperclass(innerClass);\n\t\t\tenhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);\n\t\t\tenhancer.setCallback(new MethodInterceptorImpl());\n\t\t\treturn (T) enhancer.create();\n\t\t}\n\t}\n\n\tpublic Class<?> getObjectType() {\n\t\ttry {\n\t\t\treturn Class.forName(beanClassName);\n\t\t} catch (ClassNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic boolean isSingleton() {\n\t\treturn true;\n\t}\n\n\tpublic void afterPropertiesSet() throws Exception {\n\t}\n}\n```\n\n这个属性beanClassName是上面扫描绑定过来的。这里就是生成bean的工厂。getObject是bean的生成方法，代理就略过。代码如下：\n\n```\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\npublic class InvocationHandlerImpl implements InvocationHandler {\n  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n      System.out.println(\"ObjectProxy execute:\" + method.getName());\n      return method.invoke(proxy, args);\n  }\n  public static <T> T newInstance(Class<T> innerInterface) {\n      ClassLoader classLoader = innerInterface.getClassLoader();\n      Class[] interfaces = new Class[] { innerInterface };\n      InvocationHandlerImpl proxy = new InvocationHandlerImpl();\n      return (T) Proxy.newProxyInstance(classLoader, interfaces, proxy);\n  }\n}\n \n\nimport java.lang.reflect.Method;\nimport org.springframework.cglib.proxy.MethodInterceptor;\nimport org.springframework.cglib.proxy.MethodProxy;\n\npublic class MethodInterceptorImpl implements MethodInterceptor {\n\tpublic Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n\t\tSystem.out.println(\"MethodInterceptorImpl:\" + method.getName());\n\t\treturn methodProxy.invokeSuper(o, objects);\n\t}\n}\n```\n\n3.什么都做了，什么时候扫描\n\n```\npublic Scanner(BeanDefinitionRegistry registry) {\n    super(registry);\n}\n```\n\n在实例化Scanner时需要 BeanDefinitionRegistry该类的作用主要是向注册表中注册 BeanDefinition实例 完成注册的过程。\nBeanFactoryPostProcessor是在spring容器加载了bean的定义文件之后，在bean实例化之前执行的。\nConfigurableListableBeanFactory该类提供解析,修改bean定义,并与初始化单例.\n在运行的时候传入的是 DefaultListableBeanFactory为 ConfigurableListableBeanFactory子类且实现了 BeanDefinitionRegistry\n接口。代码如下：\n\n```\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.config.BeanFactoryPostProcessor;\nimport org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistry;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.ApplicationContextAware;\nimport org.springframework.stereotype.Component;\n\npublic class BeanFactoryPostProcesserImpl implements BeanFactoryPostProcessor, ApplicationContextAware {\n\tprivate ApplicationContext applicationContext;\n\n\tpublic void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n\t\tthis.applicationContext = applicationContext;\n\t}\n\n\tpublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n\t\tScanner scanner = new Scanner((BeanDefinitionRegistry) beanFactory);//可以强转\n\t\tscanner.setResourceLoader(this.applicationContext);\n\t\tscanner.setBeanNameGenerator(new AnnotationBeanNameGenerator());//解析注解得到value值。\n\t\tscanner.scan(\"com.extend.service\");//可以在xml配置进来 不再演示\n\t}\n}\n\nimport java.beans.Introspector;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.springframework.beans.factory.annotation.AnnotatedBeanDefinition;\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistry;\nimport org.springframework.beans.factory.support.BeanNameGenerator;\nimport org.springframework.core.annotation.AnnotationAttributes;\nimport org.springframework.core.type.AnnotationMetadata;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.StringUtils;\n\npublic class AnnotationBeanNameGenerator implements BeanNameGenerator {\n\n\tprivate static final String COMPONENT_ANNOTATION_CLASSNAME = \"com.extend.annotation2.Component\";\n\n\t@Override\n\tpublic String generateBeanName(BeanDefinition definition, BeanDefinitionRegistry registry) {\n\t\tif (definition instanceof AnnotatedBeanDefinition) {\n\t\t\tString beanName = determineBeanNameFromAnnotation((AnnotatedBeanDefinition) definition);\n\t\t\tif (StringUtils.hasText(beanName)) {\n\t\t\t\treturn beanName;\n\t\t\t}\n\t\t}\n\t\treturn buildDefaultBeanName(definition, registry);\n\t}\n\n\tprotected String determineBeanNameFromAnnotation(AnnotatedBeanDefinition annotatedDef) {\n\t\tAnnotationMetadata amd = annotatedDef.getMetadata();\n\t\tSet<String> types = amd.getAnnotationTypes();\n\t\tString beanName = null;\n\t\tfor (String type : types) {\n\t\t\tAnnotationAttributes attributes = AnnotationAttributes.fromMap(amd.getAnnotationAttributes(type, false));\n\t\t\t// AnnotationAttributes attributes =\n\t\t\t// AnnotationConfigUtils.attributesFor(amd, type);\n\t\t\tif (isStereotypeWithNameValue(type, amd.getMetaAnnotationTypes(type), attributes)) {\n\t\t\t\tObject value = attributes.get(\"value\");\n\t\t\t\tif (value instanceof String) {\n\t\t\t\t\tString strVal = (String) value;\n\t\t\t\t\tif (StringUtils.hasLength(strVal)) {\n\t\t\t\t\t  if (beanName != null && !strVal.equals(beanName)) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"Stereotype annotations suggest inconsistent \"\n\t\t\t\t\t\t\t\t+ \"component names: '\" + beanName + \"' versus '\" + strVal + \"'\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbeanName = strVal;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn beanName;\n\t}\n\n\tprotected boolean isStereotypeWithNameValue(String annotationType, Set<String> metaAnnotationTypes,\n\t\t\tMap<String, Object> attributes) {\n\n\t\tboolean isStereotype = annotationType.equals(COMPONENT_ANNOTATION_CLASSNAME)\n\t\t\t|| (metaAnnotationTypes != null && metaAnnotationTypes.contains(COMPONENT_ANNOTATION_CLASSNAME))\n\t\t\t|| annotationType.equals(\"javax.annotation.ManagedBean\") || annotationType.equals(\"javax.inject.Named\");\n\n\t\treturn (isStereotype && attributes != null && attributes.containsKey(\"value\"));\n\t}\n\n\tprotected String buildDefaultBeanName(BeanDefinition definition, BeanDefinitionRegistry registry) {\n\t\treturn buildDefaultBeanName(definition);\n\t}\n\n\tprotected String buildDefaultBeanName(BeanDefinition definition) {\n\t\tString shortClassName = ClassUtils.getShortName(definition.getBeanClassName());\n\t\treturn Introspector.decapitalize(shortClassName);\n\t}\n\n}\n```\n\n以上就是实现过程 下面是测试：\n\n```\nimport com.extend.annotation2.Component;\n@Component(\"disCaver1\")\npublic class TestService {\n\tpublic String getName() {\n\t\tSystem.err.println(\"hello world!\");\n\t\treturn \"hello world!\";\n\t}\n}\n\npublic class Test {\n\tpublic static void main(String[] args) throws Exception {\n\t\tClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:spring-mybatis.xml\");\n\t\tcontext.start();\n\t\tTestService disCaver1 = (TestService) context.getBean(\"disCaver1\");\n\t\tTestService disCaver2 = (TestService) context.getBean(TestService.class);\n\t\tdisCaver1.getName();\n\t\tcontext.close();\n\t}\n}\n\t\n```\n\nspring-mybatis.xml：\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t\txmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\"\n\t\txmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\" \n\t\txmlns:cache=\"http://www.springframework.org/schema/cache\"\n\t\txsi:schemaLocation=\"http://www.springframework.org/schema/beans    \n\t           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd    \n\t           http://www.springframework.org/schema/context    \n\t           http://www.springframework.org/schema/context/spring-context-3.0.xsd    \n\t           http://www.springframework.org/schema/aop    \n\t           http://www.springframework.org/schema/aop/spring-aop-3.0.xsd    \n\t           http://www.springframework.org/schema/tx \n\t           http://www.springframework.org/schema/tx/spring-tx-3.0.xsd\n\t           http://code.alibabatech.com/schema/dubbo \n\t\t\t   http://code.alibabatech.com/schema/dubbo/dubbo.xsd\">\n\t\t\t   <bean class=\"com.extend.annotation2.BeanFactoryPostProcesserImpl\"/>\n\t</beans>\n```\n\n结果：\nMethodInterceptorImpl:getName\nhello world!\n \n","source":"_posts/Spring扩展.md","raw":"---\ntitle: \"Spring扩展\"\ndate: 2017-05-22 09:00:00\ncategories: Spring\ntags:\n  - 扩展\n---\n \n# Spring扩展\n----------------\n\n### 为什么要扩展\n\n1. 做java开发Spring是必须要用的而且用的很频繁。\n2. Spring的核心IOC和AOP是我们最想要的，但是有些时候需要把我们自定义的bean的生产过程，bean创建好之后再交给Spring容器。所以重点来了怎么交给它\n3. 其实Spring的设计早就考虑到这些问题了，只是平时没怎么使用而已，本文带你解开它神秘的面纱。\n\n# 理论加实践\n----------------\n\n### 1.使用Component注解\n\n1. 想让Spring扫描我们自定义的注解很简单。只需要在我们的注解上加上 @org.springframework.stereotype.Component 代码如下:\n\n```\n    @Component\n    @Retention(RetentionPolicy.RUNTIME)\n    @Target(ElementType.TYPE)\n    public @interface MyService {\n    \tString value() default \"\";// 必须要有\n    }\n```\n\n以上就可以让Spring扫描到我们的注解，作用和Spring的注解作用是一样的。 细心的同学可能已经发现\norg.springframework.stereotype.Controller 的注解不就是这样实现的嘛。\n让我们来看看这是为什么,在\norg.springframework.context.annotation.ClassPathScanningCandidateComponentProvider类中的registerDefaultFilters 方法中有\nthis.includeFilters.add(new AnnotationTypeFilter(Component.class))这样一句话，看到这里明白了吧 。代码如下：\n\n```\n@SuppressWarnings(\"unchecked\")\nprotected void registerDefaultFilters() {\n\tthis.includeFilters.add(new AnnotationTypeFilter(Component.class));\n\tClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader();\n\ttry {\n\t\tthis.includeFilters.add(new AnnotationTypeFilter(\n\t\t\t\t((Class<? extends Annotation>) ClassUtils.forName(\"javax.annotation.ManagedBean\", cl)), false));\n\t\tlogger.debug(\"JSR-250 'javax.annotation.ManagedBean' found and supported for component scanning\");\n\t}\n\tcatch (ClassNotFoundException ex) {\n\t\t// JSR-250 1.1 API (as included in Java EE 6) not available - simply skip.\n\t}\n\ttry {\n\t\tthis.includeFilters.add(new AnnotationTypeFilter(\n\t\t\t\t((Class<? extends Annotation>) ClassUtils.forName(\"javax.inject.Named\", cl)), false));\n\t\tlogger.debug(\"JSR-330 'javax.inject.Named' annotation found and supported for component scanning\");\n\t}\n\tcatch (ClassNotFoundException ex) {\n\t\t// JSR-330 API not available - simply skip.\n\t}\n}\n```\n\n你以为这样就完了嘛？如果仅仅是装个x确实完了，被他注解的类会被Spring管理。 但是对于我们来讲是不够滴，应为我们还要定义这个bean的生产过程呀！这才是真正的目的。代码如下：\n\n```\n@Component\npublic class MyBeanPostProcessor implements BeanPostProcessor {\n\tpublic Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n\t\tSystem.out.println(\"postProcessAfterInitialization  \"+ beanName);\n\t\treturn bean;\n\t}\n\n\tpublic Object postProcessBeforeInitialization(``````Object bean, String beanName) throws BeansException {\n\t\tSystem.out.println(\"postProcessBeforeInitialization \"+ beanName);\n\t\treturn bean;\n\t}\n}\n```\n\nBeanPostProcessor接口作用是：如果我们需要在Spring容器完成Bean的实例化、配置和其他的初始化前后添加一些自己的逻辑处理，我们就可以定义一个或者多个BeanPostProcessor接口的实现，然后注册到容器中。两个方法一个之前\n一个之后。注册到容器时两个方法都会调，获取的时会调postProcessBeforeInitialization方法。我们可以在这里把bean在定制一番,怎么定制就看个人需求啦不再讲述。听SpringMvc就是采用的这种策略，没去验证过。第一种方法就介绍完了。\n\n### 2.扫描包解析注解\n\n1. 先定义注解代码如下：\n\n``` \nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface Component {\n\tString value() default \"\";\n}\n\t\n```\n\n2. 扫描 既然用到了Spring那么就让Spring来帮我们扫描代码如下：\n\n```\nimport java.util.Set;\nimport org.springframework.beans.factory.annotation.AnnotatedBeanDefinition;\nimport org.springframework.beans.factory.config.BeanDefinitionHolder;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistry;\nimport org.springframework.beans.factory.support.GenericBeanDefinition;\nimport org.springframework.context.annotation.ClassPathBeanDefinitionScanner;\nimport org.springframework.core.type.filter.AnnotationTypeFilter;\n\npublic final class Scanner extends ClassPathBeanDefinitionScanner {\n\n\tpublic Scanner(BeanDefinitionRegistry registry) {\n\t\tsuper(registry);\n\t}\n\n\tpublic void registerDefaultFilters() {\n\t\tthis.addIncludeFilter(new AnnotationTypeFilter(Component.class));\n\t}\n\n\tpublic Set<BeanDefinitionHolder> doScan(String... basePackages) {\n\t\t//super.doScan(basePackages) 会把生成的bean 加入Spring容器\n\t\tSet<BeanDefinitionHolder> beanDefinitions = super.doScan(basePackages);\n\t\tfor (BeanDefinitionHolder holder : beanDefinitions) {\n\t\t\tGenericBeanDefinition definition = (GenericBeanDefinition) holder.getBeanDefinition();\n\t\t\t// beanClassName给FactoryBeanImpl使用，还以再加几个Property\n\t\t\tdefinition.getPropertyValues().add(\"beanClassName\", definition.getBeanClassName()); \n\t\t\tdefinition.setBeanClass(FactoryBeanImpl.class);\n\t\t}\n\t\treturn beanDefinitions;\n\t}\n\n\tpublic boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) {\n\t\treturn super.isCandidateComponent(beanDefinition) \n\t\t\t\t\t&& (beanDefinition.getMetadata().hasAnnotation(Component.class.getName()));\n\t}\n}\n```\n\n上面的代码就是扫描，解析后得到的BeanDefinitionHolder 然后指定工厂FactoryBeanImpl生产后加入容器 代码如下：\n\n```\nimport org.springframework.beans.factory.FactoryBean;\nimport org.springframework.beans.factory.InitializingBean;\nimport org.springframework.cglib.core.SpringNamingPolicy;\nimport org.springframework.cglib.proxy.Enhancer;\n\npublic class FactoryBeanImpl<T> implements InitializingBean, FactoryBean<T> {\n\tprivate String beanClassName;\n \n\tpublic void setBeanClassName(String beanClassName) {\n\t\tthis.beanClassName = beanClassName;\n\t}\n\n\tpublic T getObject() throws Exception {\n\t\tClass innerClass = Class.forName(beanClassName);\n\t\tif (innerClass.isInterface()) {//接口使用 jdk代理\n\t\t\treturn (T) InvocationHandlerImpl.newInstance(innerClass);\n\t\t} else {//类使用 cglib代理\n\t\t\tEnhancer enhancer = new Enhancer();\n\t\t\tenhancer.setSuperclass(innerClass);\n\t\t\tenhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);\n\t\t\tenhancer.setCallback(new MethodInterceptorImpl());\n\t\t\treturn (T) enhancer.create();\n\t\t}\n\t}\n\n\tpublic Class<?> getObjectType() {\n\t\ttry {\n\t\t\treturn Class.forName(beanClassName);\n\t\t} catch (ClassNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic boolean isSingleton() {\n\t\treturn true;\n\t}\n\n\tpublic void afterPropertiesSet() throws Exception {\n\t}\n}\n```\n\n这个属性beanClassName是上面扫描绑定过来的。这里就是生成bean的工厂。getObject是bean的生成方法，代理就略过。代码如下：\n\n```\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\npublic class InvocationHandlerImpl implements InvocationHandler {\n  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n      System.out.println(\"ObjectProxy execute:\" + method.getName());\n      return method.invoke(proxy, args);\n  }\n  public static <T> T newInstance(Class<T> innerInterface) {\n      ClassLoader classLoader = innerInterface.getClassLoader();\n      Class[] interfaces = new Class[] { innerInterface };\n      InvocationHandlerImpl proxy = new InvocationHandlerImpl();\n      return (T) Proxy.newProxyInstance(classLoader, interfaces, proxy);\n  }\n}\n \n\nimport java.lang.reflect.Method;\nimport org.springframework.cglib.proxy.MethodInterceptor;\nimport org.springframework.cglib.proxy.MethodProxy;\n\npublic class MethodInterceptorImpl implements MethodInterceptor {\n\tpublic Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n\t\tSystem.out.println(\"MethodInterceptorImpl:\" + method.getName());\n\t\treturn methodProxy.invokeSuper(o, objects);\n\t}\n}\n```\n\n3.什么都做了，什么时候扫描\n\n```\npublic Scanner(BeanDefinitionRegistry registry) {\n    super(registry);\n}\n```\n\n在实例化Scanner时需要 BeanDefinitionRegistry该类的作用主要是向注册表中注册 BeanDefinition实例 完成注册的过程。\nBeanFactoryPostProcessor是在spring容器加载了bean的定义文件之后，在bean实例化之前执行的。\nConfigurableListableBeanFactory该类提供解析,修改bean定义,并与初始化单例.\n在运行的时候传入的是 DefaultListableBeanFactory为 ConfigurableListableBeanFactory子类且实现了 BeanDefinitionRegistry\n接口。代码如下：\n\n```\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.config.BeanFactoryPostProcessor;\nimport org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistry;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.ApplicationContextAware;\nimport org.springframework.stereotype.Component;\n\npublic class BeanFactoryPostProcesserImpl implements BeanFactoryPostProcessor, ApplicationContextAware {\n\tprivate ApplicationContext applicationContext;\n\n\tpublic void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n\t\tthis.applicationContext = applicationContext;\n\t}\n\n\tpublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n\t\tScanner scanner = new Scanner((BeanDefinitionRegistry) beanFactory);//可以强转\n\t\tscanner.setResourceLoader(this.applicationContext);\n\t\tscanner.setBeanNameGenerator(new AnnotationBeanNameGenerator());//解析注解得到value值。\n\t\tscanner.scan(\"com.extend.service\");//可以在xml配置进来 不再演示\n\t}\n}\n\nimport java.beans.Introspector;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.springframework.beans.factory.annotation.AnnotatedBeanDefinition;\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistry;\nimport org.springframework.beans.factory.support.BeanNameGenerator;\nimport org.springframework.core.annotation.AnnotationAttributes;\nimport org.springframework.core.type.AnnotationMetadata;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.StringUtils;\n\npublic class AnnotationBeanNameGenerator implements BeanNameGenerator {\n\n\tprivate static final String COMPONENT_ANNOTATION_CLASSNAME = \"com.extend.annotation2.Component\";\n\n\t@Override\n\tpublic String generateBeanName(BeanDefinition definition, BeanDefinitionRegistry registry) {\n\t\tif (definition instanceof AnnotatedBeanDefinition) {\n\t\t\tString beanName = determineBeanNameFromAnnotation((AnnotatedBeanDefinition) definition);\n\t\t\tif (StringUtils.hasText(beanName)) {\n\t\t\t\treturn beanName;\n\t\t\t}\n\t\t}\n\t\treturn buildDefaultBeanName(definition, registry);\n\t}\n\n\tprotected String determineBeanNameFromAnnotation(AnnotatedBeanDefinition annotatedDef) {\n\t\tAnnotationMetadata amd = annotatedDef.getMetadata();\n\t\tSet<String> types = amd.getAnnotationTypes();\n\t\tString beanName = null;\n\t\tfor (String type : types) {\n\t\t\tAnnotationAttributes attributes = AnnotationAttributes.fromMap(amd.getAnnotationAttributes(type, false));\n\t\t\t// AnnotationAttributes attributes =\n\t\t\t// AnnotationConfigUtils.attributesFor(amd, type);\n\t\t\tif (isStereotypeWithNameValue(type, amd.getMetaAnnotationTypes(type), attributes)) {\n\t\t\t\tObject value = attributes.get(\"value\");\n\t\t\t\tif (value instanceof String) {\n\t\t\t\t\tString strVal = (String) value;\n\t\t\t\t\tif (StringUtils.hasLength(strVal)) {\n\t\t\t\t\t  if (beanName != null && !strVal.equals(beanName)) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"Stereotype annotations suggest inconsistent \"\n\t\t\t\t\t\t\t\t+ \"component names: '\" + beanName + \"' versus '\" + strVal + \"'\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbeanName = strVal;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn beanName;\n\t}\n\n\tprotected boolean isStereotypeWithNameValue(String annotationType, Set<String> metaAnnotationTypes,\n\t\t\tMap<String, Object> attributes) {\n\n\t\tboolean isStereotype = annotationType.equals(COMPONENT_ANNOTATION_CLASSNAME)\n\t\t\t|| (metaAnnotationTypes != null && metaAnnotationTypes.contains(COMPONENT_ANNOTATION_CLASSNAME))\n\t\t\t|| annotationType.equals(\"javax.annotation.ManagedBean\") || annotationType.equals(\"javax.inject.Named\");\n\n\t\treturn (isStereotype && attributes != null && attributes.containsKey(\"value\"));\n\t}\n\n\tprotected String buildDefaultBeanName(BeanDefinition definition, BeanDefinitionRegistry registry) {\n\t\treturn buildDefaultBeanName(definition);\n\t}\n\n\tprotected String buildDefaultBeanName(BeanDefinition definition) {\n\t\tString shortClassName = ClassUtils.getShortName(definition.getBeanClassName());\n\t\treturn Introspector.decapitalize(shortClassName);\n\t}\n\n}\n```\n\n以上就是实现过程 下面是测试：\n\n```\nimport com.extend.annotation2.Component;\n@Component(\"disCaver1\")\npublic class TestService {\n\tpublic String getName() {\n\t\tSystem.err.println(\"hello world!\");\n\t\treturn \"hello world!\";\n\t}\n}\n\npublic class Test {\n\tpublic static void main(String[] args) throws Exception {\n\t\tClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:spring-mybatis.xml\");\n\t\tcontext.start();\n\t\tTestService disCaver1 = (TestService) context.getBean(\"disCaver1\");\n\t\tTestService disCaver2 = (TestService) context.getBean(TestService.class);\n\t\tdisCaver1.getName();\n\t\tcontext.close();\n\t}\n}\n\t\n```\n\nspring-mybatis.xml：\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t\txmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\"\n\t\txmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\" \n\t\txmlns:cache=\"http://www.springframework.org/schema/cache\"\n\t\txsi:schemaLocation=\"http://www.springframework.org/schema/beans    \n\t           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd    \n\t           http://www.springframework.org/schema/context    \n\t           http://www.springframework.org/schema/context/spring-context-3.0.xsd    \n\t           http://www.springframework.org/schema/aop    \n\t           http://www.springframework.org/schema/aop/spring-aop-3.0.xsd    \n\t           http://www.springframework.org/schema/tx \n\t           http://www.springframework.org/schema/tx/spring-tx-3.0.xsd\n\t           http://code.alibabatech.com/schema/dubbo \n\t\t\t   http://code.alibabatech.com/schema/dubbo/dubbo.xsd\">\n\t\t\t   <bean class=\"com.extend.annotation2.BeanFactoryPostProcesserImpl\"/>\n\t</beans>\n```\n\n结果：\nMethodInterceptorImpl:getName\nhello world!\n \n","slug":"Spring扩展","published":1,"updated":"2024-11-27T03:20:35.258Z","_id":"cm3zaz9c20005tgu63va4ehvo","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"Spring扩展\"><a href=\"#Spring扩展\" class=\"headerlink\" title=\"Spring扩展\"></a>Spring扩展</h1><hr>\n<h3 id=\"为什么要扩展\"><a href=\"#为什么要扩展\" class=\"headerlink\" title=\"为什么要扩展\"></a>为什么要扩展</h3><ol>\n<li>做java开发Spring是必须要用的而且用的很频繁。</li>\n<li>Spring的核心IOC和AOP是我们最想要的，但是有些时候需要把我们自定义的bean的生产过程，bean创建好之后再交给Spring容器。所以重点来了怎么交给它</li>\n<li>其实Spring的设计早就考虑到这些问题了，只是平时没怎么使用而已，本文带你解开它神秘的面纱。</li>\n</ol>\n<h1 id=\"理论加实践\"><a href=\"#理论加实践\" class=\"headerlink\" title=\"理论加实践\"></a>理论加实践</h1><hr>\n<h3 id=\"1-使用Component注解\"><a href=\"#1-使用Component注解\" class=\"headerlink\" title=\"1.使用Component注解\"></a>1.使用Component注解</h3><ol>\n<li>想让Spring扫描我们自定义的注解很简单。只需要在我们的注解上加上 @org.springframework.stereotype.Component 代码如下:</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component</span><br><span class=\"line\">@Retention(RetentionPolicy.RUNTIME)</span><br><span class=\"line\">@Target(ElementType.TYPE)</span><br><span class=\"line\">public @interface MyService &#123;</span><br><span class=\"line\">\tString value() default &quot;&quot;;// 必须要有</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上就可以让Spring扫描到我们的注解，作用和Spring的注解作用是一样的。 细心的同学可能已经发现<br>org.springframework.stereotype.Controller 的注解不就是这样实现的嘛。<br>让我们来看看这是为什么,在<br>org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider类中的registerDefaultFilters 方法中有<br>this.includeFilters.add(new AnnotationTypeFilter(Component.class))这样一句话，看到这里明白了吧 。代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class=\"line\">protected void registerDefaultFilters() &#123;</span><br><span class=\"line\">\tthis.includeFilters.add(new AnnotationTypeFilter(Component.class));</span><br><span class=\"line\">\tClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader();</span><br><span class=\"line\">\ttry &#123;</span><br><span class=\"line\">\t\tthis.includeFilters.add(new AnnotationTypeFilter(</span><br><span class=\"line\">\t\t\t\t((Class&lt;? extends Annotation&gt;) ClassUtils.forName(&quot;javax.annotation.ManagedBean&quot;, cl)), false));</span><br><span class=\"line\">\t\tlogger.debug(&quot;JSR-250 &#x27;javax.annotation.ManagedBean&#x27; found and supported for component scanning&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcatch (ClassNotFoundException ex) &#123;</span><br><span class=\"line\">\t\t// JSR-250 1.1 API (as included in Java EE 6) not available - simply skip.</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ttry &#123;</span><br><span class=\"line\">\t\tthis.includeFilters.add(new AnnotationTypeFilter(</span><br><span class=\"line\">\t\t\t\t((Class&lt;? extends Annotation&gt;) ClassUtils.forName(&quot;javax.inject.Named&quot;, cl)), false));</span><br><span class=\"line\">\t\tlogger.debug(&quot;JSR-330 &#x27;javax.inject.Named&#x27; annotation found and supported for component scanning&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcatch (ClassNotFoundException ex) &#123;</span><br><span class=\"line\">\t\t// JSR-330 API not available - simply skip.</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>你以为这样就完了嘛？如果仅仅是装个x确实完了，被他注解的类会被Spring管理。 但是对于我们来讲是不够滴，应为我们还要定义这个bean的生产过程呀！这才是真正的目的。代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component</span><br><span class=\"line\">public class MyBeanPostProcessor implements BeanPostProcessor &#123;</span><br><span class=\"line\">\tpublic Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;postProcessAfterInitialization  &quot;+ beanName);</span><br><span class=\"line\">\t\treturn bean;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic Object postProcessBeforeInitialization(``````Object bean, String beanName) throws BeansException &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;postProcessBeforeInitialization &quot;+ beanName);</span><br><span class=\"line\">\t\treturn bean;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>BeanPostProcessor接口作用是：如果我们需要在Spring容器完成Bean的实例化、配置和其他的初始化前后添加一些自己的逻辑处理，我们就可以定义一个或者多个BeanPostProcessor接口的实现，然后注册到容器中。两个方法一个之前<br>一个之后。注册到容器时两个方法都会调，获取的时会调postProcessBeforeInitialization方法。我们可以在这里把bean在定制一番,怎么定制就看个人需求啦不再讲述。听SpringMvc就是采用的这种策略，没去验证过。第一种方法就介绍完了。</p>\n<h3 id=\"2-扫描包解析注解\"><a href=\"#2-扫描包解析注解\" class=\"headerlink\" title=\"2.扫描包解析注解\"></a>2.扫描包解析注解</h3><ol>\n<li>先定义注解代码如下：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.lang.annotation.Documented;</span><br><span class=\"line\">import java.lang.annotation.ElementType;</span><br><span class=\"line\">import java.lang.annotation.Retention;</span><br><span class=\"line\">import java.lang.annotation.RetentionPolicy;</span><br><span class=\"line\">import java.lang.annotation.Target;</span><br><span class=\"line\"></span><br><span class=\"line\">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class=\"line\">@Retention(RetentionPolicy.RUNTIME)</span><br><span class=\"line\">@Documented</span><br><span class=\"line\">public @interface Component &#123;</span><br><span class=\"line\">\tString value() default &quot;&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>扫描 既然用到了Spring那么就让Spring来帮我们扫描代码如下：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.Set;</span><br><span class=\"line\">import org.springframework.beans.factory.annotation.AnnotatedBeanDefinition;</span><br><span class=\"line\">import org.springframework.beans.factory.config.BeanDefinitionHolder;</span><br><span class=\"line\">import org.springframework.beans.factory.support.BeanDefinitionRegistry;</span><br><span class=\"line\">import org.springframework.beans.factory.support.GenericBeanDefinition;</span><br><span class=\"line\">import org.springframework.context.annotation.ClassPathBeanDefinitionScanner;</span><br><span class=\"line\">import org.springframework.core.type.filter.AnnotationTypeFilter;</span><br><span class=\"line\"></span><br><span class=\"line\">public final class Scanner extends ClassPathBeanDefinitionScanner &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic Scanner(BeanDefinitionRegistry registry) &#123;</span><br><span class=\"line\">\t\tsuper(registry);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void registerDefaultFilters() &#123;</span><br><span class=\"line\">\t\tthis.addIncludeFilter(new AnnotationTypeFilter(Component.class));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123;</span><br><span class=\"line\">\t\t//super.doScan(basePackages) 会把生成的bean 加入Spring容器</span><br><span class=\"line\">\t\tSet&lt;BeanDefinitionHolder&gt; beanDefinitions = super.doScan(basePackages);</span><br><span class=\"line\">\t\tfor (BeanDefinitionHolder holder : beanDefinitions) &#123;</span><br><span class=\"line\">\t\t\tGenericBeanDefinition definition = (GenericBeanDefinition) holder.getBeanDefinition();</span><br><span class=\"line\">\t\t\t// beanClassName给FactoryBeanImpl使用，还以再加几个Property</span><br><span class=\"line\">\t\t\tdefinition.getPropertyValues().add(&quot;beanClassName&quot;, definition.getBeanClassName()); </span><br><span class=\"line\">\t\t\tdefinition.setBeanClass(FactoryBeanImpl.class);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn beanDefinitions;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) &#123;</span><br><span class=\"line\">\t\treturn super.isCandidateComponent(beanDefinition) </span><br><span class=\"line\">\t\t\t\t\t&amp;&amp; (beanDefinition.getMetadata().hasAnnotation(Component.class.getName()));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码就是扫描，解析后得到的BeanDefinitionHolder 然后指定工厂FactoryBeanImpl生产后加入容器 代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import org.springframework.beans.factory.FactoryBean;</span><br><span class=\"line\">import org.springframework.beans.factory.InitializingBean;</span><br><span class=\"line\">import org.springframework.cglib.core.SpringNamingPolicy;</span><br><span class=\"line\">import org.springframework.cglib.proxy.Enhancer;</span><br><span class=\"line\"></span><br><span class=\"line\">public class FactoryBeanImpl&lt;T&gt; implements InitializingBean, FactoryBean&lt;T&gt; &#123;</span><br><span class=\"line\">\tprivate String beanClassName;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tpublic void setBeanClassName(String beanClassName) &#123;</span><br><span class=\"line\">\t\tthis.beanClassName = beanClassName;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic T getObject() throws Exception &#123;</span><br><span class=\"line\">\t\tClass innerClass = Class.forName(beanClassName);</span><br><span class=\"line\">\t\tif (innerClass.isInterface()) &#123;//接口使用 jdk代理</span><br><span class=\"line\">\t\t\treturn (T) InvocationHandlerImpl.newInstance(innerClass);</span><br><span class=\"line\">\t\t&#125; else &#123;//类使用 cglib代理</span><br><span class=\"line\">\t\t\tEnhancer enhancer = new Enhancer();</span><br><span class=\"line\">\t\t\tenhancer.setSuperclass(innerClass);</span><br><span class=\"line\">\t\t\tenhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class=\"line\">\t\t\tenhancer.setCallback(new MethodInterceptorImpl());</span><br><span class=\"line\">\t\t\treturn (T) enhancer.create();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic Class&lt;?&gt; getObjectType() &#123;</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\treturn Class.forName(beanClassName);</span><br><span class=\"line\">\t\t&#125; catch (ClassNotFoundException e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn null;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic boolean isSingleton() &#123;</span><br><span class=\"line\">\t\treturn true;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void afterPropertiesSet() throws Exception &#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个属性beanClassName是上面扫描绑定过来的。这里就是生成bean的工厂。getObject是bean的生成方法，代理就略过。代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.lang.reflect.InvocationHandler;</span><br><span class=\"line\">import java.lang.reflect.Method;</span><br><span class=\"line\">import java.lang.reflect.Proxy;</span><br><span class=\"line\">public class InvocationHandlerImpl implements InvocationHandler &#123;</span><br><span class=\"line\">  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class=\"line\">      System.out.println(&quot;ObjectProxy execute:&quot; + method.getName());</span><br><span class=\"line\">      return method.invoke(proxy, args);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  public static &lt;T&gt; T newInstance(Class&lt;T&gt; innerInterface) &#123;</span><br><span class=\"line\">      ClassLoader classLoader = innerInterface.getClassLoader();</span><br><span class=\"line\">      Class[] interfaces = new Class[] &#123; innerInterface &#125;;</span><br><span class=\"line\">      InvocationHandlerImpl proxy = new InvocationHandlerImpl();</span><br><span class=\"line\">      return (T) Proxy.newProxyInstance(classLoader, interfaces, proxy);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"></span><br><span class=\"line\">import java.lang.reflect.Method;</span><br><span class=\"line\">import org.springframework.cglib.proxy.MethodInterceptor;</span><br><span class=\"line\">import org.springframework.cglib.proxy.MethodProxy;</span><br><span class=\"line\"></span><br><span class=\"line\">public class MethodInterceptorImpl implements MethodInterceptor &#123;</span><br><span class=\"line\">\tpublic Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;MethodInterceptorImpl:&quot; + method.getName());</span><br><span class=\"line\">\t\treturn methodProxy.invokeSuper(o, objects);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.什么都做了，什么时候扫描</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Scanner(BeanDefinitionRegistry registry) &#123;</span><br><span class=\"line\">    super(registry);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在实例化Scanner时需要 BeanDefinitionRegistry该类的作用主要是向注册表中注册 BeanDefinition实例 完成注册的过程。<br>BeanFactoryPostProcessor是在spring容器加载了bean的定义文件之后，在bean实例化之前执行的。<br>ConfigurableListableBeanFactory该类提供解析,修改bean定义,并与初始化单例.<br>在运行的时候传入的是 DefaultListableBeanFactory为 ConfigurableListableBeanFactory子类且实现了 BeanDefinitionRegistry<br>接口。代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import org.springframework.beans.BeansException;</span><br><span class=\"line\">import org.springframework.beans.factory.config.BeanFactoryPostProcessor;</span><br><span class=\"line\">import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;</span><br><span class=\"line\">import org.springframework.beans.factory.support.BeanDefinitionRegistry;</span><br><span class=\"line\">import org.springframework.context.ApplicationContext;</span><br><span class=\"line\">import org.springframework.context.ApplicationContextAware;</span><br><span class=\"line\">import org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\">public class BeanFactoryPostProcesserImpl implements BeanFactoryPostProcessor, ApplicationContextAware &#123;</span><br><span class=\"line\">\tprivate ApplicationContext applicationContext;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class=\"line\">\t\tthis.applicationContext = applicationContext;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;</span><br><span class=\"line\">\t\tScanner scanner = new Scanner((BeanDefinitionRegistry) beanFactory);//可以强转</span><br><span class=\"line\">\t\tscanner.setResourceLoader(this.applicationContext);</span><br><span class=\"line\">\t\tscanner.setBeanNameGenerator(new AnnotationBeanNameGenerator());//解析注解得到value值。</span><br><span class=\"line\">\t\tscanner.scan(&quot;com.extend.service&quot;);//可以在xml配置进来 不再演示</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.beans.Introspector;</span><br><span class=\"line\">import java.util.Map;</span><br><span class=\"line\">import java.util.Set;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.springframework.beans.factory.annotation.AnnotatedBeanDefinition;</span><br><span class=\"line\">import org.springframework.beans.factory.config.BeanDefinition;</span><br><span class=\"line\">import org.springframework.beans.factory.support.BeanDefinitionRegistry;</span><br><span class=\"line\">import org.springframework.beans.factory.support.BeanNameGenerator;</span><br><span class=\"line\">import org.springframework.core.annotation.AnnotationAttributes;</span><br><span class=\"line\">import org.springframework.core.type.AnnotationMetadata;</span><br><span class=\"line\">import org.springframework.util.ClassUtils;</span><br><span class=\"line\">import org.springframework.util.StringUtils;</span><br><span class=\"line\"></span><br><span class=\"line\">public class AnnotationBeanNameGenerator implements BeanNameGenerator &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate static final String COMPONENT_ANNOTATION_CLASSNAME = &quot;com.extend.annotation2.Component&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic String generateBeanName(BeanDefinition definition, BeanDefinitionRegistry registry) &#123;</span><br><span class=\"line\">\t\tif (definition instanceof AnnotatedBeanDefinition) &#123;</span><br><span class=\"line\">\t\t\tString beanName = determineBeanNameFromAnnotation((AnnotatedBeanDefinition) definition);</span><br><span class=\"line\">\t\t\tif (StringUtils.hasText(beanName)) &#123;</span><br><span class=\"line\">\t\t\t\treturn beanName;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn buildDefaultBeanName(definition, registry);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprotected String determineBeanNameFromAnnotation(AnnotatedBeanDefinition annotatedDef) &#123;</span><br><span class=\"line\">\t\tAnnotationMetadata amd = annotatedDef.getMetadata();</span><br><span class=\"line\">\t\tSet&lt;String&gt; types = amd.getAnnotationTypes();</span><br><span class=\"line\">\t\tString beanName = null;</span><br><span class=\"line\">\t\tfor (String type : types) &#123;</span><br><span class=\"line\">\t\t\tAnnotationAttributes attributes = AnnotationAttributes.fromMap(amd.getAnnotationAttributes(type, false));</span><br><span class=\"line\">\t\t\t// AnnotationAttributes attributes =</span><br><span class=\"line\">\t\t\t// AnnotationConfigUtils.attributesFor(amd, type);</span><br><span class=\"line\">\t\t\tif (isStereotypeWithNameValue(type, amd.getMetaAnnotationTypes(type), attributes)) &#123;</span><br><span class=\"line\">\t\t\t\tObject value = attributes.get(&quot;value&quot;);</span><br><span class=\"line\">\t\t\t\tif (value instanceof String) &#123;</span><br><span class=\"line\">\t\t\t\t\tString strVal = (String) value;</span><br><span class=\"line\">\t\t\t\t\tif (StringUtils.hasLength(strVal)) &#123;</span><br><span class=\"line\">\t\t\t\t\t  if (beanName != null &amp;&amp; !strVal.equals(beanName)) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tthrow new IllegalStateException(&quot;Stereotype annotations suggest inconsistent &quot;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t+ &quot;component names: &#x27;&quot; + beanName + &quot;&#x27; versus &#x27;&quot; + strVal + &quot;&#x27;&quot;);</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t\tbeanName = strVal;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn beanName;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprotected boolean isStereotypeWithNameValue(String annotationType, Set&lt;String&gt; metaAnnotationTypes,</span><br><span class=\"line\">\t\t\tMap&lt;String, Object&gt; attributes) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tboolean isStereotype = annotationType.equals(COMPONENT_ANNOTATION_CLASSNAME)</span><br><span class=\"line\">\t\t\t|| (metaAnnotationTypes != null &amp;&amp; metaAnnotationTypes.contains(COMPONENT_ANNOTATION_CLASSNAME))</span><br><span class=\"line\">\t\t\t|| annotationType.equals(&quot;javax.annotation.ManagedBean&quot;) || annotationType.equals(&quot;javax.inject.Named&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\treturn (isStereotype &amp;&amp; attributes != null &amp;&amp; attributes.containsKey(&quot;value&quot;));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprotected String buildDefaultBeanName(BeanDefinition definition, BeanDefinitionRegistry registry) &#123;</span><br><span class=\"line\">\t\treturn buildDefaultBeanName(definition);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprotected String buildDefaultBeanName(BeanDefinition definition) &#123;</span><br><span class=\"line\">\t\tString shortClassName = ClassUtils.getShortName(definition.getBeanClassName());</span><br><span class=\"line\">\t\treturn Introspector.decapitalize(shortClassName);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上就是实现过程 下面是测试：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import com.extend.annotation2.Component;</span><br><span class=\"line\">@Component(&quot;disCaver1&quot;)</span><br><span class=\"line\">public class TestService &#123;</span><br><span class=\"line\">\tpublic String getName() &#123;</span><br><span class=\"line\">\t\tSystem.err.println(&quot;hello world!&quot;);</span><br><span class=\"line\">\t\treturn &quot;hello world!&quot;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Test &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">\t\tClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:spring-mybatis.xml&quot;);</span><br><span class=\"line\">\t\tcontext.start();</span><br><span class=\"line\">\t\tTestService disCaver1 = (TestService) context.getBean(&quot;disCaver1&quot;);</span><br><span class=\"line\">\t\tTestService disCaver2 = (TestService) context.getBean(TestService.class);</span><br><span class=\"line\">\t\tdisCaver1.getName();</span><br><span class=\"line\">\t\tcontext.close();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br></pre></td></tr></table></figure>\n\n<p>spring-mybatis.xml：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class=\"line\">\t&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class=\"line\">\t\txmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class=\"line\">\t\txmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; </span><br><span class=\"line\">\t\txmlns:cache=&quot;http://www.springframework.org/schema/cache&quot;</span><br><span class=\"line\">\t\txsi:schemaLocation=&quot;http://www.springframework.org/schema/beans    </span><br><span class=\"line\">\t           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd    </span><br><span class=\"line\">\t           http://www.springframework.org/schema/context    </span><br><span class=\"line\">\t           http://www.springframework.org/schema/context/spring-context-3.0.xsd    </span><br><span class=\"line\">\t           http://www.springframework.org/schema/aop    </span><br><span class=\"line\">\t           http://www.springframework.org/schema/aop/spring-aop-3.0.xsd    </span><br><span class=\"line\">\t           http://www.springframework.org/schema/tx </span><br><span class=\"line\">\t           http://www.springframework.org/schema/tx/spring-tx-3.0.xsd</span><br><span class=\"line\">\t           http://code.alibabatech.com/schema/dubbo </span><br><span class=\"line\">\t\t\t   http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt;</span><br><span class=\"line\">\t\t\t   &lt;bean class=&quot;com.extend.annotation2.BeanFactoryPostProcesserImpl&quot;/&gt;</span><br><span class=\"line\">\t&lt;/beans&gt;</span><br></pre></td></tr></table></figure>\n\n<p>结果：<br>MethodInterceptorImpl:getName<br>hello world!</p>\n","excerpt":"","more":"<h1 id=\"Spring扩展\"><a href=\"#Spring扩展\" class=\"headerlink\" title=\"Spring扩展\"></a>Spring扩展</h1><hr>\n<h3 id=\"为什么要扩展\"><a href=\"#为什么要扩展\" class=\"headerlink\" title=\"为什么要扩展\"></a>为什么要扩展</h3><ol>\n<li>做java开发Spring是必须要用的而且用的很频繁。</li>\n<li>Spring的核心IOC和AOP是我们最想要的，但是有些时候需要把我们自定义的bean的生产过程，bean创建好之后再交给Spring容器。所以重点来了怎么交给它</li>\n<li>其实Spring的设计早就考虑到这些问题了，只是平时没怎么使用而已，本文带你解开它神秘的面纱。</li>\n</ol>\n<h1 id=\"理论加实践\"><a href=\"#理论加实践\" class=\"headerlink\" title=\"理论加实践\"></a>理论加实践</h1><hr>\n<h3 id=\"1-使用Component注解\"><a href=\"#1-使用Component注解\" class=\"headerlink\" title=\"1.使用Component注解\"></a>1.使用Component注解</h3><ol>\n<li>想让Spring扫描我们自定义的注解很简单。只需要在我们的注解上加上 @org.springframework.stereotype.Component 代码如下:</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component</span><br><span class=\"line\">@Retention(RetentionPolicy.RUNTIME)</span><br><span class=\"line\">@Target(ElementType.TYPE)</span><br><span class=\"line\">public @interface MyService &#123;</span><br><span class=\"line\">\tString value() default &quot;&quot;;// 必须要有</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上就可以让Spring扫描到我们的注解，作用和Spring的注解作用是一样的。 细心的同学可能已经发现<br>org.springframework.stereotype.Controller 的注解不就是这样实现的嘛。<br>让我们来看看这是为什么,在<br>org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider类中的registerDefaultFilters 方法中有<br>this.includeFilters.add(new AnnotationTypeFilter(Component.class))这样一句话，看到这里明白了吧 。代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class=\"line\">protected void registerDefaultFilters() &#123;</span><br><span class=\"line\">\tthis.includeFilters.add(new AnnotationTypeFilter(Component.class));</span><br><span class=\"line\">\tClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader();</span><br><span class=\"line\">\ttry &#123;</span><br><span class=\"line\">\t\tthis.includeFilters.add(new AnnotationTypeFilter(</span><br><span class=\"line\">\t\t\t\t((Class&lt;? extends Annotation&gt;) ClassUtils.forName(&quot;javax.annotation.ManagedBean&quot;, cl)), false));</span><br><span class=\"line\">\t\tlogger.debug(&quot;JSR-250 &#x27;javax.annotation.ManagedBean&#x27; found and supported for component scanning&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcatch (ClassNotFoundException ex) &#123;</span><br><span class=\"line\">\t\t// JSR-250 1.1 API (as included in Java EE 6) not available - simply skip.</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ttry &#123;</span><br><span class=\"line\">\t\tthis.includeFilters.add(new AnnotationTypeFilter(</span><br><span class=\"line\">\t\t\t\t((Class&lt;? extends Annotation&gt;) ClassUtils.forName(&quot;javax.inject.Named&quot;, cl)), false));</span><br><span class=\"line\">\t\tlogger.debug(&quot;JSR-330 &#x27;javax.inject.Named&#x27; annotation found and supported for component scanning&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcatch (ClassNotFoundException ex) &#123;</span><br><span class=\"line\">\t\t// JSR-330 API not available - simply skip.</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>你以为这样就完了嘛？如果仅仅是装个x确实完了，被他注解的类会被Spring管理。 但是对于我们来讲是不够滴，应为我们还要定义这个bean的生产过程呀！这才是真正的目的。代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component</span><br><span class=\"line\">public class MyBeanPostProcessor implements BeanPostProcessor &#123;</span><br><span class=\"line\">\tpublic Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;postProcessAfterInitialization  &quot;+ beanName);</span><br><span class=\"line\">\t\treturn bean;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic Object postProcessBeforeInitialization(``````Object bean, String beanName) throws BeansException &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;postProcessBeforeInitialization &quot;+ beanName);</span><br><span class=\"line\">\t\treturn bean;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>BeanPostProcessor接口作用是：如果我们需要在Spring容器完成Bean的实例化、配置和其他的初始化前后添加一些自己的逻辑处理，我们就可以定义一个或者多个BeanPostProcessor接口的实现，然后注册到容器中。两个方法一个之前<br>一个之后。注册到容器时两个方法都会调，获取的时会调postProcessBeforeInitialization方法。我们可以在这里把bean在定制一番,怎么定制就看个人需求啦不再讲述。听SpringMvc就是采用的这种策略，没去验证过。第一种方法就介绍完了。</p>\n<h3 id=\"2-扫描包解析注解\"><a href=\"#2-扫描包解析注解\" class=\"headerlink\" title=\"2.扫描包解析注解\"></a>2.扫描包解析注解</h3><ol>\n<li>先定义注解代码如下：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.lang.annotation.Documented;</span><br><span class=\"line\">import java.lang.annotation.ElementType;</span><br><span class=\"line\">import java.lang.annotation.Retention;</span><br><span class=\"line\">import java.lang.annotation.RetentionPolicy;</span><br><span class=\"line\">import java.lang.annotation.Target;</span><br><span class=\"line\"></span><br><span class=\"line\">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class=\"line\">@Retention(RetentionPolicy.RUNTIME)</span><br><span class=\"line\">@Documented</span><br><span class=\"line\">public @interface Component &#123;</span><br><span class=\"line\">\tString value() default &quot;&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>扫描 既然用到了Spring那么就让Spring来帮我们扫描代码如下：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.Set;</span><br><span class=\"line\">import org.springframework.beans.factory.annotation.AnnotatedBeanDefinition;</span><br><span class=\"line\">import org.springframework.beans.factory.config.BeanDefinitionHolder;</span><br><span class=\"line\">import org.springframework.beans.factory.support.BeanDefinitionRegistry;</span><br><span class=\"line\">import org.springframework.beans.factory.support.GenericBeanDefinition;</span><br><span class=\"line\">import org.springframework.context.annotation.ClassPathBeanDefinitionScanner;</span><br><span class=\"line\">import org.springframework.core.type.filter.AnnotationTypeFilter;</span><br><span class=\"line\"></span><br><span class=\"line\">public final class Scanner extends ClassPathBeanDefinitionScanner &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic Scanner(BeanDefinitionRegistry registry) &#123;</span><br><span class=\"line\">\t\tsuper(registry);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void registerDefaultFilters() &#123;</span><br><span class=\"line\">\t\tthis.addIncludeFilter(new AnnotationTypeFilter(Component.class));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123;</span><br><span class=\"line\">\t\t//super.doScan(basePackages) 会把生成的bean 加入Spring容器</span><br><span class=\"line\">\t\tSet&lt;BeanDefinitionHolder&gt; beanDefinitions = super.doScan(basePackages);</span><br><span class=\"line\">\t\tfor (BeanDefinitionHolder holder : beanDefinitions) &#123;</span><br><span class=\"line\">\t\t\tGenericBeanDefinition definition = (GenericBeanDefinition) holder.getBeanDefinition();</span><br><span class=\"line\">\t\t\t// beanClassName给FactoryBeanImpl使用，还以再加几个Property</span><br><span class=\"line\">\t\t\tdefinition.getPropertyValues().add(&quot;beanClassName&quot;, definition.getBeanClassName()); </span><br><span class=\"line\">\t\t\tdefinition.setBeanClass(FactoryBeanImpl.class);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn beanDefinitions;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) &#123;</span><br><span class=\"line\">\t\treturn super.isCandidateComponent(beanDefinition) </span><br><span class=\"line\">\t\t\t\t\t&amp;&amp; (beanDefinition.getMetadata().hasAnnotation(Component.class.getName()));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码就是扫描，解析后得到的BeanDefinitionHolder 然后指定工厂FactoryBeanImpl生产后加入容器 代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import org.springframework.beans.factory.FactoryBean;</span><br><span class=\"line\">import org.springframework.beans.factory.InitializingBean;</span><br><span class=\"line\">import org.springframework.cglib.core.SpringNamingPolicy;</span><br><span class=\"line\">import org.springframework.cglib.proxy.Enhancer;</span><br><span class=\"line\"></span><br><span class=\"line\">public class FactoryBeanImpl&lt;T&gt; implements InitializingBean, FactoryBean&lt;T&gt; &#123;</span><br><span class=\"line\">\tprivate String beanClassName;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tpublic void setBeanClassName(String beanClassName) &#123;</span><br><span class=\"line\">\t\tthis.beanClassName = beanClassName;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic T getObject() throws Exception &#123;</span><br><span class=\"line\">\t\tClass innerClass = Class.forName(beanClassName);</span><br><span class=\"line\">\t\tif (innerClass.isInterface()) &#123;//接口使用 jdk代理</span><br><span class=\"line\">\t\t\treturn (T) InvocationHandlerImpl.newInstance(innerClass);</span><br><span class=\"line\">\t\t&#125; else &#123;//类使用 cglib代理</span><br><span class=\"line\">\t\t\tEnhancer enhancer = new Enhancer();</span><br><span class=\"line\">\t\t\tenhancer.setSuperclass(innerClass);</span><br><span class=\"line\">\t\t\tenhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class=\"line\">\t\t\tenhancer.setCallback(new MethodInterceptorImpl());</span><br><span class=\"line\">\t\t\treturn (T) enhancer.create();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic Class&lt;?&gt; getObjectType() &#123;</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\treturn Class.forName(beanClassName);</span><br><span class=\"line\">\t\t&#125; catch (ClassNotFoundException e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn null;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic boolean isSingleton() &#123;</span><br><span class=\"line\">\t\treturn true;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void afterPropertiesSet() throws Exception &#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个属性beanClassName是上面扫描绑定过来的。这里就是生成bean的工厂。getObject是bean的生成方法，代理就略过。代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.lang.reflect.InvocationHandler;</span><br><span class=\"line\">import java.lang.reflect.Method;</span><br><span class=\"line\">import java.lang.reflect.Proxy;</span><br><span class=\"line\">public class InvocationHandlerImpl implements InvocationHandler &#123;</span><br><span class=\"line\">  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class=\"line\">      System.out.println(&quot;ObjectProxy execute:&quot; + method.getName());</span><br><span class=\"line\">      return method.invoke(proxy, args);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  public static &lt;T&gt; T newInstance(Class&lt;T&gt; innerInterface) &#123;</span><br><span class=\"line\">      ClassLoader classLoader = innerInterface.getClassLoader();</span><br><span class=\"line\">      Class[] interfaces = new Class[] &#123; innerInterface &#125;;</span><br><span class=\"line\">      InvocationHandlerImpl proxy = new InvocationHandlerImpl();</span><br><span class=\"line\">      return (T) Proxy.newProxyInstance(classLoader, interfaces, proxy);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"></span><br><span class=\"line\">import java.lang.reflect.Method;</span><br><span class=\"line\">import org.springframework.cglib.proxy.MethodInterceptor;</span><br><span class=\"line\">import org.springframework.cglib.proxy.MethodProxy;</span><br><span class=\"line\"></span><br><span class=\"line\">public class MethodInterceptorImpl implements MethodInterceptor &#123;</span><br><span class=\"line\">\tpublic Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;MethodInterceptorImpl:&quot; + method.getName());</span><br><span class=\"line\">\t\treturn methodProxy.invokeSuper(o, objects);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.什么都做了，什么时候扫描</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Scanner(BeanDefinitionRegistry registry) &#123;</span><br><span class=\"line\">    super(registry);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在实例化Scanner时需要 BeanDefinitionRegistry该类的作用主要是向注册表中注册 BeanDefinition实例 完成注册的过程。<br>BeanFactoryPostProcessor是在spring容器加载了bean的定义文件之后，在bean实例化之前执行的。<br>ConfigurableListableBeanFactory该类提供解析,修改bean定义,并与初始化单例.<br>在运行的时候传入的是 DefaultListableBeanFactory为 ConfigurableListableBeanFactory子类且实现了 BeanDefinitionRegistry<br>接口。代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import org.springframework.beans.BeansException;</span><br><span class=\"line\">import org.springframework.beans.factory.config.BeanFactoryPostProcessor;</span><br><span class=\"line\">import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;</span><br><span class=\"line\">import org.springframework.beans.factory.support.BeanDefinitionRegistry;</span><br><span class=\"line\">import org.springframework.context.ApplicationContext;</span><br><span class=\"line\">import org.springframework.context.ApplicationContextAware;</span><br><span class=\"line\">import org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\">public class BeanFactoryPostProcesserImpl implements BeanFactoryPostProcessor, ApplicationContextAware &#123;</span><br><span class=\"line\">\tprivate ApplicationContext applicationContext;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class=\"line\">\t\tthis.applicationContext = applicationContext;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;</span><br><span class=\"line\">\t\tScanner scanner = new Scanner((BeanDefinitionRegistry) beanFactory);//可以强转</span><br><span class=\"line\">\t\tscanner.setResourceLoader(this.applicationContext);</span><br><span class=\"line\">\t\tscanner.setBeanNameGenerator(new AnnotationBeanNameGenerator());//解析注解得到value值。</span><br><span class=\"line\">\t\tscanner.scan(&quot;com.extend.service&quot;);//可以在xml配置进来 不再演示</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.beans.Introspector;</span><br><span class=\"line\">import java.util.Map;</span><br><span class=\"line\">import java.util.Set;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.springframework.beans.factory.annotation.AnnotatedBeanDefinition;</span><br><span class=\"line\">import org.springframework.beans.factory.config.BeanDefinition;</span><br><span class=\"line\">import org.springframework.beans.factory.support.BeanDefinitionRegistry;</span><br><span class=\"line\">import org.springframework.beans.factory.support.BeanNameGenerator;</span><br><span class=\"line\">import org.springframework.core.annotation.AnnotationAttributes;</span><br><span class=\"line\">import org.springframework.core.type.AnnotationMetadata;</span><br><span class=\"line\">import org.springframework.util.ClassUtils;</span><br><span class=\"line\">import org.springframework.util.StringUtils;</span><br><span class=\"line\"></span><br><span class=\"line\">public class AnnotationBeanNameGenerator implements BeanNameGenerator &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate static final String COMPONENT_ANNOTATION_CLASSNAME = &quot;com.extend.annotation2.Component&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic String generateBeanName(BeanDefinition definition, BeanDefinitionRegistry registry) &#123;</span><br><span class=\"line\">\t\tif (definition instanceof AnnotatedBeanDefinition) &#123;</span><br><span class=\"line\">\t\t\tString beanName = determineBeanNameFromAnnotation((AnnotatedBeanDefinition) definition);</span><br><span class=\"line\">\t\t\tif (StringUtils.hasText(beanName)) &#123;</span><br><span class=\"line\">\t\t\t\treturn beanName;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn buildDefaultBeanName(definition, registry);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprotected String determineBeanNameFromAnnotation(AnnotatedBeanDefinition annotatedDef) &#123;</span><br><span class=\"line\">\t\tAnnotationMetadata amd = annotatedDef.getMetadata();</span><br><span class=\"line\">\t\tSet&lt;String&gt; types = amd.getAnnotationTypes();</span><br><span class=\"line\">\t\tString beanName = null;</span><br><span class=\"line\">\t\tfor (String type : types) &#123;</span><br><span class=\"line\">\t\t\tAnnotationAttributes attributes = AnnotationAttributes.fromMap(amd.getAnnotationAttributes(type, false));</span><br><span class=\"line\">\t\t\t// AnnotationAttributes attributes =</span><br><span class=\"line\">\t\t\t// AnnotationConfigUtils.attributesFor(amd, type);</span><br><span class=\"line\">\t\t\tif (isStereotypeWithNameValue(type, amd.getMetaAnnotationTypes(type), attributes)) &#123;</span><br><span class=\"line\">\t\t\t\tObject value = attributes.get(&quot;value&quot;);</span><br><span class=\"line\">\t\t\t\tif (value instanceof String) &#123;</span><br><span class=\"line\">\t\t\t\t\tString strVal = (String) value;</span><br><span class=\"line\">\t\t\t\t\tif (StringUtils.hasLength(strVal)) &#123;</span><br><span class=\"line\">\t\t\t\t\t  if (beanName != null &amp;&amp; !strVal.equals(beanName)) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tthrow new IllegalStateException(&quot;Stereotype annotations suggest inconsistent &quot;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t+ &quot;component names: &#x27;&quot; + beanName + &quot;&#x27; versus &#x27;&quot; + strVal + &quot;&#x27;&quot;);</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t\tbeanName = strVal;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn beanName;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprotected boolean isStereotypeWithNameValue(String annotationType, Set&lt;String&gt; metaAnnotationTypes,</span><br><span class=\"line\">\t\t\tMap&lt;String, Object&gt; attributes) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tboolean isStereotype = annotationType.equals(COMPONENT_ANNOTATION_CLASSNAME)</span><br><span class=\"line\">\t\t\t|| (metaAnnotationTypes != null &amp;&amp; metaAnnotationTypes.contains(COMPONENT_ANNOTATION_CLASSNAME))</span><br><span class=\"line\">\t\t\t|| annotationType.equals(&quot;javax.annotation.ManagedBean&quot;) || annotationType.equals(&quot;javax.inject.Named&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\treturn (isStereotype &amp;&amp; attributes != null &amp;&amp; attributes.containsKey(&quot;value&quot;));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprotected String buildDefaultBeanName(BeanDefinition definition, BeanDefinitionRegistry registry) &#123;</span><br><span class=\"line\">\t\treturn buildDefaultBeanName(definition);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprotected String buildDefaultBeanName(BeanDefinition definition) &#123;</span><br><span class=\"line\">\t\tString shortClassName = ClassUtils.getShortName(definition.getBeanClassName());</span><br><span class=\"line\">\t\treturn Introspector.decapitalize(shortClassName);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上就是实现过程 下面是测试：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import com.extend.annotation2.Component;</span><br><span class=\"line\">@Component(&quot;disCaver1&quot;)</span><br><span class=\"line\">public class TestService &#123;</span><br><span class=\"line\">\tpublic String getName() &#123;</span><br><span class=\"line\">\t\tSystem.err.println(&quot;hello world!&quot;);</span><br><span class=\"line\">\t\treturn &quot;hello world!&quot;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Test &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">\t\tClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:spring-mybatis.xml&quot;);</span><br><span class=\"line\">\t\tcontext.start();</span><br><span class=\"line\">\t\tTestService disCaver1 = (TestService) context.getBean(&quot;disCaver1&quot;);</span><br><span class=\"line\">\t\tTestService disCaver2 = (TestService) context.getBean(TestService.class);</span><br><span class=\"line\">\t\tdisCaver1.getName();</span><br><span class=\"line\">\t\tcontext.close();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br></pre></td></tr></table></figure>\n\n<p>spring-mybatis.xml：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class=\"line\">\t&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class=\"line\">\t\txmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class=\"line\">\t\txmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; </span><br><span class=\"line\">\t\txmlns:cache=&quot;http://www.springframework.org/schema/cache&quot;</span><br><span class=\"line\">\t\txsi:schemaLocation=&quot;http://www.springframework.org/schema/beans    </span><br><span class=\"line\">\t           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd    </span><br><span class=\"line\">\t           http://www.springframework.org/schema/context    </span><br><span class=\"line\">\t           http://www.springframework.org/schema/context/spring-context-3.0.xsd    </span><br><span class=\"line\">\t           http://www.springframework.org/schema/aop    </span><br><span class=\"line\">\t           http://www.springframework.org/schema/aop/spring-aop-3.0.xsd    </span><br><span class=\"line\">\t           http://www.springframework.org/schema/tx </span><br><span class=\"line\">\t           http://www.springframework.org/schema/tx/spring-tx-3.0.xsd</span><br><span class=\"line\">\t           http://code.alibabatech.com/schema/dubbo </span><br><span class=\"line\">\t\t\t   http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt;</span><br><span class=\"line\">\t\t\t   &lt;bean class=&quot;com.extend.annotation2.BeanFactoryPostProcesserImpl&quot;/&gt;</span><br><span class=\"line\">\t&lt;/beans&gt;</span><br></pre></td></tr></table></figure>\n\n<p>结果：<br>MethodInterceptorImpl:getName<br>hello world!</p>\n"},{"title":"java中强引用，软引用，弱引用，虚引用概念比较","excerpt":"在JAVA垃圾回收，内存分配过程中，经常会涉及对象的生命周期，而判定对象是否存货都与“引用”有关。Java中的引用的定义非常简单粗糙：如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就表示该内存块存在一个引用。这样分类会将对讲划分成两个类别：有引用、无引用。我们希望能够根据GC回收时间来对对象引用进行划分：当内存空间足够时，对象的引用继续保持；当内存不够时，抛弃这些对象。","date":"2016-03-14T16:00:00.000Z","_content":"\n在JAVA垃圾回收，内存分配过程中，经常会涉及对象的生命周期，而判定对象是否存货都与“引用”有关。Java中的引用的定义非常简单粗糙：如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就表示该内存块存在一个引用。这样分类会将对讲划分成两个类别：有引用、无引用。我们希望能够根据GC回收时间来对对象引用进行划分：当内存空间足够时，对象的引用继续保持；当内存不够时，抛弃这些对象。\n\n### 1. 概念解释\n\n> **强引用**是使用最普遍的引用：Object o=new Object(); 特点：不会被GC\n\n- 将对象的引用显示地置为null：o=null; // 帮助垃圾收集器回收此对象\n- 举例ArrayList的实现源代码：\n  ![强引用 截图](../images/20160515P1.jpg)\n\n> **软引用**\n>\n用来描述一些还有用但是并非必须的对象，在Java中用java.lang.ref.SoftReference类来表示。对于软引用关联着的对象，只有在内存不足的时候JVM才会回收该对象。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。\n\n- 浏览器网页缓存实例：\n  ![软引用 截图](../images/20160515P2.jpg)\n- 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。\n\n> **弱引用**\n>\n与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。\n> 如果这个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 Weak Reference\n> 来记住此对象。\n\n- 弱引用实例：\n  ![弱引用 截图](../images/20160515P3.jpg)\n\n> **虚引用**也称为幻影引用：一个对象是都有虚引用的存在都不会对生存时间都构成影响，也无法通过虚引用来获取对一个对象的真实引用。唯一的用处：能在对象被GC时收到系统通知，JAVA中用PhantomReference来实现虚引用。\n\n### 2. 对比不同\n\n| 引用类型 | GC回收时间  |    用途    |   生存时间   |\n|:----:|:-------:|:--------:|:--------:|\n| 强引用\t | never\t  | 对象的一般状态\t | JVM停止运行时 |\n| 软引用\t | 内存不足时\t  |  对象缓存\t   | 内存不足时终止  |\n| 弱引用\t |  GC时\t   |   对象缓存   |  GC后终止   |\n| 虚引用\t | unknow\t | unknow\t  |  unknow  |","source":"_posts/java中强引用，软引用，弱引用，虚引用概念比较.md","raw":"---\ntitle: java中强引用，软引用，弱引用，虚引用概念比较\nexcerpt: 在JAVA垃圾回收，内存分配过程中，经常会涉及对象的生命周期，而判定对象是否存货都与“引用”有关。Java中的引用的定义非常简单粗糙：如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就表示该内存块存在一个引用。这样分类会将对讲划分成两个类别：有引用、无引用。我们希望能够根据GC回收时间来对对象引用进行划分：当内存空间足够时，对象的引用继续保持；当内存不够时，抛弃这些对象。\ndate: 2016-03-15 00:00:00\ncategory: JAVA\ntags:\n  - 基础知识\n---\n\n在JAVA垃圾回收，内存分配过程中，经常会涉及对象的生命周期，而判定对象是否存货都与“引用”有关。Java中的引用的定义非常简单粗糙：如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就表示该内存块存在一个引用。这样分类会将对讲划分成两个类别：有引用、无引用。我们希望能够根据GC回收时间来对对象引用进行划分：当内存空间足够时，对象的引用继续保持；当内存不够时，抛弃这些对象。\n\n### 1. 概念解释\n\n> **强引用**是使用最普遍的引用：Object o=new Object(); 特点：不会被GC\n\n- 将对象的引用显示地置为null：o=null; // 帮助垃圾收集器回收此对象\n- 举例ArrayList的实现源代码：\n  ![强引用 截图](../images/20160515P1.jpg)\n\n> **软引用**\n>\n用来描述一些还有用但是并非必须的对象，在Java中用java.lang.ref.SoftReference类来表示。对于软引用关联着的对象，只有在内存不足的时候JVM才会回收该对象。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。\n\n- 浏览器网页缓存实例：\n  ![软引用 截图](../images/20160515P2.jpg)\n- 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。\n\n> **弱引用**\n>\n与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。\n> 如果这个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 Weak Reference\n> 来记住此对象。\n\n- 弱引用实例：\n  ![弱引用 截图](../images/20160515P3.jpg)\n\n> **虚引用**也称为幻影引用：一个对象是都有虚引用的存在都不会对生存时间都构成影响，也无法通过虚引用来获取对一个对象的真实引用。唯一的用处：能在对象被GC时收到系统通知，JAVA中用PhantomReference来实现虚引用。\n\n### 2. 对比不同\n\n| 引用类型 | GC回收时间  |    用途    |   生存时间   |\n|:----:|:-------:|:--------:|:--------:|\n| 强引用\t | never\t  | 对象的一般状态\t | JVM停止运行时 |\n| 软引用\t | 内存不足时\t  |  对象缓存\t   | 内存不足时终止  |\n| 弱引用\t |  GC时\t   |   对象缓存   |  GC后终止   |\n| 虚引用\t | unknow\t | unknow\t  |  unknow  |","slug":"java中强引用，软引用，弱引用，虚引用概念比较","published":1,"updated":"2024-11-27T04:20:14.153Z","_id":"cm3zaz9c20007tgu687gnbwqk","comments":1,"layout":"post","photos":[],"content":"<p>在JAVA垃圾回收，内存分配过程中，经常会涉及对象的生命周期，而判定对象是否存货都与“引用”有关。Java中的引用的定义非常简单粗糙：如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就表示该内存块存在一个引用。这样分类会将对讲划分成两个类别：有引用、无引用。我们希望能够根据GC回收时间来对对象引用进行划分：当内存空间足够时，对象的引用继续保持；当内存不够时，抛弃这些对象。</p>\n<h3 id=\"1-概念解释\"><a href=\"#1-概念解释\" class=\"headerlink\" title=\"1. 概念解释\"></a>1. 概念解释</h3><blockquote>\n<p><strong>强引用</strong>是使用最普遍的引用：Object o&#x3D;new Object(); 特点：不会被GC</p>\n</blockquote>\n<ul>\n<li>将对象的引用显示地置为null：o&#x3D;null; &#x2F;&#x2F; 帮助垃圾收集器回收此对象</li>\n<li>举例ArrayList的实现源代码：<br><img src=\"/../images/20160515P1.jpg\" alt=\"强引用 截图\"></li>\n</ul>\n<blockquote>\n<p><strong>软引用</strong></p>\n</blockquote>\n<p>用来描述一些还有用但是并非必须的对象，在Java中用java.lang.ref.SoftReference类来表示。对于软引用关联着的对象，只有在内存不足的时候JVM才会回收该对象。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。</p>\n<ul>\n<li>浏览器网页缓存实例：<br><img src=\"/../images/20160515P2.jpg\" alt=\"软引用 截图\"></li>\n<li>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</li>\n</ul>\n<blockquote>\n<p><strong>弱引用</strong></p>\n</blockquote>\n<p>与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</p>\n<blockquote>\n<p>如果这个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 Weak Reference<br>来记住此对象。</p>\n</blockquote>\n<ul>\n<li>弱引用实例：<br><img src=\"/../images/20160515P3.jpg\" alt=\"弱引用 截图\"></li>\n</ul>\n<blockquote>\n<p><strong>虚引用</strong>也称为幻影引用：一个对象是都有虚引用的存在都不会对生存时间都构成影响，也无法通过虚引用来获取对一个对象的真实引用。唯一的用处：能在对象被GC时收到系统通知，JAVA中用PhantomReference来实现虚引用。</p>\n</blockquote>\n<h3 id=\"2-对比不同\"><a href=\"#2-对比不同\" class=\"headerlink\" title=\"2. 对比不同\"></a>2. 对比不同</h3><table>\n<thead>\n<tr>\n<th align=\"center\">引用类型</th>\n<th align=\"center\">GC回收时间</th>\n<th align=\"center\">用途</th>\n<th align=\"center\">生存时间</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">强引用</td>\n<td align=\"center\">never</td>\n<td align=\"center\">对象的一般状态</td>\n<td align=\"center\">JVM停止运行时</td>\n</tr>\n<tr>\n<td align=\"center\">软引用</td>\n<td align=\"center\">内存不足时</td>\n<td align=\"center\">对象缓存</td>\n<td align=\"center\">内存不足时终止</td>\n</tr>\n<tr>\n<td align=\"center\">弱引用</td>\n<td align=\"center\">GC时</td>\n<td align=\"center\">对象缓存</td>\n<td align=\"center\">GC后终止</td>\n</tr>\n<tr>\n<td align=\"center\">虚引用</td>\n<td align=\"center\">unknow</td>\n<td align=\"center\">unknow</td>\n<td align=\"center\">unknow</td>\n</tr>\n</tbody></table>\n","more":"<p>在JAVA垃圾回收，内存分配过程中，经常会涉及对象的生命周期，而判定对象是否存货都与“引用”有关。Java中的引用的定义非常简单粗糙：如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就表示该内存块存在一个引用。这样分类会将对讲划分成两个类别：有引用、无引用。我们希望能够根据GC回收时间来对对象引用进行划分：当内存空间足够时，对象的引用继续保持；当内存不够时，抛弃这些对象。</p>\n<h3 id=\"1-概念解释\"><a href=\"#1-概念解释\" class=\"headerlink\" title=\"1. 概念解释\"></a>1. 概念解释</h3><blockquote>\n<p><strong>强引用</strong>是使用最普遍的引用：Object o&#x3D;new Object(); 特点：不会被GC</p>\n</blockquote>\n<ul>\n<li>将对象的引用显示地置为null：o&#x3D;null; &#x2F;&#x2F; 帮助垃圾收集器回收此对象</li>\n<li>举例ArrayList的实现源代码：<br><img src=\"/../images/20160515P1.jpg\" alt=\"强引用 截图\"></li>\n</ul>\n<blockquote>\n<p><strong>软引用</strong></p>\n</blockquote>\n<p>用来描述一些还有用但是并非必须的对象，在Java中用java.lang.ref.SoftReference类来表示。对于软引用关联着的对象，只有在内存不足的时候JVM才会回收该对象。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。</p>\n<ul>\n<li>浏览器网页缓存实例：<br><img src=\"/../images/20160515P2.jpg\" alt=\"软引用 截图\"></li>\n<li>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</li>\n</ul>\n<blockquote>\n<p><strong>弱引用</strong></p>\n</blockquote>\n<p>与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</p>\n<blockquote>\n<p>如果这个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 Weak Reference<br>来记住此对象。</p>\n</blockquote>\n<ul>\n<li>弱引用实例：<br><img src=\"/../images/20160515P3.jpg\" alt=\"弱引用 截图\"></li>\n</ul>\n<blockquote>\n<p><strong>虚引用</strong>也称为幻影引用：一个对象是都有虚引用的存在都不会对生存时间都构成影响，也无法通过虚引用来获取对一个对象的真实引用。唯一的用处：能在对象被GC时收到系统通知，JAVA中用PhantomReference来实现虚引用。</p>\n</blockquote>\n<h3 id=\"2-对比不同\"><a href=\"#2-对比不同\" class=\"headerlink\" title=\"2. 对比不同\"></a>2. 对比不同</h3><table>\n<thead>\n<tr>\n<th align=\"center\">引用类型</th>\n<th align=\"center\">GC回收时间</th>\n<th align=\"center\">用途</th>\n<th align=\"center\">生存时间</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">强引用</td>\n<td align=\"center\">never</td>\n<td align=\"center\">对象的一般状态</td>\n<td align=\"center\">JVM停止运行时</td>\n</tr>\n<tr>\n<td align=\"center\">软引用</td>\n<td align=\"center\">内存不足时</td>\n<td align=\"center\">对象缓存</td>\n<td align=\"center\">内存不足时终止</td>\n</tr>\n<tr>\n<td align=\"center\">弱引用</td>\n<td align=\"center\">GC时</td>\n<td align=\"center\">对象缓存</td>\n<td align=\"center\">GC后终止</td>\n</tr>\n<tr>\n<td align=\"center\">虚引用</td>\n<td align=\"center\">unknow</td>\n<td align=\"center\">unknow</td>\n<td align=\"center\">unknow</td>\n</tr>\n</tbody></table>\n"},{"title":"JAVA面试总结","date":"2017-05-17T09:28:00.000Z","_content":"\n# 关于业务\n----------------\n\n### 自我介绍\n\n1. 准备1-2个重点项目，简单描述项目内容 & 自己负责的模块，遇到的技术难点 &\n   是如何解决的。常见的技术难点：并发问题、分布式系统一致性问题、接口幂等问题、OOM分析、redis缓存etc.\n2. 自己所负责项目的各项业务的指标。例如，存量数据量级、QPS、团单成交量、公司的营业额之类的也可以关注一下，会被问到。\n3. 注意点：一定要对简历上写的业务非常熟悉。面试官会对某个业务细节内容进行深入询问，也会设置某些场景要求给出解决方案。\n\n# 关于技术\n----------------\n\n### 自我介绍\n\n1. 自我介绍的时候可以介绍下自己比较熟悉的技术内容，从而引导面试官对自己擅长的技术进行深入提问。（e.g.我JAVA基础扎实，对JVM原理有一定的了解，熟悉Spring,ibatis等开源框架;\n   熟练使用面向对象设计原则，掌握设计模式及应用场景; 熟练使用底层中间件、分布式技术(包括缓存、消息系统等)\n   ，并对原理有一定的了解; ）\n\n### 被提问过的技术内容总结\n\n> **`Java语言基础`**，各种数据结构(Linklist, ArrayList, HashMap, TreeMap etc) 。其中，hashmap是提问频率最高的，几乎一定会被问到：\n\n- Hashmap是基于什么数据结构实现的「数组+链表」\n- Hashmap和hashtable的区别是什么「多线程问题，concurrenthashmap」\n- Hashmap默认大小是多少？什么时候会resize？\n\n----------------\n\n> **`多线程相关`**\n>\n。主要掌握Executor创建线程池时的各种参数，各种BlockingQueue的区别以及适用场景。参考链接：http://www.infoq.com/cn/articles/java-threadPool\n\n----------------\n\n> **`SQL优化`**主要会问一些跟索引相关的内容：\n\n- 聚集索引&非聚集索引：http://www.cnblogs.com/AK2012/archive/2013/01/04/2844283.html\n- 索引实战，索引设计问题e：\n  http://blog.csdn.net/gprime/article/details/1687930\n\n----------------\n\n> **`JVM相关`**(JVM内存模型;ClassLoder机制;GC场景+机制;JVM编译优化)\n\n- 参考书：《深入理解Java虚拟机 》\n- java类加载器参考链接：https://www.ibm.com/developerworks/cn/java/j-lo-classloader/\n- GC参考链接：http://blog.csdn.net/z69183787/article/details/51131629\n\n----------------\n\n> **`各种中间件`**\n>1. **`RPC服务框架`**（同步阻塞/同步非阻塞/异步非阻塞；BIO；NIO；NIO的4种调用方式、实现方式selector）\n\n- 点评pigeon资料：http://ppt.geekbang.org/slide/show/424\n- 主流框架结构：https://wiki.sankuai.com/pages/viewpage.action?pageId=725008629\n- 序列化的方式（PB、Hession、thrift、java serializable序列化对象大小，序列化，反序列化时间的比较）\n- Netty是怎么实现RPC的\n\n> 2. **`消息中间件`**：Swallow kafka\n\n- 如何实现系统解耦；\n- 如何实现业务操作 和 消息发送的一致性；\n- 如何解决消息中间件与使用者的强依赖问题；\n- JMS消息模型\n\n> 3. **`KV中间件squirrel`**（需要了解redis的知识）\n\n- 缓存穿透，缓存击穿，缓存雪崩解决方案分析http://blog.csdn.net/zeb_perfect/article/details/54135506\n-\n\n点评的squirrel：https://wiki.sankuai.com/pages/viewpage.action?pageId=610280467&preview=%2F610280467%2F610280452%2FSquirrel%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB.pptx\n\n- redis常见面试题`**：http://blog.csdn.net/guchuanyun111/article/details/52064870\n\n> 4. **`zebra`**数据库中间件\n\n- 垂直、水平拆分数据库；\n- 数据库分布式事务（重点）：ACID、CAP理论、二段式提交，三段式提交一致性Hash，Paxos算法\n- 数据层访问的流程\n- ORM框架之间的比较\n\n> 5. **`提问低频的一些中间件`**：监控平台CAT、HTTP层 SLB、HLB、统一任务调度平台Crane\n     （需要稍作了解，比如cat监控平台有哪些参数，分别是什么作用；比如CAT是如何实现服务调用链路的监控，阿里是在接口上打注解，用AOP实现的）\n\n----------------\n\n> **`Spring相关`**：\n\n1. **`AOP实现原理`**（JDK动态代理）\n   延伸：JDK动态代理是怎么实现的？（反射http:\n   //rejoy.iteye.com/blog/1627405）、JDK动态代理跟CGlib有什么区别（JDK动态代理只能代理接口）、JDK动态代理跟CGlib的效率哪个比较高？为什么？\n2. **`IOC原理`**\n\n----------------\n\n> **`无规律可循的被提问到的内容：`**\n\n1. **`SSO登录原理`**：\n   参考链接：https://wiki.sankuai.com/pages/viewpage.action?pageId=737929535\n2. **`权限系统的设计原理`**\n3. **`你知道哪些设计模式，有哪些是在工作中用到的？如何实现一个简单的单例、Spring多例怎么实现（@Scope注解）`**\n4.\n    *\n*`算法题目「参考校招面试，只要基础不差就可以，不用特意准备」（如何实现一个String的字母倒转、多个String模式匹配、信号量是什么，java中是哪个包实现的、汉诺塔问题）`\n**\n\n----------------\n\n#### 最后的面试官的提问\n\n> ###### 1.你平时关注哪些技术网站（InfoQ、segmentfault、github…）\n>###### 2.你对自己未来的职业发展有什么看法\n>###### 3.你有什么问题想问我的吗\n","source":"_posts/java面试总结.md","raw":"---\ntitle: JAVA面试总结\ndate: 2017.05.17 17:28:00\ncategory: 经验\ntags:\n  - 面试\n---\n\n# 关于业务\n----------------\n\n### 自我介绍\n\n1. 准备1-2个重点项目，简单描述项目内容 & 自己负责的模块，遇到的技术难点 &\n   是如何解决的。常见的技术难点：并发问题、分布式系统一致性问题、接口幂等问题、OOM分析、redis缓存etc.\n2. 自己所负责项目的各项业务的指标。例如，存量数据量级、QPS、团单成交量、公司的营业额之类的也可以关注一下，会被问到。\n3. 注意点：一定要对简历上写的业务非常熟悉。面试官会对某个业务细节内容进行深入询问，也会设置某些场景要求给出解决方案。\n\n# 关于技术\n----------------\n\n### 自我介绍\n\n1. 自我介绍的时候可以介绍下自己比较熟悉的技术内容，从而引导面试官对自己擅长的技术进行深入提问。（e.g.我JAVA基础扎实，对JVM原理有一定的了解，熟悉Spring,ibatis等开源框架;\n   熟练使用面向对象设计原则，掌握设计模式及应用场景; 熟练使用底层中间件、分布式技术(包括缓存、消息系统等)\n   ，并对原理有一定的了解; ）\n\n### 被提问过的技术内容总结\n\n> **`Java语言基础`**，各种数据结构(Linklist, ArrayList, HashMap, TreeMap etc) 。其中，hashmap是提问频率最高的，几乎一定会被问到：\n\n- Hashmap是基于什么数据结构实现的「数组+链表」\n- Hashmap和hashtable的区别是什么「多线程问题，concurrenthashmap」\n- Hashmap默认大小是多少？什么时候会resize？\n\n----------------\n\n> **`多线程相关`**\n>\n。主要掌握Executor创建线程池时的各种参数，各种BlockingQueue的区别以及适用场景。参考链接：http://www.infoq.com/cn/articles/java-threadPool\n\n----------------\n\n> **`SQL优化`**主要会问一些跟索引相关的内容：\n\n- 聚集索引&非聚集索引：http://www.cnblogs.com/AK2012/archive/2013/01/04/2844283.html\n- 索引实战，索引设计问题e：\n  http://blog.csdn.net/gprime/article/details/1687930\n\n----------------\n\n> **`JVM相关`**(JVM内存模型;ClassLoder机制;GC场景+机制;JVM编译优化)\n\n- 参考书：《深入理解Java虚拟机 》\n- java类加载器参考链接：https://www.ibm.com/developerworks/cn/java/j-lo-classloader/\n- GC参考链接：http://blog.csdn.net/z69183787/article/details/51131629\n\n----------------\n\n> **`各种中间件`**\n>1. **`RPC服务框架`**（同步阻塞/同步非阻塞/异步非阻塞；BIO；NIO；NIO的4种调用方式、实现方式selector）\n\n- 点评pigeon资料：http://ppt.geekbang.org/slide/show/424\n- 主流框架结构：https://wiki.sankuai.com/pages/viewpage.action?pageId=725008629\n- 序列化的方式（PB、Hession、thrift、java serializable序列化对象大小，序列化，反序列化时间的比较）\n- Netty是怎么实现RPC的\n\n> 2. **`消息中间件`**：Swallow kafka\n\n- 如何实现系统解耦；\n- 如何实现业务操作 和 消息发送的一致性；\n- 如何解决消息中间件与使用者的强依赖问题；\n- JMS消息模型\n\n> 3. **`KV中间件squirrel`**（需要了解redis的知识）\n\n- 缓存穿透，缓存击穿，缓存雪崩解决方案分析http://blog.csdn.net/zeb_perfect/article/details/54135506\n-\n\n点评的squirrel：https://wiki.sankuai.com/pages/viewpage.action?pageId=610280467&preview=%2F610280467%2F610280452%2FSquirrel%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB.pptx\n\n- redis常见面试题`**：http://blog.csdn.net/guchuanyun111/article/details/52064870\n\n> 4. **`zebra`**数据库中间件\n\n- 垂直、水平拆分数据库；\n- 数据库分布式事务（重点）：ACID、CAP理论、二段式提交，三段式提交一致性Hash，Paxos算法\n- 数据层访问的流程\n- ORM框架之间的比较\n\n> 5. **`提问低频的一些中间件`**：监控平台CAT、HTTP层 SLB、HLB、统一任务调度平台Crane\n     （需要稍作了解，比如cat监控平台有哪些参数，分别是什么作用；比如CAT是如何实现服务调用链路的监控，阿里是在接口上打注解，用AOP实现的）\n\n----------------\n\n> **`Spring相关`**：\n\n1. **`AOP实现原理`**（JDK动态代理）\n   延伸：JDK动态代理是怎么实现的？（反射http:\n   //rejoy.iteye.com/blog/1627405）、JDK动态代理跟CGlib有什么区别（JDK动态代理只能代理接口）、JDK动态代理跟CGlib的效率哪个比较高？为什么？\n2. **`IOC原理`**\n\n----------------\n\n> **`无规律可循的被提问到的内容：`**\n\n1. **`SSO登录原理`**：\n   参考链接：https://wiki.sankuai.com/pages/viewpage.action?pageId=737929535\n2. **`权限系统的设计原理`**\n3. **`你知道哪些设计模式，有哪些是在工作中用到的？如何实现一个简单的单例、Spring多例怎么实现（@Scope注解）`**\n4.\n    *\n*`算法题目「参考校招面试，只要基础不差就可以，不用特意准备」（如何实现一个String的字母倒转、多个String模式匹配、信号量是什么，java中是哪个包实现的、汉诺塔问题）`\n**\n\n----------------\n\n#### 最后的面试官的提问\n\n> ###### 1.你平时关注哪些技术网站（InfoQ、segmentfault、github…）\n>###### 2.你对自己未来的职业发展有什么看法\n>###### 3.你有什么问题想问我的吗\n","slug":"java面试总结","published":1,"updated":"2024-11-27T03:09:53.019Z","_id":"cm3zaz9c3000atgu6dw5feo6e","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"关于业务\"><a href=\"#关于业务\" class=\"headerlink\" title=\"关于业务\"></a>关于业务</h1><hr>\n<h3 id=\"自我介绍\"><a href=\"#自我介绍\" class=\"headerlink\" title=\"自我介绍\"></a>自我介绍</h3><ol>\n<li>准备1-2个重点项目，简单描述项目内容 &amp; 自己负责的模块，遇到的技术难点 &amp;<br>是如何解决的。常见的技术难点：并发问题、分布式系统一致性问题、接口幂等问题、OOM分析、redis缓存etc.</li>\n<li>自己所负责项目的各项业务的指标。例如，存量数据量级、QPS、团单成交量、公司的营业额之类的也可以关注一下，会被问到。</li>\n<li>注意点：一定要对简历上写的业务非常熟悉。面试官会对某个业务细节内容进行深入询问，也会设置某些场景要求给出解决方案。</li>\n</ol>\n<h1 id=\"关于技术\"><a href=\"#关于技术\" class=\"headerlink\" title=\"关于技术\"></a>关于技术</h1><hr>\n<h3 id=\"自我介绍-1\"><a href=\"#自我介绍-1\" class=\"headerlink\" title=\"自我介绍\"></a>自我介绍</h3><ol>\n<li>自我介绍的时候可以介绍下自己比较熟悉的技术内容，从而引导面试官对自己擅长的技术进行深入提问。（e.g.我JAVA基础扎实，对JVM原理有一定的了解，熟悉Spring,ibatis等开源框架;<br>熟练使用面向对象设计原则，掌握设计模式及应用场景; 熟练使用底层中间件、分布式技术(包括缓存、消息系统等)<br>，并对原理有一定的了解; ）</li>\n</ol>\n<h3 id=\"被提问过的技术内容总结\"><a href=\"#被提问过的技术内容总结\" class=\"headerlink\" title=\"被提问过的技术内容总结\"></a>被提问过的技术内容总结</h3><blockquote>\n<p>**<code>Java语言基础</code>**，各种数据结构(Linklist, ArrayList, HashMap, TreeMap etc) 。其中，hashmap是提问频率最高的，几乎一定会被问到：</p>\n</blockquote>\n<ul>\n<li>Hashmap是基于什么数据结构实现的「数组+链表」</li>\n<li>Hashmap和hashtable的区别是什么「多线程问题，concurrenthashmap」</li>\n<li>Hashmap默认大小是多少？什么时候会resize？</li>\n</ul>\n<hr>\n<blockquote>\n<p><strong><code>多线程相关</code></strong></p>\n</blockquote>\n<p>。主要掌握Executor创建线程池时的各种参数，各种BlockingQueue的区别以及适用场景。参考链接：<a href=\"http://www.infoq.com/cn/articles/java-threadPool\">http://www.infoq.com/cn/articles/java-threadPool</a></p>\n<hr>\n<blockquote>\n<p>**<code>SQL优化</code>**主要会问一些跟索引相关的内容：</p>\n</blockquote>\n<ul>\n<li>聚集索引&amp;非聚集索引：<a href=\"http://www.cnblogs.com/AK2012/archive/2013/01/04/2844283.html\">http://www.cnblogs.com/AK2012/archive/2013/01/04/2844283.html</a></li>\n<li>索引实战，索引设计问题e：<br><a href=\"http://blog.csdn.net/gprime/article/details/1687930\">http://blog.csdn.net/gprime/article/details/1687930</a></li>\n</ul>\n<hr>\n<blockquote>\n<p><strong><code>JVM相关</code></strong>(JVM内存模型;ClassLoder机制;GC场景+机制;JVM编译优化)</p>\n</blockquote>\n<ul>\n<li>参考书：《深入理解Java虚拟机 》</li>\n<li>java类加载器参考链接：<a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-classloader/\">https://www.ibm.com/developerworks/cn/java/j-lo-classloader/</a></li>\n<li>GC参考链接：<a href=\"http://blog.csdn.net/z69183787/article/details/51131629\">http://blog.csdn.net/z69183787/article/details/51131629</a></li>\n</ul>\n<hr>\n<blockquote>\n<p><strong><code>各种中间件</code></strong></p>\n<ol>\n<li>**<code>RPC服务框架</code>**（同步阻塞&#x2F;同步非阻塞&#x2F;异步非阻塞；BIO；NIO；NIO的4种调用方式、实现方式selector）</li>\n</ol>\n</blockquote>\n<ul>\n<li>点评pigeon资料：<a href=\"http://ppt.geekbang.org/slide/show/424\">http://ppt.geekbang.org/slide/show/424</a></li>\n<li>主流框架结构：<a href=\"https://wiki.sankuai.com/pages/viewpage.action?pageId=725008629\">https://wiki.sankuai.com/pages/viewpage.action?pageId=725008629</a></li>\n<li>序列化的方式（PB、Hession、thrift、java serializable序列化对象大小，序列化，反序列化时间的比较）</li>\n<li>Netty是怎么实现RPC的</li>\n</ul>\n<blockquote>\n<ol start=\"2\">\n<li>**<code>消息中间件</code>**：Swallow kafka</li>\n</ol>\n</blockquote>\n<ul>\n<li>如何实现系统解耦；</li>\n<li>如何实现业务操作 和 消息发送的一致性；</li>\n<li>如何解决消息中间件与使用者的强依赖问题；</li>\n<li>JMS消息模型</li>\n</ul>\n<blockquote>\n<ol start=\"3\">\n<li>**<code>KV中间件squirrel</code>**（需要了解redis的知识）</li>\n</ol>\n</blockquote>\n<ul>\n<li>缓存穿透，缓存击穿，缓存雪崩解决方案分析<a href=\"http://blog.csdn.net/zeb_perfect/article/details/54135506\">http://blog.csdn.net/zeb_perfect/article/details/54135506</a></li>\n<li></li>\n</ul>\n<p>点评的squirrel：<a href=\"https://wiki.sankuai.com/pages/viewpage.action?pageId=610280467&preview=/610280467/610280452/Squirrel%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB.pptx\">https://wiki.sankuai.com/pages/viewpage.action?pageId=610280467&amp;preview=%2F610280467%2F610280452%2FSquirrel%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB.pptx</a></p>\n<ul>\n<li>redis常见面试题&#96;**：<a href=\"http://blog.csdn.net/guchuanyun111/article/details/52064870\">http://blog.csdn.net/guchuanyun111/article/details/52064870</a></li>\n</ul>\n<blockquote>\n<ol start=\"4\">\n<li>**<code>zebra</code>**数据库中间件</li>\n</ol>\n</blockquote>\n<ul>\n<li>垂直、水平拆分数据库；</li>\n<li>数据库分布式事务（重点）：ACID、CAP理论、二段式提交，三段式提交一致性Hash，Paxos算法</li>\n<li>数据层访问的流程</li>\n<li>ORM框架之间的比较</li>\n</ul>\n<blockquote>\n<ol start=\"5\">\n<li>**<code>提问低频的一些中间件</code>**：监控平台CAT、HTTP层 SLB、HLB、统一任务调度平台Crane<br>  （需要稍作了解，比如cat监控平台有哪些参数，分别是什么作用；比如CAT是如何实现服务调用链路的监控，阿里是在接口上打注解，用AOP实现的）</li>\n</ol>\n</blockquote>\n<hr>\n<blockquote>\n<p>**<code>Spring相关</code>**：</p>\n</blockquote>\n<ol>\n<li>**<code>AOP实现原理</code>**（JDK动态代理）<br>延伸：JDK动态代理是怎么实现的？（反射http:<br>&#x2F;&#x2F;rejoy.iteye.com&#x2F;blog&#x2F;1627405）、JDK动态代理跟CGlib有什么区别（JDK动态代理只能代理接口）、JDK动态代理跟CGlib的效率哪个比较高？为什么？</li>\n<li><strong><code>IOC原理</code></strong></li>\n</ol>\n<hr>\n<blockquote>\n<p><strong><code>无规律可循的被提问到的内容：</code></strong></p>\n</blockquote>\n<ol>\n<li>**<code>SSO登录原理</code>**：<br>参考链接：<a href=\"https://wiki.sankuai.com/pages/viewpage.action?pageId=737929535\">https://wiki.sankuai.com/pages/viewpage.action?pageId=737929535</a></li>\n<li><strong><code>权限系统的设计原理</code></strong></li>\n<li><strong><code>你知道哪些设计模式，有哪些是在工作中用到的？如何实现一个简单的单例、Spring多例怎么实现（@Scope注解）</code></strong></li>\n<li><ul>\n<li>*<code>算法题目「参考校招面试，只要基础不差就可以，不用特意准备」（如何实现一个String的字母倒转、多个String模式匹配、信号量是什么，java中是哪个包实现的、汉诺塔问题）</code><br>**</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h4 id=\"最后的面试官的提问\"><a href=\"#最后的面试官的提问\" class=\"headerlink\" title=\"最后的面试官的提问\"></a>最后的面试官的提问</h4><blockquote>\n<h6 id=\"1-你平时关注哪些技术网站（InfoQ、segmentfault、github…）\"><a href=\"#1-你平时关注哪些技术网站（InfoQ、segmentfault、github…）\" class=\"headerlink\" title=\"1.你平时关注哪些技术网站（InfoQ、segmentfault、github…）\"></a>1.你平时关注哪些技术网站（InfoQ、segmentfault、github…）</h6><h6 id=\"2-你对自己未来的职业发展有什么看法\"><a href=\"#2-你对自己未来的职业发展有什么看法\" class=\"headerlink\" title=\"2.你对自己未来的职业发展有什么看法\"></a>2.你对自己未来的职业发展有什么看法</h6><h6 id=\"3-你有什么问题想问我的吗\"><a href=\"#3-你有什么问题想问我的吗\" class=\"headerlink\" title=\"3.你有什么问题想问我的吗\"></a>3.你有什么问题想问我的吗</h6></blockquote>\n","excerpt":"","more":"<h1 id=\"关于业务\"><a href=\"#关于业务\" class=\"headerlink\" title=\"关于业务\"></a>关于业务</h1><hr>\n<h3 id=\"自我介绍\"><a href=\"#自我介绍\" class=\"headerlink\" title=\"自我介绍\"></a>自我介绍</h3><ol>\n<li>准备1-2个重点项目，简单描述项目内容 &amp; 自己负责的模块，遇到的技术难点 &amp;<br>是如何解决的。常见的技术难点：并发问题、分布式系统一致性问题、接口幂等问题、OOM分析、redis缓存etc.</li>\n<li>自己所负责项目的各项业务的指标。例如，存量数据量级、QPS、团单成交量、公司的营业额之类的也可以关注一下，会被问到。</li>\n<li>注意点：一定要对简历上写的业务非常熟悉。面试官会对某个业务细节内容进行深入询问，也会设置某些场景要求给出解决方案。</li>\n</ol>\n<h1 id=\"关于技术\"><a href=\"#关于技术\" class=\"headerlink\" title=\"关于技术\"></a>关于技术</h1><hr>\n<h3 id=\"自我介绍-1\"><a href=\"#自我介绍-1\" class=\"headerlink\" title=\"自我介绍\"></a>自我介绍</h3><ol>\n<li>自我介绍的时候可以介绍下自己比较熟悉的技术内容，从而引导面试官对自己擅长的技术进行深入提问。（e.g.我JAVA基础扎实，对JVM原理有一定的了解，熟悉Spring,ibatis等开源框架;<br>熟练使用面向对象设计原则，掌握设计模式及应用场景; 熟练使用底层中间件、分布式技术(包括缓存、消息系统等)<br>，并对原理有一定的了解; ）</li>\n</ol>\n<h3 id=\"被提问过的技术内容总结\"><a href=\"#被提问过的技术内容总结\" class=\"headerlink\" title=\"被提问过的技术内容总结\"></a>被提问过的技术内容总结</h3><blockquote>\n<p>**<code>Java语言基础</code>**，各种数据结构(Linklist, ArrayList, HashMap, TreeMap etc) 。其中，hashmap是提问频率最高的，几乎一定会被问到：</p>\n</blockquote>\n<ul>\n<li>Hashmap是基于什么数据结构实现的「数组+链表」</li>\n<li>Hashmap和hashtable的区别是什么「多线程问题，concurrenthashmap」</li>\n<li>Hashmap默认大小是多少？什么时候会resize？</li>\n</ul>\n<hr>\n<blockquote>\n<p><strong><code>多线程相关</code></strong></p>\n</blockquote>\n<p>。主要掌握Executor创建线程池时的各种参数，各种BlockingQueue的区别以及适用场景。参考链接：<a href=\"http://www.infoq.com/cn/articles/java-threadPool\">http://www.infoq.com/cn/articles/java-threadPool</a></p>\n<hr>\n<blockquote>\n<p>**<code>SQL优化</code>**主要会问一些跟索引相关的内容：</p>\n</blockquote>\n<ul>\n<li>聚集索引&amp;非聚集索引：<a href=\"http://www.cnblogs.com/AK2012/archive/2013/01/04/2844283.html\">http://www.cnblogs.com/AK2012/archive/2013/01/04/2844283.html</a></li>\n<li>索引实战，索引设计问题e：<br><a href=\"http://blog.csdn.net/gprime/article/details/1687930\">http://blog.csdn.net/gprime/article/details/1687930</a></li>\n</ul>\n<hr>\n<blockquote>\n<p><strong><code>JVM相关</code></strong>(JVM内存模型;ClassLoder机制;GC场景+机制;JVM编译优化)</p>\n</blockquote>\n<ul>\n<li>参考书：《深入理解Java虚拟机 》</li>\n<li>java类加载器参考链接：<a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-classloader/\">https://www.ibm.com/developerworks/cn/java/j-lo-classloader/</a></li>\n<li>GC参考链接：<a href=\"http://blog.csdn.net/z69183787/article/details/51131629\">http://blog.csdn.net/z69183787/article/details/51131629</a></li>\n</ul>\n<hr>\n<blockquote>\n<p><strong><code>各种中间件</code></strong></p>\n<ol>\n<li>**<code>RPC服务框架</code>**（同步阻塞&#x2F;同步非阻塞&#x2F;异步非阻塞；BIO；NIO；NIO的4种调用方式、实现方式selector）</li>\n</ol>\n</blockquote>\n<ul>\n<li>点评pigeon资料：<a href=\"http://ppt.geekbang.org/slide/show/424\">http://ppt.geekbang.org/slide/show/424</a></li>\n<li>主流框架结构：<a href=\"https://wiki.sankuai.com/pages/viewpage.action?pageId=725008629\">https://wiki.sankuai.com/pages/viewpage.action?pageId=725008629</a></li>\n<li>序列化的方式（PB、Hession、thrift、java serializable序列化对象大小，序列化，反序列化时间的比较）</li>\n<li>Netty是怎么实现RPC的</li>\n</ul>\n<blockquote>\n<ol start=\"2\">\n<li>**<code>消息中间件</code>**：Swallow kafka</li>\n</ol>\n</blockquote>\n<ul>\n<li>如何实现系统解耦；</li>\n<li>如何实现业务操作 和 消息发送的一致性；</li>\n<li>如何解决消息中间件与使用者的强依赖问题；</li>\n<li>JMS消息模型</li>\n</ul>\n<blockquote>\n<ol start=\"3\">\n<li>**<code>KV中间件squirrel</code>**（需要了解redis的知识）</li>\n</ol>\n</blockquote>\n<ul>\n<li>缓存穿透，缓存击穿，缓存雪崩解决方案分析<a href=\"http://blog.csdn.net/zeb_perfect/article/details/54135506\">http://blog.csdn.net/zeb_perfect/article/details/54135506</a></li>\n<li></li>\n</ul>\n<p>点评的squirrel：<a href=\"https://wiki.sankuai.com/pages/viewpage.action?pageId=610280467&preview=/610280467/610280452/Squirrel%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB.pptx\">https://wiki.sankuai.com/pages/viewpage.action?pageId=610280467&amp;preview=%2F610280467%2F610280452%2FSquirrel%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB.pptx</a></p>\n<ul>\n<li>redis常见面试题&#96;**：<a href=\"http://blog.csdn.net/guchuanyun111/article/details/52064870\">http://blog.csdn.net/guchuanyun111/article/details/52064870</a></li>\n</ul>\n<blockquote>\n<ol start=\"4\">\n<li>**<code>zebra</code>**数据库中间件</li>\n</ol>\n</blockquote>\n<ul>\n<li>垂直、水平拆分数据库；</li>\n<li>数据库分布式事务（重点）：ACID、CAP理论、二段式提交，三段式提交一致性Hash，Paxos算法</li>\n<li>数据层访问的流程</li>\n<li>ORM框架之间的比较</li>\n</ul>\n<blockquote>\n<ol start=\"5\">\n<li>**<code>提问低频的一些中间件</code>**：监控平台CAT、HTTP层 SLB、HLB、统一任务调度平台Crane<br>  （需要稍作了解，比如cat监控平台有哪些参数，分别是什么作用；比如CAT是如何实现服务调用链路的监控，阿里是在接口上打注解，用AOP实现的）</li>\n</ol>\n</blockquote>\n<hr>\n<blockquote>\n<p>**<code>Spring相关</code>**：</p>\n</blockquote>\n<ol>\n<li>**<code>AOP实现原理</code>**（JDK动态代理）<br>延伸：JDK动态代理是怎么实现的？（反射http:<br>&#x2F;&#x2F;rejoy.iteye.com&#x2F;blog&#x2F;1627405）、JDK动态代理跟CGlib有什么区别（JDK动态代理只能代理接口）、JDK动态代理跟CGlib的效率哪个比较高？为什么？</li>\n<li><strong><code>IOC原理</code></strong></li>\n</ol>\n<hr>\n<blockquote>\n<p><strong><code>无规律可循的被提问到的内容：</code></strong></p>\n</blockquote>\n<ol>\n<li>**<code>SSO登录原理</code>**：<br>参考链接：<a href=\"https://wiki.sankuai.com/pages/viewpage.action?pageId=737929535\">https://wiki.sankuai.com/pages/viewpage.action?pageId=737929535</a></li>\n<li><strong><code>权限系统的设计原理</code></strong></li>\n<li><strong><code>你知道哪些设计模式，有哪些是在工作中用到的？如何实现一个简单的单例、Spring多例怎么实现（@Scope注解）</code></strong></li>\n<li><ul>\n<li>*<code>算法题目「参考校招面试，只要基础不差就可以，不用特意准备」（如何实现一个String的字母倒转、多个String模式匹配、信号量是什么，java中是哪个包实现的、汉诺塔问题）</code><br>**</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h4 id=\"最后的面试官的提问\"><a href=\"#最后的面试官的提问\" class=\"headerlink\" title=\"最后的面试官的提问\"></a>最后的面试官的提问</h4><blockquote>\n<h6 id=\"1-你平时关注哪些技术网站（InfoQ、segmentfault、github…）\"><a href=\"#1-你平时关注哪些技术网站（InfoQ、segmentfault、github…）\" class=\"headerlink\" title=\"1.你平时关注哪些技术网站（InfoQ、segmentfault、github…）\"></a>1.你平时关注哪些技术网站（InfoQ、segmentfault、github…）</h6><h6 id=\"2-你对自己未来的职业发展有什么看法\"><a href=\"#2-你对自己未来的职业发展有什么看法\" class=\"headerlink\" title=\"2.你对自己未来的职业发展有什么看法\"></a>2.你对自己未来的职业发展有什么看法</h6><h6 id=\"3-你有什么问题想问我的吗\"><a href=\"#3-你有什么问题想问我的吗\" class=\"headerlink\" title=\"3.你有什么问题想问我的吗\"></a>3.你有什么问题想问我的吗</h6></blockquote>\n"},{"title":"join的7种方式","date":"2016-08-02T01:00:00.000Z","_content":"\n# SQL JOIN的7种方式\n----------------\n\n### JOIN在查询时用的非常频繁\n\n1. 常用join方式 ![](../images/mysql/7-join.png)\n\n### left JOIN的的后面能不能带条件\n\n1. 从结果的情况来看\n\n> SELECT * FROM t_user u LEFT JOIN t_user_role ur ON ur.user_id = u.id\n> LEFT JOIN t_role r ON ur.role_id = r.id\n> WHERE u.id=1 AND r.id=1\n\n\t![](../images/mysql/7-join-r1.png)\t\n\n\t>\tSELECT * FROM t_user u   LEFT JOIN t_user_role ur   ON ur.user_id = u.id\n\t\t   AND  ur.user_id=1 LEFT JOIN t_role r   ON ur.role_id = r.id\n\t\t\t\t AND ur.role_id =1\n\n\n\n\t![](../images/mysql/7-join-r2.png)\n\n2. 从使用索引的情况来看\n\n> EXPLAIN SELECT * FROM t_user u LEFT JOIN t_user_role ur ON ur.user_id = u.id\n> LEFT JOIN t_role r ON ur.role_id = r.id\n> WHERE u.id=1 AND r.id=1\n\n\t![](../images/mysql/7-join-r3.png)\t\n\n\t>\tEXPLAIN SELECT * FROM t_user u   LEFT JOIN t_user_role ur   \n\t \t\tON ur.user_id = u.id   AND  ur.user_id=1\n\t\t\t\tLEFT JOIN t_role r   ON ur.role_id = r.id AND ur.role_id =1\n\n\n\n\n\t![](../images/mysql/7-join-r4.png)\n\n3. 结论：\n\n> left join on 后面跟 and 带过滤条件并不能起到过滤作用。而且导致不能使用索引。\n\n","source":"_posts/join的7种方式.md","raw":"---\ntitle: join的7种方式\ndate: 2016-08-02 09:00:00\ncategories: 数据库\ntags:\n  - mysql\n---\n\n# SQL JOIN的7种方式\n----------------\n\n### JOIN在查询时用的非常频繁\n\n1. 常用join方式 ![](../images/mysql/7-join.png)\n\n### left JOIN的的后面能不能带条件\n\n1. 从结果的情况来看\n\n> SELECT * FROM t_user u LEFT JOIN t_user_role ur ON ur.user_id = u.id\n> LEFT JOIN t_role r ON ur.role_id = r.id\n> WHERE u.id=1 AND r.id=1\n\n\t![](../images/mysql/7-join-r1.png)\t\n\n\t>\tSELECT * FROM t_user u   LEFT JOIN t_user_role ur   ON ur.user_id = u.id\n\t\t   AND  ur.user_id=1 LEFT JOIN t_role r   ON ur.role_id = r.id\n\t\t\t\t AND ur.role_id =1\n\n\n\n\t![](../images/mysql/7-join-r2.png)\n\n2. 从使用索引的情况来看\n\n> EXPLAIN SELECT * FROM t_user u LEFT JOIN t_user_role ur ON ur.user_id = u.id\n> LEFT JOIN t_role r ON ur.role_id = r.id\n> WHERE u.id=1 AND r.id=1\n\n\t![](../images/mysql/7-join-r3.png)\t\n\n\t>\tEXPLAIN SELECT * FROM t_user u   LEFT JOIN t_user_role ur   \n\t \t\tON ur.user_id = u.id   AND  ur.user_id=1\n\t\t\t\tLEFT JOIN t_role r   ON ur.role_id = r.id AND ur.role_id =1\n\n\n\n\n\t![](../images/mysql/7-join-r4.png)\n\n3. 结论：\n\n> left join on 后面跟 and 带过滤条件并不能起到过滤作用。而且导致不能使用索引。\n\n","slug":"join的7种方式","published":1,"updated":"2024-11-27T03:20:35.204Z","_id":"cm3zaz9c3000dtgu69arp9t5x","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"SQL-JOIN的7种方式\"><a href=\"#SQL-JOIN的7种方式\" class=\"headerlink\" title=\"SQL JOIN的7种方式\"></a>SQL JOIN的7种方式</h1><hr>\n<h3 id=\"JOIN在查询时用的非常频繁\"><a href=\"#JOIN在查询时用的非常频繁\" class=\"headerlink\" title=\"JOIN在查询时用的非常频繁\"></a>JOIN在查询时用的非常频繁</h3><ol>\n<li>常用join方式 <img src=\"/../images/mysql/7-join.png\"></li>\n</ol>\n<h3 id=\"left-JOIN的的后面能不能带条件\"><a href=\"#left-JOIN的的后面能不能带条件\" class=\"headerlink\" title=\"left JOIN的的后面能不能带条件\"></a>left JOIN的的后面能不能带条件</h3><ol>\n<li>从结果的情况来看</li>\n</ol>\n<blockquote>\n<p>SELECT * FROM t_user u LEFT JOIN t_user_role ur ON ur.user_id &#x3D; u.id<br>LEFT JOIN t_role r ON ur.role_id &#x3D; r.id<br>WHERE u.id&#x3D;1 AND r.id&#x3D;1</p>\n</blockquote>\n<pre><code>![](../images/mysql/7-join-r1.png)\t\n\n&gt;\tSELECT * FROM t_user u   LEFT JOIN t_user_role ur   ON ur.user_id = u.id\n       AND  ur.user_id=1 LEFT JOIN t_role r   ON ur.role_id = r.id\n             AND ur.role_id =1\n\n\n\n![](../images/mysql/7-join-r2.png)\n</code></pre>\n<ol start=\"2\">\n<li>从使用索引的情况来看</li>\n</ol>\n<blockquote>\n<p>EXPLAIN SELECT * FROM t_user u LEFT JOIN t_user_role ur ON ur.user_id &#x3D; u.id<br>LEFT JOIN t_role r ON ur.role_id &#x3D; r.id<br>WHERE u.id&#x3D;1 AND r.id&#x3D;1</p>\n</blockquote>\n<pre><code>![](../images/mysql/7-join-r3.png)\t\n\n&gt;\tEXPLAIN SELECT * FROM t_user u   LEFT JOIN t_user_role ur   \n \t\tON ur.user_id = u.id   AND  ur.user_id=1\n            LEFT JOIN t_role r   ON ur.role_id = r.id AND ur.role_id =1\n\n\n\n\n![](../images/mysql/7-join-r4.png)\n</code></pre>\n<ol start=\"3\">\n<li>结论：</li>\n</ol>\n<blockquote>\n<p>left join on 后面跟 and 带过滤条件并不能起到过滤作用。而且导致不能使用索引。</p>\n</blockquote>\n","excerpt":"","more":"<h1 id=\"SQL-JOIN的7种方式\"><a href=\"#SQL-JOIN的7种方式\" class=\"headerlink\" title=\"SQL JOIN的7种方式\"></a>SQL JOIN的7种方式</h1><hr>\n<h3 id=\"JOIN在查询时用的非常频繁\"><a href=\"#JOIN在查询时用的非常频繁\" class=\"headerlink\" title=\"JOIN在查询时用的非常频繁\"></a>JOIN在查询时用的非常频繁</h3><ol>\n<li>常用join方式 <img src=\"/../images/mysql/7-join.png\"></li>\n</ol>\n<h3 id=\"left-JOIN的的后面能不能带条件\"><a href=\"#left-JOIN的的后面能不能带条件\" class=\"headerlink\" title=\"left JOIN的的后面能不能带条件\"></a>left JOIN的的后面能不能带条件</h3><ol>\n<li>从结果的情况来看</li>\n</ol>\n<blockquote>\n<p>SELECT * FROM t_user u LEFT JOIN t_user_role ur ON ur.user_id &#x3D; u.id<br>LEFT JOIN t_role r ON ur.role_id &#x3D; r.id<br>WHERE u.id&#x3D;1 AND r.id&#x3D;1</p>\n</blockquote>\n<pre><code>![](../images/mysql/7-join-r1.png)\t\n\n&gt;\tSELECT * FROM t_user u   LEFT JOIN t_user_role ur   ON ur.user_id = u.id\n       AND  ur.user_id=1 LEFT JOIN t_role r   ON ur.role_id = r.id\n             AND ur.role_id =1\n\n\n\n![](../images/mysql/7-join-r2.png)\n</code></pre>\n<ol start=\"2\">\n<li>从使用索引的情况来看</li>\n</ol>\n<blockquote>\n<p>EXPLAIN SELECT * FROM t_user u LEFT JOIN t_user_role ur ON ur.user_id &#x3D; u.id<br>LEFT JOIN t_role r ON ur.role_id &#x3D; r.id<br>WHERE u.id&#x3D;1 AND r.id&#x3D;1</p>\n</blockquote>\n<pre><code>![](../images/mysql/7-join-r3.png)\t\n\n&gt;\tEXPLAIN SELECT * FROM t_user u   LEFT JOIN t_user_role ur   \n \t\tON ur.user_id = u.id   AND  ur.user_id=1\n            LEFT JOIN t_role r   ON ur.role_id = r.id AND ur.role_id =1\n\n\n\n\n![](../images/mysql/7-join-r4.png)\n</code></pre>\n<ol start=\"3\">\n<li>结论：</li>\n</ol>\n<blockquote>\n<p>left join on 后面跟 and 带过滤条件并不能起到过滤作用。而且导致不能使用索引。</p>\n</blockquote>\n"},{"title":"jsonp跨域请求","date":"2017-09-16T01:00:00.000Z","_content":"\n## 处理跨域请求\n\n       后台：\n       \n        @RequestMapping(\"/list2.do\")\n    \t@ResponseBody\n    \tpublic Object list2(String callback) {\n    \t\tString str = studentService.getMessage();\n    \t\tJSONObject json = new JSONObject();\n    \t\tjson.put(\"data\", str);\n    \t\tString result=json.toJSONString();\n    \t\t \n    \t\tif(callback!=null && !callback.equals(\"\")){\n    \t\t\tMappingJacksonValue mappingJacksonValue=new MappingJacksonValue(result);\n    \t\t\tmappingJacksonValue.setJsonpFunction(callback);\n    \t\t\treturn mappingJacksonValue;\n    \t\t}else{\n    \t\t\treturn result;\n    \t\t}\n    \t}\n    \t\n    \t@RequestMapping(\"/list3.do\")\n    \t@ResponseBody\n    \tpublic String list3(String callback) {\n    \t\tString str = studentService.getMessage();\n    \t\tJSONObject json = new JSONObject();\n    \t\tjson.put(\"data\", str);\n    \t\tString result=json.toJSONString();\n    \t\t\n    \t\tif(callback!=null && !callback.equals(\"\")){\n    \t\t\treturn callback +\"(\"+result+\")\";\n    \t\t}else{\n    \t\t\treturn result;\n    \t\t}\n    \t\t\n    \t}\n    \t\n    \t前端：\n    \t\n    \t$.ajax({  \n\t        data:'',\n\t        type:\"get\",\n\t        url:\"http://www.xxxx.com/upms/user/list3.do\",\n\t        dataType:'jsonp',\t\t\t\t//声明采用 jsonp\n\t        jsonp:'callback',\t\t\t\t//后台用 callback字符串接收。  jsonpCallback的回调函数callbackFunc的名称\n\t        jsonpCallback:\"callbackFunc\",\t//callbackFunc 回调的方法 可以不要\n\t        success:function(result) {  \n\t           console.info(result);// 成功后携带数据进入。\n\t        },  \n\t        timeout:3000  \n\t    });  \n    \tfunction callbackFunc(datas){}// 空实现  可以不要\n\n## 原理\n\n1. 主要是服务器把返回数据包裹成 js文件内容。 因为js是可以跨域访问的。","source":"_posts/jsonp跨域请求.md","raw":"---\ntitle: jsonp跨域请求\ndate: 2017-09-16 09:00:00\ncategories: AJAX\ntags:\n  - js \n---\n\n## 处理跨域请求\n\n       后台：\n       \n        @RequestMapping(\"/list2.do\")\n    \t@ResponseBody\n    \tpublic Object list2(String callback) {\n    \t\tString str = studentService.getMessage();\n    \t\tJSONObject json = new JSONObject();\n    \t\tjson.put(\"data\", str);\n    \t\tString result=json.toJSONString();\n    \t\t \n    \t\tif(callback!=null && !callback.equals(\"\")){\n    \t\t\tMappingJacksonValue mappingJacksonValue=new MappingJacksonValue(result);\n    \t\t\tmappingJacksonValue.setJsonpFunction(callback);\n    \t\t\treturn mappingJacksonValue;\n    \t\t}else{\n    \t\t\treturn result;\n    \t\t}\n    \t}\n    \t\n    \t@RequestMapping(\"/list3.do\")\n    \t@ResponseBody\n    \tpublic String list3(String callback) {\n    \t\tString str = studentService.getMessage();\n    \t\tJSONObject json = new JSONObject();\n    \t\tjson.put(\"data\", str);\n    \t\tString result=json.toJSONString();\n    \t\t\n    \t\tif(callback!=null && !callback.equals(\"\")){\n    \t\t\treturn callback +\"(\"+result+\")\";\n    \t\t}else{\n    \t\t\treturn result;\n    \t\t}\n    \t\t\n    \t}\n    \t\n    \t前端：\n    \t\n    \t$.ajax({  \n\t        data:'',\n\t        type:\"get\",\n\t        url:\"http://www.xxxx.com/upms/user/list3.do\",\n\t        dataType:'jsonp',\t\t\t\t//声明采用 jsonp\n\t        jsonp:'callback',\t\t\t\t//后台用 callback字符串接收。  jsonpCallback的回调函数callbackFunc的名称\n\t        jsonpCallback:\"callbackFunc\",\t//callbackFunc 回调的方法 可以不要\n\t        success:function(result) {  \n\t           console.info(result);// 成功后携带数据进入。\n\t        },  \n\t        timeout:3000  \n\t    });  \n    \tfunction callbackFunc(datas){}// 空实现  可以不要\n\n## 原理\n\n1. 主要是服务器把返回数据包裹成 js文件内容。 因为js是可以跨域访问的。","slug":"jsonp跨域请求","published":1,"updated":"2024-11-27T03:20:35.276Z","_id":"cm3zaz9c4000gtgu68l73d21l","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"处理跨域请求\"><a href=\"#处理跨域请求\" class=\"headerlink\" title=\"处理跨域请求\"></a>处理跨域请求</h2><pre><code>   后台：\n   \n    @RequestMapping(&quot;/list2.do&quot;)\n    @ResponseBody\n    public Object list2(String callback) &#123;\n        String str = studentService.getMessage();\n        JSONObject json = new JSONObject();\n        json.put(&quot;data&quot;, str);\n        String result=json.toJSONString();\n         \n        if(callback!=null &amp;&amp; !callback.equals(&quot;&quot;))&#123;\n            MappingJacksonValue mappingJacksonValue=new MappingJacksonValue(result);\n            mappingJacksonValue.setJsonpFunction(callback);\n            return mappingJacksonValue;\n        &#125;else&#123;\n            return result;\n        &#125;\n    &#125;\n    \n    @RequestMapping(&quot;/list3.do&quot;)\n    @ResponseBody\n    public String list3(String callback) &#123;\n        String str = studentService.getMessage();\n        JSONObject json = new JSONObject();\n        json.put(&quot;data&quot;, str);\n        String result=json.toJSONString();\n        \n        if(callback!=null &amp;&amp; !callback.equals(&quot;&quot;))&#123;\n            return callback +&quot;(&quot;+result+&quot;)&quot;;\n        &#125;else&#123;\n            return result;\n        &#125;\n        \n    &#125;\n    \n    前端：\n    \n    $.ajax(&#123;  \n        data:&#39;&#39;,\n        type:&quot;get&quot;,\n        url:&quot;http://www.xxxx.com/upms/user/list3.do&quot;,\n        dataType:&#39;jsonp&#39;,\t\t\t\t//声明采用 jsonp\n        jsonp:&#39;callback&#39;,\t\t\t\t//后台用 callback字符串接收。  jsonpCallback的回调函数callbackFunc的名称\n        jsonpCallback:&quot;callbackFunc&quot;,\t//callbackFunc 回调的方法 可以不要\n        success:function(result) &#123;  \n           console.info(result);// 成功后携带数据进入。\n        &#125;,  \n        timeout:3000  \n    &#125;);  \n    function callbackFunc(datas)&#123;&#125;// 空实现  可以不要\n</code></pre>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><ol>\n<li>主要是服务器把返回数据包裹成 js文件内容。 因为js是可以跨域访问的。</li>\n</ol>\n","excerpt":"","more":"<h2 id=\"处理跨域请求\"><a href=\"#处理跨域请求\" class=\"headerlink\" title=\"处理跨域请求\"></a>处理跨域请求</h2><pre><code>   后台：\n   \n    @RequestMapping(&quot;/list2.do&quot;)\n    @ResponseBody\n    public Object list2(String callback) &#123;\n        String str = studentService.getMessage();\n        JSONObject json = new JSONObject();\n        json.put(&quot;data&quot;, str);\n        String result=json.toJSONString();\n         \n        if(callback!=null &amp;&amp; !callback.equals(&quot;&quot;))&#123;\n            MappingJacksonValue mappingJacksonValue=new MappingJacksonValue(result);\n            mappingJacksonValue.setJsonpFunction(callback);\n            return mappingJacksonValue;\n        &#125;else&#123;\n            return result;\n        &#125;\n    &#125;\n    \n    @RequestMapping(&quot;/list3.do&quot;)\n    @ResponseBody\n    public String list3(String callback) &#123;\n        String str = studentService.getMessage();\n        JSONObject json = new JSONObject();\n        json.put(&quot;data&quot;, str);\n        String result=json.toJSONString();\n        \n        if(callback!=null &amp;&amp; !callback.equals(&quot;&quot;))&#123;\n            return callback +&quot;(&quot;+result+&quot;)&quot;;\n        &#125;else&#123;\n            return result;\n        &#125;\n        \n    &#125;\n    \n    前端：\n    \n    $.ajax(&#123;  \n        data:&#39;&#39;,\n        type:&quot;get&quot;,\n        url:&quot;http://www.xxxx.com/upms/user/list3.do&quot;,\n        dataType:&#39;jsonp&#39;,\t\t\t\t//声明采用 jsonp\n        jsonp:&#39;callback&#39;,\t\t\t\t//后台用 callback字符串接收。  jsonpCallback的回调函数callbackFunc的名称\n        jsonpCallback:&quot;callbackFunc&quot;,\t//callbackFunc 回调的方法 可以不要\n        success:function(result) &#123;  \n           console.info(result);// 成功后携带数据进入。\n        &#125;,  \n        timeout:3000  \n    &#125;);  \n    function callbackFunc(datas)&#123;&#125;// 空实现  可以不要\n</code></pre>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><ol>\n<li>主要是服务器把返回数据包裹成 js文件内容。 因为js是可以跨域访问的。</li>\n</ol>\n"},{"title":"java多线程的一些总结","date":"2017-07-24T01:00:00.000Z","_content":"\n# 1.java线程创建方式\n----------------\n\n### 创建线程\n\n1. 继承 Thread重写 run方法,调用 start方法。\n   ```\n   new Thread(){\n   public void run() {\n   System.out.println(\"Thread\");\n   };\n   }.start();\n   ```\n2. Thread构造函数 中传入 Runnable 实现类,调用 start方法。\n\n```\nnew Thread(new Runnable() {\n\t@Override\n\tpublic void run() {\n\t\tSystem.out.println(\"Runnable\");\n\t}\n}).start();\n```\n\n3. 线程池中submit一个 (*Callable* ) 代码如下：\n\n```\nExecutorService service = Executors.newSingleThreadExecutor();\nFuture<String> future = service.submit(new Callable<String>() {\n\tpublic String call() throws Exception {\n\t\treturn \"Callable\";\n\t}\n});\nfuture.get();\n```\n\n4. 创建Timer\n\n```\nnew Timer().schedule(\n\t\tnew TimerTask(){\n\t\t\tpublic void run() {\n\t\t\t\tSystem.out.println(\"Timer\");\n\t\t\t}\n\t\t}, \n10000,\n1000);\n```\n\n# 2.线程间的通信方式\n\n### 1. 线程同步synchronized、notify、wait\n\n* 如果对象调用了wait方法就会 使持有该对象的线程把该对象的控制权交出去，然后处于等待状态。\n* 如果对象调用了notify方法就会通知某个正在等待这个对象的控制权的线程可以继续运行。（但不是立即）\n* 如果对象调用了notifyAll方法就会通知所有等待这个对象控制权的线程继续运行。（但不是立即）\n* wait、notify必须用在synchronized块里面。\n* 下面主线程和子线程轮流打印5次例子：\n\n```\npublic class SynchronizedDemo {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tfinal Worker business = new Worker();\n\t\tnew Thread() {\n\t\t\tpublic void run() {\n\t\t\t\tfor (int i = 1; i <= 2; i++) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tbusiness.sub(i);\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}.start();\n\n\t\tfor (int i = 1; i <= 2; i++) {\n\t\t\tbusiness.main(i);\n\t\t}\n\t}\n\n}\n \nclass Worker {\n\tprivate boolean isSub = true;\n\n\tpublic synchronized void sub(int i) throws Exception {\n\t\twhile (!isSub) {\n\t\t\tthis.wait();\n\t\t}\n\t\tfor (int j = 1; j <= 5; j++) {\n\t\t\tSystem.out.println(\"sub: \" + i + \" times \" + \",  loop \" + j);\n\t\t}\n\t\tisSub = false;\n\t\tthis.notify();\n\t}\n\n\tpublic synchronized void main(int i) throws InterruptedException {\n\t\twhile (isSub) {\n\t\t\tthis.wait();\n\t\t}\n\t\tfor (int j = 1; j <= 5; j++) {\n\t\t\tSystem.out.println(\"main: \" + i + \" times \" + \",  loop \" + j);\n\t\t}\n\t\tisSub = true;\n\t\tthis.notify();\n\t}\n}\n\n```\n\n### 2. 利用ReentrantLock、Condition\n\n* 如果Lock调用了await()方法就会 使持有该对象的线程把该对象的控制权交出去，然后处于等待状态。\n* 如果对象调用了signal方法就会通知某个正在等待这个对象的控制权的线程可以继续运行。（但不是立即）\n* 如果对象调用了signalAll方法就会通知所有等待这个对象控制权的线程继续运行。（但不是立即）\n* lock.unlock() 一定要写在 finally 块里防止异常释放锁失败造成死锁。\n* 下面主线程和子线程轮流打印5次例子：\n\n```\npublic class ReentrantLockDemo {\n\tpublic static void main(String[] args) throws Exception {\n\t\tfinal Worker2 business = new Worker2();\n\t\tnew Thread() {\n\t\t\tpublic void run() {\n\t\t\t\tfor (int i = 1; i <= 2; i++) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tbusiness.sub(i);\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}.start();\n\n\t\tfor (int i = 1; i <= 2; i++) {\n\t\t\tbusiness.main(i);\n\t\t}\n\t}\n\n}\n  \nclass Worker2 {\n\tLock lock = new ReentrantLock();\n\tCondition condition = lock.newCondition();\n\tprivate boolean isSub = true;\n\tpublic void sub(int i) throws InterruptedException {\n\t\tlock.lock();\n\t\ttry {\n\t\t\twhile (!isSub) {\n\t\t\t\tcondition.await();\n\t\t\t}\n\t\t\tfor (int j = 1; j <= 5; j++) {\n\t\t\t\tSystem.out.println(\"sub: \" + i + \" times \" + \",  loop \" + j);\n\t\t\t}\n\t\t\tisSub = false;\n\t\t\tcondition.signal();\n\t\t} finally {\n\t\t\tlock.unlock();\n\t\t}\n\t}\n\n\tpublic void main(int i) throws InterruptedException {\n\t\tlock.lock();\n\t\ttry {\n\t\t\twhile (isSub) {\n\t\t\t\tcondition.await();\n\t\t\t}\n\t\t\tfor (int j = 1; j <= 5; j++) {\n\t\t\t\tSystem.out.println(\"main: \" + i + \" times \" + \",  loop \" + j);\n\t\t\t}\n\t\t\tisSub = true;\n\t\t\tcondition.signal();\n\t\t} finally {\n\t\t\tlock.unlock();\n\t\t}\n\t}\n\n}\n```\n\n### 3. volatile能保证所修饰的变量对于多个线程可见性，即只要被修改，其它线程读到的一定是最新的值。（并不能保证，线程并发修改的数据是安全的）\n\n### 4. 并发工具类\n\n* Semaphore 线程调用semaphore.acquire()获取资源使用权 当获取到资源执行，否则一直阻塞 等待获取资源Semaphore 构造函数中必须有\n  最大的数量\n\n```\npublic static void main(String[] args) {\n\tfinal Semaphore semaphore = new Semaphore(1);\n\tfor (int i = 0; i < 10; i++) {\n\t\tnew Thread() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tSystem.out.println(Thread.currentThread().getName() + \" 我申请坑位\");\n\t\t\t\t\tsemaphore.acquire(1);\n\t\t\t\t\tSystem.out.println(Thread.currentThread().getName() + \" 我申请到坑位啦\");\n\t\t\t\t\tThread.sleep(5000);\n\t\t\t\t\tSystem.out.println(Thread.currentThread().getName() + \":  我完事啦\");\n\t\t\t\t\tsemaphore.release();\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}.start();\n\t}\n\n}\n```\n\n* Callable、Future 必须在线程池中使用，调用future.get()的线程会阻塞等待结果。\n\n```\npublic static void main(String[] args) throws Exception {\n\tExecutorService service = Executors.newSingleThreadExecutor();\n\tfinal Future<String> future = service.submit(new Callable<String>() {\n\t\tpublic String call() throws Exception {\n\t\t\tSystem.out.println(\"我在计算中\");\n\t\t\tThread.sleep(1000);\n\t\t\treturn \"hello\";\n\t\t}\n\t});\n\t\n\tservice.submit(new Runnable() {\n\t\tpublic void run() {\n\t\t\ttry {\n\t\t\t\tSystem.out.println(\"我在等待结果中\");\n\t\t\t\tSystem.out.println(\"结果: \"+future.get());\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t} \n\t\t}\n\t});\n\tservice.shutdown();\n}\n```\n\n* Exchanger仅适用与两个线程间数据的交换(类是与买东西 找补)。\n\n```\n public static void main(String[] args) {\n\tfinal Exchanger<Integer> exchanger=new Exchanger<Integer>();\n\t new Thread(){\n\t\t @Override\n\t\tpublic void run() {\n\t\t\t System.out.println(Thread.currentThread().getName()+ \"那谁，我要给你5块\");\n\t\t\t try {\n\t\t\t\tInteger exchange = exchanger.exchange(5);\n\t\t\t\tSystem.out.println(Thread.currentThread().getName()+ \"收到：\"+exchange +\" 块 \");\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t }.start();\n\t \n\t new Thread(){\n\t\t @Override\n\t\tpublic void run() {\n\t\t\t System.out.println(Thread.currentThread().getName()+ \"那谁，我要找你1块\");\n\t\t\t try {\n\t\t\t\t Integer exchange = exchanger.exchange(1);\n\t\t\t     System.out.println(Thread.currentThread().getName()+ \"收到：\"+exchange +\" 块 \");\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t }.start();\n\t \n\t \n}\n ```\n\n* CyclicBarrier 用于多个线程都准备等待,当同时等待的线程达到规定数量后 所有线程自动唤醒运行。 （类似汽车票站\n  没有检够票数不发车）相比CountDownLatch,CyclicBarrier不需要其他线程来唤醒等待的线程.CyclicBarrier 的构造函数 等待线程数量\n  达到规定数量线程开始运行。\n\n```\npublic static void main(String[] args) {\n\tCyclicBarrier cyclicBarrier=new CyclicBarrier(5);\n\tfor(int i=0;i<5;i++) {\n\t\t new Thread(){\n\t\t\t @Override\n\t\t\tpublic void run() {\n\t\t\t\t try {\n\t\t\t\t\t cyclicBarrier.await();\n\t\t\t\t\tThread.sleep((long) (Math.random()*1000));\n\t\t\t\t\tSystem.out.println(Thread.currentThread().getName()+ \":  开始跑啦\");\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t }.start();;\n\t }\n}\n```\n\n* CountDownLatch 用于多个线程都准备等待，接到命令后 统一运行（类似 赛跑比赛）CountDownLatch的构造函数中的数字表示等待者必须接到几次命令后\n  开始运行等待者待用调用countDownLatch.await()后开始阻塞发布命令者调用一次或多次countDownLatch.countDown()后唤醒等待者。\n\n```\npublic static void main(String[] args) throws Exception {\n\t final CountDownLatch countDownLatch=new CountDownLatch(1);\n\t for(int i=0;i<3;i++) {\n\t\t new Thread(){\n\t\t\t @Override\n\t\t\tpublic void run() {\n\t\t\t\t try {\n\t\t\t\t\tcountDownLatch.await();\n\t\t\t\t\tThread.sleep((long) (Math.random()*1000));\n\t\t\t\t\tSystem.out.println(Thread.currentThread().getName()+ \":  开始跑啦\");\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t }.start();\n\t }\n\t \n\t Thread.sleep(2000);\n\t System.out.println(Thread.currentThread().getName()+ \":  准备\");\n\t countDownLatch.countDown();\n}\n\n```\n\n# 3.线程常用api\n\n1. join()：线程的合并的含义就是将几个并行线程的线程合并为一个单线程执行，应用场景是当一个线程必须等待另一个线程执行完毕才能执行时可以使用join方法。\n2. yield(): 暂停当前正在执行的线程对象，并执行其他线程。（当前时间片）。\n3. interrupt():中断线程。\n4. sleep(long millis)：暂停执行(不会释放占有资源)。\n\n# 4.线程池\n\n### ThreadPoolExecutor\n\n\t1.ThreadPoolExecutor：ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<Runnable> workQueue)\n\t\t1.\t当线程池实际线程数小于corePoolSize时，有新的任务加入则优先创建线程。\n\t\t2.\t当线程池实际线程数等于corePoolSize时，有新的任务加入则加入队列。\n\t\t3.\t当线程池实际线程数等于corePoolSize时，有新的任务加入若队列已满，则在总线程数不大于maximumPoolSize的前提下，创建新的线程。\n\t\t4.\t当线程池实际线程数等于maximumPoolSize，有新的任务加入则执行拒绝策略（默认抛异常）。可自定义拒绝策略 需实现RejectedExecutionHandler接口。\n\t\t总结：所以关键点是： 队列是否会满若是无限队列（可能系统资源耗尽） ,maximumPoolSize是否会达到最大值。\n\n\t2.Executors工具提供四种线程池(基于 ThreadPoolExecutor )，分别为：\n\t\t1.\tnewCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。\n\t\t2.\tnewFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。\n\t\t3.\tnewScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。\n\t\t4.\tnewSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。\n\n# 5.Java死锁范例以及如何分析死锁\n\n### 什么是死锁\n\n\t1.死锁是这样一种情形：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放,而那个资源又不能被释放。导致线程被无限期地阻塞，因此程序不可能正常终止。(等待一个永远无法获取的资源)\n\t2.java 死锁产生的四个必要条件：\n\t\t1、互斥使用，即当资源被一个线程使用(占有)时，别的线程不能使用\n\t\t2、不可抢占，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放。\n\t\t3、请求和保持，即当资源请求者在请求其他的资源的同时保持对原有资源的占有。\n\t\t4、循环等待，即存在一个等待队列：P1占有P2的资源，P2占有P3的资源，P3占有P1的资源。这样就形成了一个等待环路。\n\n### 死锁方式\n\n1.\n\n第一种synchronized方式死锁：线程thread1先获取锁locka，然后在同步块里嵌套竞争锁lockb。而线程thread2先获取锁lockb，然后在同步块里嵌套竞争锁locka。此时已经被线程thread1拥有，而thread1在等待lockb，而lockb被thread2拥有，thread2在等待locka……无线循环。(\nsynchronized (locka){ ...; synchronized (locka){...;} ....; } )\n\n2. 第二种concurrent包Lock错误使用，导致死锁：释放锁使用地方不规范，导致死锁不能正常释放！ 应该在finally块里 lock.unlock();\n\n### 解决方法\n\n1. 修改代码才能从根本解决问题。\n2. 检查问题代码\n    1. 使用一些静态分析库可以帮助我们发现可能出现的死锁。\n    2. 它其中包含连个方法findDeadlockedThreads()和findMonitorDeadlockedThreads()，用来查找处于死锁。代码如下：thread1\n       和thread2 死锁状态。\n\n```\npublic static void main(String[] args) {\n\tfinal Object lock1 = new Object();\n\tfinal Object lock2 = new Object();\n\n\tThread thread1 = new Thread(new Runnable() {\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tsynchronized (lock1) {\n\t\t\t\tSystem.out.println(\"Thread1 acquired lock1\");\n\t\t\t\ttry {\n\t\t\t\t\tTimeUnit.MILLISECONDS.sleep(500);\n\t\t\t\t} catch (InterruptedException ignore) {\n\t\t\t\t}\n\t\t\t\tsynchronized (lock2) {\n\t\t\t\t\tSystem.out.println(\"Thread1 acquired lock2\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t});\n\tthread1.start();\n\n\tThread thread2 = new Thread(new Runnable() {\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tsynchronized (lock2) {\n\t\t\t\tSystem.out.println(\"Thread2 acquired lock2\");\n\t\t\t\tsynchronized (lock1) {\n\t\t\t\t\tSystem.out.println(\"Thread2 acquired lock1\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\tthread2.start();\n\ttry {\n\t\tThread.sleep(20000);\n\t} catch (InterruptedException e) {\n\t\t// TODO Auto-generated catch block\n\t\te.printStackTrace();\n\t}\n\tThread thread3 = new Thread(new Runnable() {\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tThreadMXBean mbean = ManagementFactory.getThreadMXBean();\n\t\t\tlong[] findDeadlockedThreads = mbean.findDeadlockedThreads();\n\t\t\tif (findDeadlockedThreads != null) {\n\t\t\t\tThreadInfo[] threadInfos = mbean.getThreadInfo(findDeadlockedThreads);\n\t\t\t\tfor (ThreadInfo threadInfo : threadInfos) {\n\t\t\t\t\t//获取线程\n\t\t\t\t\tfor (Thread thread : Thread.getAllStackTraces().keySet()) {\n\t\t\t\t\t\tif (thread.getId() == threadInfo.getThreadId()) {\n\t\t\t\t\t\t\tSystem.err.println(threadInfo.toString().trim());\n\t\t\t\t\t\t\tfor (StackTraceElement ste : thread.getStackTrace()) {\n\t\t\t\t\t\t\t\tSystem.err.println(\"t\" + ste.toString().trim());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\tthread3.start();\n}\n\n```","source":"_posts/java多线程的一些总结.md","raw":"---\ntitle: \"java多线程的一些总结\"\ndate: 2017-07-24 09:00:00\ncategory: JAVA\ntags:\n  - 基础知识\n---\n\n# 1.java线程创建方式\n----------------\n\n### 创建线程\n\n1. 继承 Thread重写 run方法,调用 start方法。\n   ```\n   new Thread(){\n   public void run() {\n   System.out.println(\"Thread\");\n   };\n   }.start();\n   ```\n2. Thread构造函数 中传入 Runnable 实现类,调用 start方法。\n\n```\nnew Thread(new Runnable() {\n\t@Override\n\tpublic void run() {\n\t\tSystem.out.println(\"Runnable\");\n\t}\n}).start();\n```\n\n3. 线程池中submit一个 (*Callable* ) 代码如下：\n\n```\nExecutorService service = Executors.newSingleThreadExecutor();\nFuture<String> future = service.submit(new Callable<String>() {\n\tpublic String call() throws Exception {\n\t\treturn \"Callable\";\n\t}\n});\nfuture.get();\n```\n\n4. 创建Timer\n\n```\nnew Timer().schedule(\n\t\tnew TimerTask(){\n\t\t\tpublic void run() {\n\t\t\t\tSystem.out.println(\"Timer\");\n\t\t\t}\n\t\t}, \n10000,\n1000);\n```\n\n# 2.线程间的通信方式\n\n### 1. 线程同步synchronized、notify、wait\n\n* 如果对象调用了wait方法就会 使持有该对象的线程把该对象的控制权交出去，然后处于等待状态。\n* 如果对象调用了notify方法就会通知某个正在等待这个对象的控制权的线程可以继续运行。（但不是立即）\n* 如果对象调用了notifyAll方法就会通知所有等待这个对象控制权的线程继续运行。（但不是立即）\n* wait、notify必须用在synchronized块里面。\n* 下面主线程和子线程轮流打印5次例子：\n\n```\npublic class SynchronizedDemo {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tfinal Worker business = new Worker();\n\t\tnew Thread() {\n\t\t\tpublic void run() {\n\t\t\t\tfor (int i = 1; i <= 2; i++) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tbusiness.sub(i);\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}.start();\n\n\t\tfor (int i = 1; i <= 2; i++) {\n\t\t\tbusiness.main(i);\n\t\t}\n\t}\n\n}\n \nclass Worker {\n\tprivate boolean isSub = true;\n\n\tpublic synchronized void sub(int i) throws Exception {\n\t\twhile (!isSub) {\n\t\t\tthis.wait();\n\t\t}\n\t\tfor (int j = 1; j <= 5; j++) {\n\t\t\tSystem.out.println(\"sub: \" + i + \" times \" + \",  loop \" + j);\n\t\t}\n\t\tisSub = false;\n\t\tthis.notify();\n\t}\n\n\tpublic synchronized void main(int i) throws InterruptedException {\n\t\twhile (isSub) {\n\t\t\tthis.wait();\n\t\t}\n\t\tfor (int j = 1; j <= 5; j++) {\n\t\t\tSystem.out.println(\"main: \" + i + \" times \" + \",  loop \" + j);\n\t\t}\n\t\tisSub = true;\n\t\tthis.notify();\n\t}\n}\n\n```\n\n### 2. 利用ReentrantLock、Condition\n\n* 如果Lock调用了await()方法就会 使持有该对象的线程把该对象的控制权交出去，然后处于等待状态。\n* 如果对象调用了signal方法就会通知某个正在等待这个对象的控制权的线程可以继续运行。（但不是立即）\n* 如果对象调用了signalAll方法就会通知所有等待这个对象控制权的线程继续运行。（但不是立即）\n* lock.unlock() 一定要写在 finally 块里防止异常释放锁失败造成死锁。\n* 下面主线程和子线程轮流打印5次例子：\n\n```\npublic class ReentrantLockDemo {\n\tpublic static void main(String[] args) throws Exception {\n\t\tfinal Worker2 business = new Worker2();\n\t\tnew Thread() {\n\t\t\tpublic void run() {\n\t\t\t\tfor (int i = 1; i <= 2; i++) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tbusiness.sub(i);\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}.start();\n\n\t\tfor (int i = 1; i <= 2; i++) {\n\t\t\tbusiness.main(i);\n\t\t}\n\t}\n\n}\n  \nclass Worker2 {\n\tLock lock = new ReentrantLock();\n\tCondition condition = lock.newCondition();\n\tprivate boolean isSub = true;\n\tpublic void sub(int i) throws InterruptedException {\n\t\tlock.lock();\n\t\ttry {\n\t\t\twhile (!isSub) {\n\t\t\t\tcondition.await();\n\t\t\t}\n\t\t\tfor (int j = 1; j <= 5; j++) {\n\t\t\t\tSystem.out.println(\"sub: \" + i + \" times \" + \",  loop \" + j);\n\t\t\t}\n\t\t\tisSub = false;\n\t\t\tcondition.signal();\n\t\t} finally {\n\t\t\tlock.unlock();\n\t\t}\n\t}\n\n\tpublic void main(int i) throws InterruptedException {\n\t\tlock.lock();\n\t\ttry {\n\t\t\twhile (isSub) {\n\t\t\t\tcondition.await();\n\t\t\t}\n\t\t\tfor (int j = 1; j <= 5; j++) {\n\t\t\t\tSystem.out.println(\"main: \" + i + \" times \" + \",  loop \" + j);\n\t\t\t}\n\t\t\tisSub = true;\n\t\t\tcondition.signal();\n\t\t} finally {\n\t\t\tlock.unlock();\n\t\t}\n\t}\n\n}\n```\n\n### 3. volatile能保证所修饰的变量对于多个线程可见性，即只要被修改，其它线程读到的一定是最新的值。（并不能保证，线程并发修改的数据是安全的）\n\n### 4. 并发工具类\n\n* Semaphore 线程调用semaphore.acquire()获取资源使用权 当获取到资源执行，否则一直阻塞 等待获取资源Semaphore 构造函数中必须有\n  最大的数量\n\n```\npublic static void main(String[] args) {\n\tfinal Semaphore semaphore = new Semaphore(1);\n\tfor (int i = 0; i < 10; i++) {\n\t\tnew Thread() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tSystem.out.println(Thread.currentThread().getName() + \" 我申请坑位\");\n\t\t\t\t\tsemaphore.acquire(1);\n\t\t\t\t\tSystem.out.println(Thread.currentThread().getName() + \" 我申请到坑位啦\");\n\t\t\t\t\tThread.sleep(5000);\n\t\t\t\t\tSystem.out.println(Thread.currentThread().getName() + \":  我完事啦\");\n\t\t\t\t\tsemaphore.release();\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}.start();\n\t}\n\n}\n```\n\n* Callable、Future 必须在线程池中使用，调用future.get()的线程会阻塞等待结果。\n\n```\npublic static void main(String[] args) throws Exception {\n\tExecutorService service = Executors.newSingleThreadExecutor();\n\tfinal Future<String> future = service.submit(new Callable<String>() {\n\t\tpublic String call() throws Exception {\n\t\t\tSystem.out.println(\"我在计算中\");\n\t\t\tThread.sleep(1000);\n\t\t\treturn \"hello\";\n\t\t}\n\t});\n\t\n\tservice.submit(new Runnable() {\n\t\tpublic void run() {\n\t\t\ttry {\n\t\t\t\tSystem.out.println(\"我在等待结果中\");\n\t\t\t\tSystem.out.println(\"结果: \"+future.get());\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t} \n\t\t}\n\t});\n\tservice.shutdown();\n}\n```\n\n* Exchanger仅适用与两个线程间数据的交换(类是与买东西 找补)。\n\n```\n public static void main(String[] args) {\n\tfinal Exchanger<Integer> exchanger=new Exchanger<Integer>();\n\t new Thread(){\n\t\t @Override\n\t\tpublic void run() {\n\t\t\t System.out.println(Thread.currentThread().getName()+ \"那谁，我要给你5块\");\n\t\t\t try {\n\t\t\t\tInteger exchange = exchanger.exchange(5);\n\t\t\t\tSystem.out.println(Thread.currentThread().getName()+ \"收到：\"+exchange +\" 块 \");\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t }.start();\n\t \n\t new Thread(){\n\t\t @Override\n\t\tpublic void run() {\n\t\t\t System.out.println(Thread.currentThread().getName()+ \"那谁，我要找你1块\");\n\t\t\t try {\n\t\t\t\t Integer exchange = exchanger.exchange(1);\n\t\t\t     System.out.println(Thread.currentThread().getName()+ \"收到：\"+exchange +\" 块 \");\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t }.start();\n\t \n\t \n}\n ```\n\n* CyclicBarrier 用于多个线程都准备等待,当同时等待的线程达到规定数量后 所有线程自动唤醒运行。 （类似汽车票站\n  没有检够票数不发车）相比CountDownLatch,CyclicBarrier不需要其他线程来唤醒等待的线程.CyclicBarrier 的构造函数 等待线程数量\n  达到规定数量线程开始运行。\n\n```\npublic static void main(String[] args) {\n\tCyclicBarrier cyclicBarrier=new CyclicBarrier(5);\n\tfor(int i=0;i<5;i++) {\n\t\t new Thread(){\n\t\t\t @Override\n\t\t\tpublic void run() {\n\t\t\t\t try {\n\t\t\t\t\t cyclicBarrier.await();\n\t\t\t\t\tThread.sleep((long) (Math.random()*1000));\n\t\t\t\t\tSystem.out.println(Thread.currentThread().getName()+ \":  开始跑啦\");\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t }.start();;\n\t }\n}\n```\n\n* CountDownLatch 用于多个线程都准备等待，接到命令后 统一运行（类似 赛跑比赛）CountDownLatch的构造函数中的数字表示等待者必须接到几次命令后\n  开始运行等待者待用调用countDownLatch.await()后开始阻塞发布命令者调用一次或多次countDownLatch.countDown()后唤醒等待者。\n\n```\npublic static void main(String[] args) throws Exception {\n\t final CountDownLatch countDownLatch=new CountDownLatch(1);\n\t for(int i=0;i<3;i++) {\n\t\t new Thread(){\n\t\t\t @Override\n\t\t\tpublic void run() {\n\t\t\t\t try {\n\t\t\t\t\tcountDownLatch.await();\n\t\t\t\t\tThread.sleep((long) (Math.random()*1000));\n\t\t\t\t\tSystem.out.println(Thread.currentThread().getName()+ \":  开始跑啦\");\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t }.start();\n\t }\n\t \n\t Thread.sleep(2000);\n\t System.out.println(Thread.currentThread().getName()+ \":  准备\");\n\t countDownLatch.countDown();\n}\n\n```\n\n# 3.线程常用api\n\n1. join()：线程的合并的含义就是将几个并行线程的线程合并为一个单线程执行，应用场景是当一个线程必须等待另一个线程执行完毕才能执行时可以使用join方法。\n2. yield(): 暂停当前正在执行的线程对象，并执行其他线程。（当前时间片）。\n3. interrupt():中断线程。\n4. sleep(long millis)：暂停执行(不会释放占有资源)。\n\n# 4.线程池\n\n### ThreadPoolExecutor\n\n\t1.ThreadPoolExecutor：ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<Runnable> workQueue)\n\t\t1.\t当线程池实际线程数小于corePoolSize时，有新的任务加入则优先创建线程。\n\t\t2.\t当线程池实际线程数等于corePoolSize时，有新的任务加入则加入队列。\n\t\t3.\t当线程池实际线程数等于corePoolSize时，有新的任务加入若队列已满，则在总线程数不大于maximumPoolSize的前提下，创建新的线程。\n\t\t4.\t当线程池实际线程数等于maximumPoolSize，有新的任务加入则执行拒绝策略（默认抛异常）。可自定义拒绝策略 需实现RejectedExecutionHandler接口。\n\t\t总结：所以关键点是： 队列是否会满若是无限队列（可能系统资源耗尽） ,maximumPoolSize是否会达到最大值。\n\n\t2.Executors工具提供四种线程池(基于 ThreadPoolExecutor )，分别为：\n\t\t1.\tnewCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。\n\t\t2.\tnewFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。\n\t\t3.\tnewScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。\n\t\t4.\tnewSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。\n\n# 5.Java死锁范例以及如何分析死锁\n\n### 什么是死锁\n\n\t1.死锁是这样一种情形：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放,而那个资源又不能被释放。导致线程被无限期地阻塞，因此程序不可能正常终止。(等待一个永远无法获取的资源)\n\t2.java 死锁产生的四个必要条件：\n\t\t1、互斥使用，即当资源被一个线程使用(占有)时，别的线程不能使用\n\t\t2、不可抢占，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放。\n\t\t3、请求和保持，即当资源请求者在请求其他的资源的同时保持对原有资源的占有。\n\t\t4、循环等待，即存在一个等待队列：P1占有P2的资源，P2占有P3的资源，P3占有P1的资源。这样就形成了一个等待环路。\n\n### 死锁方式\n\n1.\n\n第一种synchronized方式死锁：线程thread1先获取锁locka，然后在同步块里嵌套竞争锁lockb。而线程thread2先获取锁lockb，然后在同步块里嵌套竞争锁locka。此时已经被线程thread1拥有，而thread1在等待lockb，而lockb被thread2拥有，thread2在等待locka……无线循环。(\nsynchronized (locka){ ...; synchronized (locka){...;} ....; } )\n\n2. 第二种concurrent包Lock错误使用，导致死锁：释放锁使用地方不规范，导致死锁不能正常释放！ 应该在finally块里 lock.unlock();\n\n### 解决方法\n\n1. 修改代码才能从根本解决问题。\n2. 检查问题代码\n    1. 使用一些静态分析库可以帮助我们发现可能出现的死锁。\n    2. 它其中包含连个方法findDeadlockedThreads()和findMonitorDeadlockedThreads()，用来查找处于死锁。代码如下：thread1\n       和thread2 死锁状态。\n\n```\npublic static void main(String[] args) {\n\tfinal Object lock1 = new Object();\n\tfinal Object lock2 = new Object();\n\n\tThread thread1 = new Thread(new Runnable() {\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tsynchronized (lock1) {\n\t\t\t\tSystem.out.println(\"Thread1 acquired lock1\");\n\t\t\t\ttry {\n\t\t\t\t\tTimeUnit.MILLISECONDS.sleep(500);\n\t\t\t\t} catch (InterruptedException ignore) {\n\t\t\t\t}\n\t\t\t\tsynchronized (lock2) {\n\t\t\t\t\tSystem.out.println(\"Thread1 acquired lock2\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t});\n\tthread1.start();\n\n\tThread thread2 = new Thread(new Runnable() {\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tsynchronized (lock2) {\n\t\t\t\tSystem.out.println(\"Thread2 acquired lock2\");\n\t\t\t\tsynchronized (lock1) {\n\t\t\t\t\tSystem.out.println(\"Thread2 acquired lock1\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\tthread2.start();\n\ttry {\n\t\tThread.sleep(20000);\n\t} catch (InterruptedException e) {\n\t\t// TODO Auto-generated catch block\n\t\te.printStackTrace();\n\t}\n\tThread thread3 = new Thread(new Runnable() {\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tThreadMXBean mbean = ManagementFactory.getThreadMXBean();\n\t\t\tlong[] findDeadlockedThreads = mbean.findDeadlockedThreads();\n\t\t\tif (findDeadlockedThreads != null) {\n\t\t\t\tThreadInfo[] threadInfos = mbean.getThreadInfo(findDeadlockedThreads);\n\t\t\t\tfor (ThreadInfo threadInfo : threadInfos) {\n\t\t\t\t\t//获取线程\n\t\t\t\t\tfor (Thread thread : Thread.getAllStackTraces().keySet()) {\n\t\t\t\t\t\tif (thread.getId() == threadInfo.getThreadId()) {\n\t\t\t\t\t\t\tSystem.err.println(threadInfo.toString().trim());\n\t\t\t\t\t\t\tfor (StackTraceElement ste : thread.getStackTrace()) {\n\t\t\t\t\t\t\t\tSystem.err.println(\"t\" + ste.toString().trim());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\tthread3.start();\n}\n\n```","slug":"java多线程的一些总结","published":1,"updated":"2024-11-27T03:20:35.235Z","_id":"cm3zaz9c5000itgu63dl8eyh2","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"1-java线程创建方式\"><a href=\"#1-java线程创建方式\" class=\"headerlink\" title=\"1.java线程创建方式\"></a>1.java线程创建方式</h1><hr>\n<h3 id=\"创建线程\"><a href=\"#创建线程\" class=\"headerlink\" title=\"创建线程\"></a>创建线程</h3><ol>\n<li>继承 Thread重写 run方法,调用 start方法。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Thread()&#123;</span><br><span class=\"line\">public void run() &#123;</span><br><span class=\"line\">System.out.println(&quot;Thread&quot;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&#125;.start();</span><br></pre></td></tr></table></figure></li>\n<li>Thread构造函数 中传入 Runnable 实现类,调用 start方法。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Thread(new Runnable() &#123;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void run() &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;Runnable&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;).start();</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>线程池中submit一个 (<em>Callable</em> ) 代码如下：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService service = Executors.newSingleThreadExecutor();</span><br><span class=\"line\">Future&lt;String&gt; future = service.submit(new Callable&lt;String&gt;() &#123;</span><br><span class=\"line\">\tpublic String call() throws Exception &#123;</span><br><span class=\"line\">\t\treturn &quot;Callable&quot;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">future.get();</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>创建Timer</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Timer().schedule(</span><br><span class=\"line\">\t\tnew TimerTask()&#123;</span><br><span class=\"line\">\t\t\tpublic void run() &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(&quot;Timer&quot;);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;, </span><br><span class=\"line\">10000,</span><br><span class=\"line\">1000);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"2-线程间的通信方式\"><a href=\"#2-线程间的通信方式\" class=\"headerlink\" title=\"2.线程间的通信方式\"></a>2.线程间的通信方式</h1><h3 id=\"1-线程同步synchronized、notify、wait\"><a href=\"#1-线程同步synchronized、notify、wait\" class=\"headerlink\" title=\"1. 线程同步synchronized、notify、wait\"></a>1. 线程同步synchronized、notify、wait</h3><ul>\n<li>如果对象调用了wait方法就会 使持有该对象的线程把该对象的控制权交出去，然后处于等待状态。</li>\n<li>如果对象调用了notify方法就会通知某个正在等待这个对象的控制权的线程可以继续运行。（但不是立即）</li>\n<li>如果对象调用了notifyAll方法就会通知所有等待这个对象控制权的线程继续运行。（但不是立即）</li>\n<li>wait、notify必须用在synchronized块里面。</li>\n<li>下面主线程和子线程轮流打印5次例子：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SynchronizedDemo &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">\t\tfinal Worker business = new Worker();</span><br><span class=\"line\">\t\tnew Thread() &#123;</span><br><span class=\"line\">\t\t\tpublic void run() &#123;</span><br><span class=\"line\">\t\t\t\tfor (int i = 1; i &lt;= 2; i++) &#123;</span><br><span class=\"line\">\t\t\t\t\ttry &#123;</span><br><span class=\"line\">\t\t\t\t\t\tbusiness.sub(i);</span><br><span class=\"line\">\t\t\t\t\t&#125; catch (Exception e) &#123;</span><br><span class=\"line\">\t\t\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;;</span><br><span class=\"line\">\t\t&#125;.start();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tfor (int i = 1; i &lt;= 2; i++) &#123;</span><br><span class=\"line\">\t\t\tbusiness.main(i);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">class Worker &#123;</span><br><span class=\"line\">\tprivate boolean isSub = true;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic synchronized void sub(int i) throws Exception &#123;</span><br><span class=\"line\">\t\twhile (!isSub) &#123;</span><br><span class=\"line\">\t\t\tthis.wait();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfor (int j = 1; j &lt;= 5; j++) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(&quot;sub: &quot; + i + &quot; times &quot; + &quot;,  loop &quot; + j);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tisSub = false;</span><br><span class=\"line\">\t\tthis.notify();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic synchronized void main(int i) throws InterruptedException &#123;</span><br><span class=\"line\">\t\twhile (isSub) &#123;</span><br><span class=\"line\">\t\t\tthis.wait();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfor (int j = 1; j &lt;= 5; j++) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(&quot;main: &quot; + i + &quot; times &quot; + &quot;,  loop &quot; + j);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tisSub = true;</span><br><span class=\"line\">\t\tthis.notify();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-利用ReentrantLock、Condition\"><a href=\"#2-利用ReentrantLock、Condition\" class=\"headerlink\" title=\"2. 利用ReentrantLock、Condition\"></a>2. 利用ReentrantLock、Condition</h3><ul>\n<li>如果Lock调用了await()方法就会 使持有该对象的线程把该对象的控制权交出去，然后处于等待状态。</li>\n<li>如果对象调用了signal方法就会通知某个正在等待这个对象的控制权的线程可以继续运行。（但不是立即）</li>\n<li>如果对象调用了signalAll方法就会通知所有等待这个对象控制权的线程继续运行。（但不是立即）</li>\n<li>lock.unlock() 一定要写在 finally 块里防止异常释放锁失败造成死锁。</li>\n<li>下面主线程和子线程轮流打印5次例子：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ReentrantLockDemo &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">\t\tfinal Worker2 business = new Worker2();</span><br><span class=\"line\">\t\tnew Thread() &#123;</span><br><span class=\"line\">\t\t\tpublic void run() &#123;</span><br><span class=\"line\">\t\t\t\tfor (int i = 1; i &lt;= 2; i++) &#123;</span><br><span class=\"line\">\t\t\t\t\ttry &#123;</span><br><span class=\"line\">\t\t\t\t\t\tbusiness.sub(i);</span><br><span class=\"line\">\t\t\t\t\t&#125; catch (Exception e) &#123;</span><br><span class=\"line\">\t\t\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;;</span><br><span class=\"line\">\t\t&#125;.start();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tfor (int i = 1; i &lt;= 2; i++) &#123;</span><br><span class=\"line\">\t\t\tbusiness.main(i);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">class Worker2 &#123;</span><br><span class=\"line\">\tLock lock = new ReentrantLock();</span><br><span class=\"line\">\tCondition condition = lock.newCondition();</span><br><span class=\"line\">\tprivate boolean isSub = true;</span><br><span class=\"line\">\tpublic void sub(int i) throws InterruptedException &#123;</span><br><span class=\"line\">\t\tlock.lock();</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\twhile (!isSub) &#123;</span><br><span class=\"line\">\t\t\t\tcondition.await();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tfor (int j = 1; j &lt;= 5; j++) &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(&quot;sub: &quot; + i + &quot; times &quot; + &quot;,  loop &quot; + j);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tisSub = false;</span><br><span class=\"line\">\t\t\tcondition.signal();</span><br><span class=\"line\">\t\t&#125; finally &#123;</span><br><span class=\"line\">\t\t\tlock.unlock();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void main(int i) throws InterruptedException &#123;</span><br><span class=\"line\">\t\tlock.lock();</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\twhile (isSub) &#123;</span><br><span class=\"line\">\t\t\t\tcondition.await();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tfor (int j = 1; j &lt;= 5; j++) &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(&quot;main: &quot; + i + &quot; times &quot; + &quot;,  loop &quot; + j);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tisSub = true;</span><br><span class=\"line\">\t\t\tcondition.signal();</span><br><span class=\"line\">\t\t&#125; finally &#123;</span><br><span class=\"line\">\t\t\tlock.unlock();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-volatile能保证所修饰的变量对于多个线程可见性，即只要被修改，其它线程读到的一定是最新的值。（并不能保证，线程并发修改的数据是安全的）\"><a href=\"#3-volatile能保证所修饰的变量对于多个线程可见性，即只要被修改，其它线程读到的一定是最新的值。（并不能保证，线程并发修改的数据是安全的）\" class=\"headerlink\" title=\"3. volatile能保证所修饰的变量对于多个线程可见性，即只要被修改，其它线程读到的一定是最新的值。（并不能保证，线程并发修改的数据是安全的）\"></a>3. volatile能保证所修饰的变量对于多个线程可见性，即只要被修改，其它线程读到的一定是最新的值。（并不能保证，线程并发修改的数据是安全的）</h3><h3 id=\"4-并发工具类\"><a href=\"#4-并发工具类\" class=\"headerlink\" title=\"4. 并发工具类\"></a>4. 并发工具类</h3><ul>\n<li>Semaphore 线程调用semaphore.acquire()获取资源使用权 当获取到资源执行，否则一直阻塞 等待获取资源Semaphore 构造函数中必须有<br>最大的数量</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">\tfinal Semaphore semaphore = new Semaphore(1);</span><br><span class=\"line\">\tfor (int i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">\t\tnew Thread() &#123;</span><br><span class=\"line\">\t\t\t@Override</span><br><span class=\"line\">\t\t\tpublic void run() &#123;</span><br><span class=\"line\">\t\t\t\ttry &#123;</span><br><span class=\"line\">\t\t\t\t\tSystem.out.println(Thread.currentThread().getName() + &quot; 我申请坑位&quot;);</span><br><span class=\"line\">\t\t\t\t\tsemaphore.acquire(1);</span><br><span class=\"line\">\t\t\t\t\tSystem.out.println(Thread.currentThread().getName() + &quot; 我申请到坑位啦&quot;);</span><br><span class=\"line\">\t\t\t\t\tThread.sleep(5000);</span><br><span class=\"line\">\t\t\t\t\tSystem.out.println(Thread.currentThread().getName() + &quot;:  我完事啦&quot;);</span><br><span class=\"line\">\t\t\t\t\tsemaphore.release();</span><br><span class=\"line\">\t\t\t\t&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;.start();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Callable、Future 必须在线程池中使用，调用future.get()的线程会阻塞等待结果。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">\tExecutorService service = Executors.newSingleThreadExecutor();</span><br><span class=\"line\">\tfinal Future&lt;String&gt; future = service.submit(new Callable&lt;String&gt;() &#123;</span><br><span class=\"line\">\t\tpublic String call() throws Exception &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(&quot;我在计算中&quot;);</span><br><span class=\"line\">\t\t\tThread.sleep(1000);</span><br><span class=\"line\">\t\t\treturn &quot;hello&quot;;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tservice.submit(new Runnable() &#123;</span><br><span class=\"line\">\t\tpublic void run() &#123;</span><br><span class=\"line\">\t\t\ttry &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(&quot;我在等待结果中&quot;);</span><br><span class=\"line\">\t\t\t\tSystem.out.println(&quot;结果: &quot;+future.get());</span><br><span class=\"line\">\t\t\t&#125; catch (Exception e) &#123;</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125; </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\tservice.shutdown();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Exchanger仅适用与两个线程间数据的交换(类是与买东西 找补)。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> public static void main(String[] args) &#123;</span><br><span class=\"line\">\tfinal Exchanger&lt;Integer&gt; exchanger=new Exchanger&lt;Integer&gt;();</span><br><span class=\"line\">\t new Thread()&#123;</span><br><span class=\"line\">\t\t @Override</span><br><span class=\"line\">\t\tpublic void run() &#123;</span><br><span class=\"line\">\t\t\t System.out.println(Thread.currentThread().getName()+ &quot;那谁，我要给你5块&quot;);</span><br><span class=\"line\">\t\t\t try &#123;</span><br><span class=\"line\">\t\t\t\tInteger exchange = exchanger.exchange(5);</span><br><span class=\"line\">\t\t\t\tSystem.out.println(Thread.currentThread().getName()+ &quot;收到：&quot;+exchange +&quot; 块 &quot;);</span><br><span class=\"line\">\t\t\t&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t &#125;.start();</span><br><span class=\"line\">\t </span><br><span class=\"line\">\t new Thread()&#123;</span><br><span class=\"line\">\t\t @Override</span><br><span class=\"line\">\t\tpublic void run() &#123;</span><br><span class=\"line\">\t\t\t System.out.println(Thread.currentThread().getName()+ &quot;那谁，我要找你1块&quot;);</span><br><span class=\"line\">\t\t\t try &#123;</span><br><span class=\"line\">\t\t\t\t Integer exchange = exchanger.exchange(1);</span><br><span class=\"line\">\t\t\t     System.out.println(Thread.currentThread().getName()+ &quot;收到：&quot;+exchange +&quot; 块 &quot;);</span><br><span class=\"line\">\t\t\t&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\t\t// TODO Auto-generated catch block</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t &#125;.start();</span><br><span class=\"line\">\t </span><br><span class=\"line\">\t </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>CyclicBarrier 用于多个线程都准备等待,当同时等待的线程达到规定数量后 所有线程自动唤醒运行。 （类似汽车票站<br>没有检够票数不发车）相比CountDownLatch,CyclicBarrier不需要其他线程来唤醒等待的线程.CyclicBarrier 的构造函数 等待线程数量<br>达到规定数量线程开始运行。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">\tCyclicBarrier cyclicBarrier=new CyclicBarrier(5);</span><br><span class=\"line\">\tfor(int i=0;i&lt;5;i++) &#123;</span><br><span class=\"line\">\t\t new Thread()&#123;</span><br><span class=\"line\">\t\t\t @Override</span><br><span class=\"line\">\t\t\tpublic void run() &#123;</span><br><span class=\"line\">\t\t\t\t try &#123;</span><br><span class=\"line\">\t\t\t\t\t cyclicBarrier.await();</span><br><span class=\"line\">\t\t\t\t\tThread.sleep((long) (Math.random()*1000));</span><br><span class=\"line\">\t\t\t\t\tSystem.out.println(Thread.currentThread().getName()+ &quot;:  开始跑啦&quot;);</span><br><span class=\"line\">\t\t\t\t&#125; catch (Exception e) &#123;</span><br><span class=\"line\">\t\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t &#125;.start();;</span><br><span class=\"line\">\t &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>CountDownLatch 用于多个线程都准备等待，接到命令后 统一运行（类似 赛跑比赛）CountDownLatch的构造函数中的数字表示等待者必须接到几次命令后<br>开始运行等待者待用调用countDownLatch.await()后开始阻塞发布命令者调用一次或多次countDownLatch.countDown()后唤醒等待者。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">\t final CountDownLatch countDownLatch=new CountDownLatch(1);</span><br><span class=\"line\">\t for(int i=0;i&lt;3;i++) &#123;</span><br><span class=\"line\">\t\t new Thread()&#123;</span><br><span class=\"line\">\t\t\t @Override</span><br><span class=\"line\">\t\t\tpublic void run() &#123;</span><br><span class=\"line\">\t\t\t\t try &#123;</span><br><span class=\"line\">\t\t\t\t\tcountDownLatch.await();</span><br><span class=\"line\">\t\t\t\t\tThread.sleep((long) (Math.random()*1000));</span><br><span class=\"line\">\t\t\t\t\tSystem.out.println(Thread.currentThread().getName()+ &quot;:  开始跑啦&quot;);</span><br><span class=\"line\">\t\t\t\t&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t &#125;.start();</span><br><span class=\"line\">\t &#125;</span><br><span class=\"line\">\t </span><br><span class=\"line\">\t Thread.sleep(2000);</span><br><span class=\"line\">\t System.out.println(Thread.currentThread().getName()+ &quot;:  准备&quot;);</span><br><span class=\"line\">\t countDownLatch.countDown();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-线程常用api\"><a href=\"#3-线程常用api\" class=\"headerlink\" title=\"3.线程常用api\"></a>3.线程常用api</h1><ol>\n<li>join()：线程的合并的含义就是将几个并行线程的线程合并为一个单线程执行，应用场景是当一个线程必须等待另一个线程执行完毕才能执行时可以使用join方法。</li>\n<li>yield(): 暂停当前正在执行的线程对象，并执行其他线程。（当前时间片）。</li>\n<li>interrupt():中断线程。</li>\n<li>sleep(long millis)：暂停执行(不会释放占有资源)。</li>\n</ol>\n<h1 id=\"4-线程池\"><a href=\"#4-线程池\" class=\"headerlink\" title=\"4.线程池\"></a>4.线程池</h1><h3 id=\"ThreadPoolExecutor\"><a href=\"#ThreadPoolExecutor\" class=\"headerlink\" title=\"ThreadPoolExecutor\"></a>ThreadPoolExecutor</h3><pre><code>1.ThreadPoolExecutor：ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue)\n    1.\t当线程池实际线程数小于corePoolSize时，有新的任务加入则优先创建线程。\n    2.\t当线程池实际线程数等于corePoolSize时，有新的任务加入则加入队列。\n    3.\t当线程池实际线程数等于corePoolSize时，有新的任务加入若队列已满，则在总线程数不大于maximumPoolSize的前提下，创建新的线程。\n    4.\t当线程池实际线程数等于maximumPoolSize，有新的任务加入则执行拒绝策略（默认抛异常）。可自定义拒绝策略 需实现RejectedExecutionHandler接口。\n    总结：所以关键点是： 队列是否会满若是无限队列（可能系统资源耗尽） ,maximumPoolSize是否会达到最大值。\n\n2.Executors工具提供四种线程池(基于 ThreadPoolExecutor )，分别为：\n    1.\tnewCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。\n    2.\tnewFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。\n    3.\tnewScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。\n    4.\tnewSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。\n</code></pre>\n<h1 id=\"5-Java死锁范例以及如何分析死锁\"><a href=\"#5-Java死锁范例以及如何分析死锁\" class=\"headerlink\" title=\"5.Java死锁范例以及如何分析死锁\"></a>5.Java死锁范例以及如何分析死锁</h1><h3 id=\"什么是死锁\"><a href=\"#什么是死锁\" class=\"headerlink\" title=\"什么是死锁\"></a>什么是死锁</h3><pre><code>1.死锁是这样一种情形：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放,而那个资源又不能被释放。导致线程被无限期地阻塞，因此程序不可能正常终止。(等待一个永远无法获取的资源)\n2.java 死锁产生的四个必要条件：\n    1、互斥使用，即当资源被一个线程使用(占有)时，别的线程不能使用\n    2、不可抢占，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放。\n    3、请求和保持，即当资源请求者在请求其他的资源的同时保持对原有资源的占有。\n    4、循环等待，即存在一个等待队列：P1占有P2的资源，P2占有P3的资源，P3占有P1的资源。这样就形成了一个等待环路。\n</code></pre>\n<h3 id=\"死锁方式\"><a href=\"#死锁方式\" class=\"headerlink\" title=\"死锁方式\"></a>死锁方式</h3><ol>\n<li></li>\n</ol>\n<p>第一种synchronized方式死锁：线程thread1先获取锁locka，然后在同步块里嵌套竞争锁lockb。而线程thread2先获取锁lockb，然后在同步块里嵌套竞争锁locka。此时已经被线程thread1拥有，而thread1在等待lockb，而lockb被thread2拥有，thread2在等待locka……无线循环。(<br>synchronized (locka){ …; synchronized (locka){…;} ….; } )</p>\n<ol start=\"2\">\n<li>第二种concurrent包Lock错误使用，导致死锁：释放锁使用地方不规范，导致死锁不能正常释放！ 应该在finally块里 lock.unlock();</li>\n</ol>\n<h3 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h3><ol>\n<li>修改代码才能从根本解决问题。</li>\n<li>检查问题代码<ol>\n<li>使用一些静态分析库可以帮助我们发现可能出现的死锁。</li>\n<li>它其中包含连个方法findDeadlockedThreads()和findMonitorDeadlockedThreads()，用来查找处于死锁。代码如下：thread1<br>和thread2 死锁状态。</li>\n</ol>\n</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">\tfinal Object lock1 = new Object();</span><br><span class=\"line\">\tfinal Object lock2 = new Object();</span><br><span class=\"line\"></span><br><span class=\"line\">\tThread thread1 = new Thread(new Runnable() &#123;</span><br><span class=\"line\">\t\t@Override</span><br><span class=\"line\">\t\tpublic void run() &#123;</span><br><span class=\"line\">\t\t\tsynchronized (lock1) &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(&quot;Thread1 acquired lock1&quot;);</span><br><span class=\"line\">\t\t\t\ttry &#123;</span><br><span class=\"line\">\t\t\t\t\tTimeUnit.MILLISECONDS.sleep(500);</span><br><span class=\"line\">\t\t\t\t&#125; catch (InterruptedException ignore) &#123;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tsynchronized (lock2) &#123;</span><br><span class=\"line\">\t\t\t\t\tSystem.out.println(&quot;Thread1 acquired lock2&quot;);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\tthread1.start();</span><br><span class=\"line\"></span><br><span class=\"line\">\tThread thread2 = new Thread(new Runnable() &#123;</span><br><span class=\"line\">\t\t@Override</span><br><span class=\"line\">\t\tpublic void run() &#123;</span><br><span class=\"line\">\t\t\tsynchronized (lock2) &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(&quot;Thread2 acquired lock2&quot;);</span><br><span class=\"line\">\t\t\t\tsynchronized (lock1) &#123;</span><br><span class=\"line\">\t\t\t\t\tSystem.out.println(&quot;Thread2 acquired lock1&quot;);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\tthread2.start();</span><br><span class=\"line\">\ttry &#123;</span><br><span class=\"line\">\t\tThread.sleep(20000);</span><br><span class=\"line\">\t&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t// TODO Auto-generated catch block</span><br><span class=\"line\">\t\te.printStackTrace();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tThread thread3 = new Thread(new Runnable() &#123;</span><br><span class=\"line\">\t\t@Override</span><br><span class=\"line\">\t\tpublic void run() &#123;</span><br><span class=\"line\">\t\t\tThreadMXBean mbean = ManagementFactory.getThreadMXBean();</span><br><span class=\"line\">\t\t\tlong[] findDeadlockedThreads = mbean.findDeadlockedThreads();</span><br><span class=\"line\">\t\t\tif (findDeadlockedThreads != null) &#123;</span><br><span class=\"line\">\t\t\t\tThreadInfo[] threadInfos = mbean.getThreadInfo(findDeadlockedThreads);</span><br><span class=\"line\">\t\t\t\tfor (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class=\"line\">\t\t\t\t\t//获取线程</span><br><span class=\"line\">\t\t\t\t\tfor (Thread thread : Thread.getAllStackTraces().keySet()) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tif (thread.getId() == threadInfo.getThreadId()) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\tSystem.err.println(threadInfo.toString().trim());</span><br><span class=\"line\">\t\t\t\t\t\t\tfor (StackTraceElement ste : thread.getStackTrace()) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\tSystem.err.println(&quot;t&quot; + ste.toString().trim());</span><br><span class=\"line\">\t\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\tthread3.start();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","excerpt":"","more":"<h1 id=\"1-java线程创建方式\"><a href=\"#1-java线程创建方式\" class=\"headerlink\" title=\"1.java线程创建方式\"></a>1.java线程创建方式</h1><hr>\n<h3 id=\"创建线程\"><a href=\"#创建线程\" class=\"headerlink\" title=\"创建线程\"></a>创建线程</h3><ol>\n<li>继承 Thread重写 run方法,调用 start方法。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Thread()&#123;</span><br><span class=\"line\">public void run() &#123;</span><br><span class=\"line\">System.out.println(&quot;Thread&quot;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&#125;.start();</span><br></pre></td></tr></table></figure></li>\n<li>Thread构造函数 中传入 Runnable 实现类,调用 start方法。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Thread(new Runnable() &#123;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void run() &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;Runnable&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;).start();</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>线程池中submit一个 (<em>Callable</em> ) 代码如下：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService service = Executors.newSingleThreadExecutor();</span><br><span class=\"line\">Future&lt;String&gt; future = service.submit(new Callable&lt;String&gt;() &#123;</span><br><span class=\"line\">\tpublic String call() throws Exception &#123;</span><br><span class=\"line\">\t\treturn &quot;Callable&quot;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">future.get();</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>创建Timer</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Timer().schedule(</span><br><span class=\"line\">\t\tnew TimerTask()&#123;</span><br><span class=\"line\">\t\t\tpublic void run() &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(&quot;Timer&quot;);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;, </span><br><span class=\"line\">10000,</span><br><span class=\"line\">1000);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"2-线程间的通信方式\"><a href=\"#2-线程间的通信方式\" class=\"headerlink\" title=\"2.线程间的通信方式\"></a>2.线程间的通信方式</h1><h3 id=\"1-线程同步synchronized、notify、wait\"><a href=\"#1-线程同步synchronized、notify、wait\" class=\"headerlink\" title=\"1. 线程同步synchronized、notify、wait\"></a>1. 线程同步synchronized、notify、wait</h3><ul>\n<li>如果对象调用了wait方法就会 使持有该对象的线程把该对象的控制权交出去，然后处于等待状态。</li>\n<li>如果对象调用了notify方法就会通知某个正在等待这个对象的控制权的线程可以继续运行。（但不是立即）</li>\n<li>如果对象调用了notifyAll方法就会通知所有等待这个对象控制权的线程继续运行。（但不是立即）</li>\n<li>wait、notify必须用在synchronized块里面。</li>\n<li>下面主线程和子线程轮流打印5次例子：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SynchronizedDemo &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">\t\tfinal Worker business = new Worker();</span><br><span class=\"line\">\t\tnew Thread() &#123;</span><br><span class=\"line\">\t\t\tpublic void run() &#123;</span><br><span class=\"line\">\t\t\t\tfor (int i = 1; i &lt;= 2; i++) &#123;</span><br><span class=\"line\">\t\t\t\t\ttry &#123;</span><br><span class=\"line\">\t\t\t\t\t\tbusiness.sub(i);</span><br><span class=\"line\">\t\t\t\t\t&#125; catch (Exception e) &#123;</span><br><span class=\"line\">\t\t\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;;</span><br><span class=\"line\">\t\t&#125;.start();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tfor (int i = 1; i &lt;= 2; i++) &#123;</span><br><span class=\"line\">\t\t\tbusiness.main(i);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">class Worker &#123;</span><br><span class=\"line\">\tprivate boolean isSub = true;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic synchronized void sub(int i) throws Exception &#123;</span><br><span class=\"line\">\t\twhile (!isSub) &#123;</span><br><span class=\"line\">\t\t\tthis.wait();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfor (int j = 1; j &lt;= 5; j++) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(&quot;sub: &quot; + i + &quot; times &quot; + &quot;,  loop &quot; + j);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tisSub = false;</span><br><span class=\"line\">\t\tthis.notify();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic synchronized void main(int i) throws InterruptedException &#123;</span><br><span class=\"line\">\t\twhile (isSub) &#123;</span><br><span class=\"line\">\t\t\tthis.wait();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfor (int j = 1; j &lt;= 5; j++) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(&quot;main: &quot; + i + &quot; times &quot; + &quot;,  loop &quot; + j);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tisSub = true;</span><br><span class=\"line\">\t\tthis.notify();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-利用ReentrantLock、Condition\"><a href=\"#2-利用ReentrantLock、Condition\" class=\"headerlink\" title=\"2. 利用ReentrantLock、Condition\"></a>2. 利用ReentrantLock、Condition</h3><ul>\n<li>如果Lock调用了await()方法就会 使持有该对象的线程把该对象的控制权交出去，然后处于等待状态。</li>\n<li>如果对象调用了signal方法就会通知某个正在等待这个对象的控制权的线程可以继续运行。（但不是立即）</li>\n<li>如果对象调用了signalAll方法就会通知所有等待这个对象控制权的线程继续运行。（但不是立即）</li>\n<li>lock.unlock() 一定要写在 finally 块里防止异常释放锁失败造成死锁。</li>\n<li>下面主线程和子线程轮流打印5次例子：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ReentrantLockDemo &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">\t\tfinal Worker2 business = new Worker2();</span><br><span class=\"line\">\t\tnew Thread() &#123;</span><br><span class=\"line\">\t\t\tpublic void run() &#123;</span><br><span class=\"line\">\t\t\t\tfor (int i = 1; i &lt;= 2; i++) &#123;</span><br><span class=\"line\">\t\t\t\t\ttry &#123;</span><br><span class=\"line\">\t\t\t\t\t\tbusiness.sub(i);</span><br><span class=\"line\">\t\t\t\t\t&#125; catch (Exception e) &#123;</span><br><span class=\"line\">\t\t\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;;</span><br><span class=\"line\">\t\t&#125;.start();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tfor (int i = 1; i &lt;= 2; i++) &#123;</span><br><span class=\"line\">\t\t\tbusiness.main(i);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">class Worker2 &#123;</span><br><span class=\"line\">\tLock lock = new ReentrantLock();</span><br><span class=\"line\">\tCondition condition = lock.newCondition();</span><br><span class=\"line\">\tprivate boolean isSub = true;</span><br><span class=\"line\">\tpublic void sub(int i) throws InterruptedException &#123;</span><br><span class=\"line\">\t\tlock.lock();</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\twhile (!isSub) &#123;</span><br><span class=\"line\">\t\t\t\tcondition.await();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tfor (int j = 1; j &lt;= 5; j++) &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(&quot;sub: &quot; + i + &quot; times &quot; + &quot;,  loop &quot; + j);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tisSub = false;</span><br><span class=\"line\">\t\t\tcondition.signal();</span><br><span class=\"line\">\t\t&#125; finally &#123;</span><br><span class=\"line\">\t\t\tlock.unlock();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void main(int i) throws InterruptedException &#123;</span><br><span class=\"line\">\t\tlock.lock();</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\twhile (isSub) &#123;</span><br><span class=\"line\">\t\t\t\tcondition.await();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tfor (int j = 1; j &lt;= 5; j++) &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(&quot;main: &quot; + i + &quot; times &quot; + &quot;,  loop &quot; + j);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tisSub = true;</span><br><span class=\"line\">\t\t\tcondition.signal();</span><br><span class=\"line\">\t\t&#125; finally &#123;</span><br><span class=\"line\">\t\t\tlock.unlock();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-volatile能保证所修饰的变量对于多个线程可见性，即只要被修改，其它线程读到的一定是最新的值。（并不能保证，线程并发修改的数据是安全的）\"><a href=\"#3-volatile能保证所修饰的变量对于多个线程可见性，即只要被修改，其它线程读到的一定是最新的值。（并不能保证，线程并发修改的数据是安全的）\" class=\"headerlink\" title=\"3. volatile能保证所修饰的变量对于多个线程可见性，即只要被修改，其它线程读到的一定是最新的值。（并不能保证，线程并发修改的数据是安全的）\"></a>3. volatile能保证所修饰的变量对于多个线程可见性，即只要被修改，其它线程读到的一定是最新的值。（并不能保证，线程并发修改的数据是安全的）</h3><h3 id=\"4-并发工具类\"><a href=\"#4-并发工具类\" class=\"headerlink\" title=\"4. 并发工具类\"></a>4. 并发工具类</h3><ul>\n<li>Semaphore 线程调用semaphore.acquire()获取资源使用权 当获取到资源执行，否则一直阻塞 等待获取资源Semaphore 构造函数中必须有<br>最大的数量</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">\tfinal Semaphore semaphore = new Semaphore(1);</span><br><span class=\"line\">\tfor (int i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">\t\tnew Thread() &#123;</span><br><span class=\"line\">\t\t\t@Override</span><br><span class=\"line\">\t\t\tpublic void run() &#123;</span><br><span class=\"line\">\t\t\t\ttry &#123;</span><br><span class=\"line\">\t\t\t\t\tSystem.out.println(Thread.currentThread().getName() + &quot; 我申请坑位&quot;);</span><br><span class=\"line\">\t\t\t\t\tsemaphore.acquire(1);</span><br><span class=\"line\">\t\t\t\t\tSystem.out.println(Thread.currentThread().getName() + &quot; 我申请到坑位啦&quot;);</span><br><span class=\"line\">\t\t\t\t\tThread.sleep(5000);</span><br><span class=\"line\">\t\t\t\t\tSystem.out.println(Thread.currentThread().getName() + &quot;:  我完事啦&quot;);</span><br><span class=\"line\">\t\t\t\t\tsemaphore.release();</span><br><span class=\"line\">\t\t\t\t&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;.start();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Callable、Future 必须在线程池中使用，调用future.get()的线程会阻塞等待结果。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">\tExecutorService service = Executors.newSingleThreadExecutor();</span><br><span class=\"line\">\tfinal Future&lt;String&gt; future = service.submit(new Callable&lt;String&gt;() &#123;</span><br><span class=\"line\">\t\tpublic String call() throws Exception &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(&quot;我在计算中&quot;);</span><br><span class=\"line\">\t\t\tThread.sleep(1000);</span><br><span class=\"line\">\t\t\treturn &quot;hello&quot;;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tservice.submit(new Runnable() &#123;</span><br><span class=\"line\">\t\tpublic void run() &#123;</span><br><span class=\"line\">\t\t\ttry &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(&quot;我在等待结果中&quot;);</span><br><span class=\"line\">\t\t\t\tSystem.out.println(&quot;结果: &quot;+future.get());</span><br><span class=\"line\">\t\t\t&#125; catch (Exception e) &#123;</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125; </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\tservice.shutdown();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Exchanger仅适用与两个线程间数据的交换(类是与买东西 找补)。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> public static void main(String[] args) &#123;</span><br><span class=\"line\">\tfinal Exchanger&lt;Integer&gt; exchanger=new Exchanger&lt;Integer&gt;();</span><br><span class=\"line\">\t new Thread()&#123;</span><br><span class=\"line\">\t\t @Override</span><br><span class=\"line\">\t\tpublic void run() &#123;</span><br><span class=\"line\">\t\t\t System.out.println(Thread.currentThread().getName()+ &quot;那谁，我要给你5块&quot;);</span><br><span class=\"line\">\t\t\t try &#123;</span><br><span class=\"line\">\t\t\t\tInteger exchange = exchanger.exchange(5);</span><br><span class=\"line\">\t\t\t\tSystem.out.println(Thread.currentThread().getName()+ &quot;收到：&quot;+exchange +&quot; 块 &quot;);</span><br><span class=\"line\">\t\t\t&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t &#125;.start();</span><br><span class=\"line\">\t </span><br><span class=\"line\">\t new Thread()&#123;</span><br><span class=\"line\">\t\t @Override</span><br><span class=\"line\">\t\tpublic void run() &#123;</span><br><span class=\"line\">\t\t\t System.out.println(Thread.currentThread().getName()+ &quot;那谁，我要找你1块&quot;);</span><br><span class=\"line\">\t\t\t try &#123;</span><br><span class=\"line\">\t\t\t\t Integer exchange = exchanger.exchange(1);</span><br><span class=\"line\">\t\t\t     System.out.println(Thread.currentThread().getName()+ &quot;收到：&quot;+exchange +&quot; 块 &quot;);</span><br><span class=\"line\">\t\t\t&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\t\t// TODO Auto-generated catch block</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t &#125;.start();</span><br><span class=\"line\">\t </span><br><span class=\"line\">\t </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>CyclicBarrier 用于多个线程都准备等待,当同时等待的线程达到规定数量后 所有线程自动唤醒运行。 （类似汽车票站<br>没有检够票数不发车）相比CountDownLatch,CyclicBarrier不需要其他线程来唤醒等待的线程.CyclicBarrier 的构造函数 等待线程数量<br>达到规定数量线程开始运行。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">\tCyclicBarrier cyclicBarrier=new CyclicBarrier(5);</span><br><span class=\"line\">\tfor(int i=0;i&lt;5;i++) &#123;</span><br><span class=\"line\">\t\t new Thread()&#123;</span><br><span class=\"line\">\t\t\t @Override</span><br><span class=\"line\">\t\t\tpublic void run() &#123;</span><br><span class=\"line\">\t\t\t\t try &#123;</span><br><span class=\"line\">\t\t\t\t\t cyclicBarrier.await();</span><br><span class=\"line\">\t\t\t\t\tThread.sleep((long) (Math.random()*1000));</span><br><span class=\"line\">\t\t\t\t\tSystem.out.println(Thread.currentThread().getName()+ &quot;:  开始跑啦&quot;);</span><br><span class=\"line\">\t\t\t\t&#125; catch (Exception e) &#123;</span><br><span class=\"line\">\t\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t &#125;.start();;</span><br><span class=\"line\">\t &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>CountDownLatch 用于多个线程都准备等待，接到命令后 统一运行（类似 赛跑比赛）CountDownLatch的构造函数中的数字表示等待者必须接到几次命令后<br>开始运行等待者待用调用countDownLatch.await()后开始阻塞发布命令者调用一次或多次countDownLatch.countDown()后唤醒等待者。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">\t final CountDownLatch countDownLatch=new CountDownLatch(1);</span><br><span class=\"line\">\t for(int i=0;i&lt;3;i++) &#123;</span><br><span class=\"line\">\t\t new Thread()&#123;</span><br><span class=\"line\">\t\t\t @Override</span><br><span class=\"line\">\t\t\tpublic void run() &#123;</span><br><span class=\"line\">\t\t\t\t try &#123;</span><br><span class=\"line\">\t\t\t\t\tcountDownLatch.await();</span><br><span class=\"line\">\t\t\t\t\tThread.sleep((long) (Math.random()*1000));</span><br><span class=\"line\">\t\t\t\t\tSystem.out.println(Thread.currentThread().getName()+ &quot;:  开始跑啦&quot;);</span><br><span class=\"line\">\t\t\t\t&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t &#125;.start();</span><br><span class=\"line\">\t &#125;</span><br><span class=\"line\">\t </span><br><span class=\"line\">\t Thread.sleep(2000);</span><br><span class=\"line\">\t System.out.println(Thread.currentThread().getName()+ &quot;:  准备&quot;);</span><br><span class=\"line\">\t countDownLatch.countDown();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-线程常用api\"><a href=\"#3-线程常用api\" class=\"headerlink\" title=\"3.线程常用api\"></a>3.线程常用api</h1><ol>\n<li>join()：线程的合并的含义就是将几个并行线程的线程合并为一个单线程执行，应用场景是当一个线程必须等待另一个线程执行完毕才能执行时可以使用join方法。</li>\n<li>yield(): 暂停当前正在执行的线程对象，并执行其他线程。（当前时间片）。</li>\n<li>interrupt():中断线程。</li>\n<li>sleep(long millis)：暂停执行(不会释放占有资源)。</li>\n</ol>\n<h1 id=\"4-线程池\"><a href=\"#4-线程池\" class=\"headerlink\" title=\"4.线程池\"></a>4.线程池</h1><h3 id=\"ThreadPoolExecutor\"><a href=\"#ThreadPoolExecutor\" class=\"headerlink\" title=\"ThreadPoolExecutor\"></a>ThreadPoolExecutor</h3><pre><code>1.ThreadPoolExecutor：ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue)\n    1.\t当线程池实际线程数小于corePoolSize时，有新的任务加入则优先创建线程。\n    2.\t当线程池实际线程数等于corePoolSize时，有新的任务加入则加入队列。\n    3.\t当线程池实际线程数等于corePoolSize时，有新的任务加入若队列已满，则在总线程数不大于maximumPoolSize的前提下，创建新的线程。\n    4.\t当线程池实际线程数等于maximumPoolSize，有新的任务加入则执行拒绝策略（默认抛异常）。可自定义拒绝策略 需实现RejectedExecutionHandler接口。\n    总结：所以关键点是： 队列是否会满若是无限队列（可能系统资源耗尽） ,maximumPoolSize是否会达到最大值。\n\n2.Executors工具提供四种线程池(基于 ThreadPoolExecutor )，分别为：\n    1.\tnewCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。\n    2.\tnewFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。\n    3.\tnewScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。\n    4.\tnewSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。\n</code></pre>\n<h1 id=\"5-Java死锁范例以及如何分析死锁\"><a href=\"#5-Java死锁范例以及如何分析死锁\" class=\"headerlink\" title=\"5.Java死锁范例以及如何分析死锁\"></a>5.Java死锁范例以及如何分析死锁</h1><h3 id=\"什么是死锁\"><a href=\"#什么是死锁\" class=\"headerlink\" title=\"什么是死锁\"></a>什么是死锁</h3><pre><code>1.死锁是这样一种情形：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放,而那个资源又不能被释放。导致线程被无限期地阻塞，因此程序不可能正常终止。(等待一个永远无法获取的资源)\n2.java 死锁产生的四个必要条件：\n    1、互斥使用，即当资源被一个线程使用(占有)时，别的线程不能使用\n    2、不可抢占，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放。\n    3、请求和保持，即当资源请求者在请求其他的资源的同时保持对原有资源的占有。\n    4、循环等待，即存在一个等待队列：P1占有P2的资源，P2占有P3的资源，P3占有P1的资源。这样就形成了一个等待环路。\n</code></pre>\n<h3 id=\"死锁方式\"><a href=\"#死锁方式\" class=\"headerlink\" title=\"死锁方式\"></a>死锁方式</h3><ol>\n<li></li>\n</ol>\n<p>第一种synchronized方式死锁：线程thread1先获取锁locka，然后在同步块里嵌套竞争锁lockb。而线程thread2先获取锁lockb，然后在同步块里嵌套竞争锁locka。此时已经被线程thread1拥有，而thread1在等待lockb，而lockb被thread2拥有，thread2在等待locka……无线循环。(<br>synchronized (locka){ …; synchronized (locka){…;} ….; } )</p>\n<ol start=\"2\">\n<li>第二种concurrent包Lock错误使用，导致死锁：释放锁使用地方不规范，导致死锁不能正常释放！ 应该在finally块里 lock.unlock();</li>\n</ol>\n<h3 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h3><ol>\n<li>修改代码才能从根本解决问题。</li>\n<li>检查问题代码<ol>\n<li>使用一些静态分析库可以帮助我们发现可能出现的死锁。</li>\n<li>它其中包含连个方法findDeadlockedThreads()和findMonitorDeadlockedThreads()，用来查找处于死锁。代码如下：thread1<br>和thread2 死锁状态。</li>\n</ol>\n</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">\tfinal Object lock1 = new Object();</span><br><span class=\"line\">\tfinal Object lock2 = new Object();</span><br><span class=\"line\"></span><br><span class=\"line\">\tThread thread1 = new Thread(new Runnable() &#123;</span><br><span class=\"line\">\t\t@Override</span><br><span class=\"line\">\t\tpublic void run() &#123;</span><br><span class=\"line\">\t\t\tsynchronized (lock1) &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(&quot;Thread1 acquired lock1&quot;);</span><br><span class=\"line\">\t\t\t\ttry &#123;</span><br><span class=\"line\">\t\t\t\t\tTimeUnit.MILLISECONDS.sleep(500);</span><br><span class=\"line\">\t\t\t\t&#125; catch (InterruptedException ignore) &#123;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tsynchronized (lock2) &#123;</span><br><span class=\"line\">\t\t\t\t\tSystem.out.println(&quot;Thread1 acquired lock2&quot;);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\tthread1.start();</span><br><span class=\"line\"></span><br><span class=\"line\">\tThread thread2 = new Thread(new Runnable() &#123;</span><br><span class=\"line\">\t\t@Override</span><br><span class=\"line\">\t\tpublic void run() &#123;</span><br><span class=\"line\">\t\t\tsynchronized (lock2) &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(&quot;Thread2 acquired lock2&quot;);</span><br><span class=\"line\">\t\t\t\tsynchronized (lock1) &#123;</span><br><span class=\"line\">\t\t\t\t\tSystem.out.println(&quot;Thread2 acquired lock1&quot;);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\tthread2.start();</span><br><span class=\"line\">\ttry &#123;</span><br><span class=\"line\">\t\tThread.sleep(20000);</span><br><span class=\"line\">\t&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t// TODO Auto-generated catch block</span><br><span class=\"line\">\t\te.printStackTrace();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tThread thread3 = new Thread(new Runnable() &#123;</span><br><span class=\"line\">\t\t@Override</span><br><span class=\"line\">\t\tpublic void run() &#123;</span><br><span class=\"line\">\t\t\tThreadMXBean mbean = ManagementFactory.getThreadMXBean();</span><br><span class=\"line\">\t\t\tlong[] findDeadlockedThreads = mbean.findDeadlockedThreads();</span><br><span class=\"line\">\t\t\tif (findDeadlockedThreads != null) &#123;</span><br><span class=\"line\">\t\t\t\tThreadInfo[] threadInfos = mbean.getThreadInfo(findDeadlockedThreads);</span><br><span class=\"line\">\t\t\t\tfor (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class=\"line\">\t\t\t\t\t//获取线程</span><br><span class=\"line\">\t\t\t\t\tfor (Thread thread : Thread.getAllStackTraces().keySet()) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tif (thread.getId() == threadInfo.getThreadId()) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\tSystem.err.println(threadInfo.toString().trim());</span><br><span class=\"line\">\t\t\t\t\t\t\tfor (StackTraceElement ste : thread.getStackTrace()) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\tSystem.err.println(&quot;t&quot; + ste.toString().trim());</span><br><span class=\"line\">\t\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\tthread3.start();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"mysql存储过程","date":"2016-08-12T01:00:00.000Z","_content":"\n## 存储过程简介\n\n1. SQL语句需要先编译然后执行，而存储过程（Stored\n   Procedure）是一组为了完成特定功能的SQL语句集，经编译后存储在数据库中，用户通过指定存储过程的名字并给定参数（如果该存储过程带有参数）来调用执行它。\n\n2. 存储过程是可编程的函数，在数据库中创建并保存，可以由SQL语句和控制结构组成。当想要在不同的应用程序或平台上执行相同的函数，或者封装特定功能时，存储过程是非常有用的。\n\n## 存储过程的优点\n\n1. 增强SQL语言的功能和灵活性：存储过程可以用控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。\n\n2. 标准组件式编程：存储过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的SQL语句。减小程序业务的复杂性，在一定程度上降低了程序的耦合性。\n\n3.\n\n较快的执行速度：如果某一操作包含大量的Transaction-SQL代码或分别被多次执行，那么存储过程要比批处理的执行速度快很多。因为存储过程是预编译的。在首次运行一个存储过程时查询，优化器对其进行分析优化，并且给出最终被存储在系统表中的执行计划。而批处理的Transaction-SQL语句在每次运行时都要进行编译和优化，速度相对要慢一些。\n\n4. 减少网络流量：针对同一个数据库对象的操作（如查询、修改），如果这一操作所涉及的Transaction-SQL语句被组织进存储过程，那么当在客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而大大减少网络流量并降低了网络负载。\n\n5. 作为一种安全机制来充分利用：通过对执行某一存储过程的权限进行限制，能够实现对相应的数据的访问权限的限制，避免了非授权用户对数据的访问，保证了数据的安全。\n   不同的排序算法性质有所不同，衡量算法的效率，通常是用资源，例如`CPU`(时间)占用、内存占用、硬盘占用和网络占用。当讨论大`O`\n   表示法时，一般考虑的是`CPU`占用。\n\n## MySQL存储过程的\n\n**`语法`**\n> \tDELIMITER $$\n\n\tCREATE PROCEDURE  过程名([[IN|OUT|INOUT] 参数名 数据类型[,[IN|OUT|INOUT] 参数名 数据类型…]]) [特性 ...] 过程体\n\tDELIMITER ;\n\n**`分隔符`**\n> 所以要事先用“DELIMITER $$”声明当前段分隔符，让编译器把两个\"$$\"\n> 之间的内容当做存储过程的代码，不会执行这些代码；“DELIMITER;”的意为把分隔符还原。BEGIN ...\n> END之间是我们要编写的部分。MySQL默认以\";\"为分隔符，如果没有声明分割符，则编译器会把存储过程当成SQL语句进行处理，因此编译过程会报错。\n\n**`参数`**\n> 存储过程根据需要可能会有输入、输出、输入输出参数，如果有多个参数用\",\"\n> 分割开。MySQL存储过程的参数用在存储过程的定义，共有三种参数类型,IN,OUT,INOUT:\n\n- IN参数的值必须在调用存储过程时指定，在存储过程中修改该参数的值不能被返回，为默认值\n- OUT:该值可在存储过程内部被改变，并可返回\n- INOUT:调用时指定，并且可被改变和返回\n\n**`过程体`**\n> 过程体的开始与结束使用BEGIN与END进行标识。\n\n**`IN参数例子`**\n\n> \tDELIMITER $$\n\n\tCREATE\n\t    PROCEDURE p_in(IN parm_in INT)\n\t    BEGIN\n\t\t\tSELECT parm_in;#若注掉 结果：5\n\t\t    SET parm_in=5;\n\t\t    SELECT parm_in;\n\t    END$$\n\tDELIMITER ;\n\n调用\nSET @p_in=1;\nCALL p_in(@p_in);\nSELECT @p_in;\n结果：5\n\n**`OUT参数例子`**\n> \tDELIMITER $$\n\n\tCREATE\n\t    PROCEDURE p_out(IN parm_out INT)\n\t    BEGIN\n\t    SELECT parm_out;#若注掉 结果：5\n\t    SET parm_out=5;\n\t    SELECT parm_out;\n\t    END$$\n\tDELIMITER ;\n\n调用\nSET @p_out=1;\nCALL p_out(@p_out);\nSELECT @p_out;\n结果：1\n\n**`INOUT参数例子`**\n\n> DELIMITER $$\n> CREATE\n> PROCEDURE p_in_out(IN parm_in_out INT)\n> BEGIN\n> SELECT parm_in_out; #若注掉 结果：5\n> SET parm_in_out=5;\n> SELECT parm_in_out;\n> END$$\n> DELIMITER ;\n> 调用\n> SET @p_in_out=1;\n> CALL p_in_out(@p_in_out);\n> SELECT @p_in_out;\n> 结果：1\n\n**`动态拼接sql例子`**\n> DELIMITER $$\n> DROP PROCEDURE IF EXISTS dsql $$\n> CREATE PROCEDURE dsql(IN parameter INT,IN name1 VARCHAR(64))\n> BEGIN\n> SET @sql1='SELECT * FROM t_user u WHERE 1=1';\n> IF parameter IS NOT NULL THEN\n> SET @sql1= CONCAT(@sql1,' and u.id = ',parameter);\n> END IF ;\n> IF (name1 IS NOT NULL AND name1!='') THEN\n> SET @sql1= CONCAT(@sql1,' and u.name LIKE\\'%',name1,'%\\'');\n> END IF ;\n> PREPARE stmt FROM @sql1;\n> EXECUTE stmt;\n> END$$\n> DELIMITER ;\n\n**`实际例子`**\n> DELIMITER $$\n> DROP PROCEDURE IF EXISTS ckm $$\n> CREATE\n> PROCEDURE ckm(IN t1 INT)\n> BEGIN\n> DECLARE u_time TIMESTAMP;\n> SELECT t.update_time INTO u_time FROM tx_msg_task t ;\n> UPDATE tx_msg_task SET update_time=NOW();\n> DELETE uk FROM tx_msg_uk uk INNER JOIN tx_msg_hc h ON uk.msg_key=h.msg_key;\n\n\t\tPREPARE sql1 FROM 'SELECT * FROM tx_msg_uk u  WHERE DATE_SUB(NOW(),INTERVAL ? MINUTE) >=u.update_time';\n\t\tSET @a = t1;\n\t\tEXECUTE sql1 USING @a;#多个可以，分割\n\t\tDEALLOCATE PREPARE sql1;#清理资源\n\t    END$$\n\tDELIMITER ; \n\n## MySQL存储过程的调用\n\n\t用call和过程名以及一个括号，括号里面根据需要，加入参数，参数包括输入参数、输出参数、输入输出参数。CALL\n\n## MySQL存储过程的查询\n\n\tSELECT name FROM mysql.proc WHERE db='数据库名';\n\tSELECT routine_name FROM information_schema.routines WHERE routine_schema='数据库名';\n\tSHOW PROCEDURE STATUS WHERE db='数据库名';\n\n## MySQL存储过程的删除\n\n\tDROP PROCEDURE [过程1[,过程2…]]\n\t从MySQL的表格中删除一个或多个存储过程。\n\n## 存储程序中的变量\n\n1. DECLARE局部变量 DECLARE var_name[,...] type [DEFAULT value]<br>\n   这个语句被用来声明局部变量。 要给变量提供一个默认值，请包含一个DEFAULT子句。值可以被指定为一个表达式，不需要为一个常数。如果没有DEFAULT子句，初始值为NULL。\n   局部变量的作用范围在它被声明的BEGIN ... END块内。它可以被用在嵌套的块中，除了那些用相同名字声明变量的块。\n2. 变量SET语句 SET var_name = expr [, var_name = expr]<br>\n   在存储程序中的SET语句是一般SET语句的扩展版本。被参考变量可能是子程序内声明的变量，或者是全局服务器变量。\n   在存储程序中的SET语句作为预先存在的SET语法的一部分来实现。这允许SET a=x, b=y,\n   ...这样的扩展语法。其中不同的变量类型（局域声明变量及全局和集体变量）可以被混合起来。这也允许把局部变量和一些只对系统变量有意义的选项合并起来。\n3. SELECT ... INTO<br>\n   SELECT col_name[,...] INTO var_name[,...] table_expr这个SELECT语法把选定的列直接存储到变量。因此，只有单一的行可以被取回。\n   SELECT id,data INTO x,y FROM test.t1 LIMIT 1;\n\n列子：\n\n\tSELECT 'Hello World' INTO @a;\n\tSELECT @a;\n\t\n\tSET @b='Hello World';\n\tSELECT @b;\n\t\n\tSET @c=1+2+3;\n\tSELECT @c; \n\t\n\t#在存储过程中使用用户变量\n\tCREATE PROCEDURE sayHi() SELECT CONCAT(@hi,'...');\n\tSET @hi='hi';\n\tCALL sayHi(); \n\t#在存储过程间传递全局范围的用户变量\n\tCREATE PROCEDURE tp1() SET @param='p1';\n\tCREATE PROCEDURE tp2() SELECT CONCAT('param... ',@param);\n\tCALL tp1();\n\tCALL tp2(); \n\n## MySQL存储过程的控制语句\n\n1. 变量作用域: 内部变量在其作用域范围内享有更高的优先权，当执行到end时，内部变量消失，不再可见了，在存储\n   过程外再也找不到这个内部变量，但是可以通过out参数或者将其值指派给会话变量来保存其值。\n\n> DELIMITER $$\n> DROP PROCEDURE IF EXISTS `proc`$$\n> CREATE PROCEDURE proc()\n> BEGIN\n> DECLARE x1 VARCHAR(5) DEFAULT 'outer';\n> BEGIN\n> DECLARE x1 VARCHAR(5) DEFAULT 'inner';\n> SELECT x1;\n> END;\n> SELECT x1;\n> END$$\n> DELIMITER ;\n> #调用\n> CALL proc();\n> 结果：inner\n\n2. 条件语句 IF-THEN-ELSE\n\n> DROP PROCEDURE IF EXISTS proc3 ;\n> DELIMITER $$\n> CREATE PROCEDURE proc3(IN parameter INT)\n> BEGIN\n> DECLARE var INT;\n> SET var=parameter+1;\n> IF var=0 THEN\n> INSERT INTO t VALUES (17);\n> END IF ;\n> IF parameter=0 THEN\n> UPDATE t SET s1=s1+1;\n> ELSE\n> UPDATE t SET s1=s1+2;\n> END IF ;\n> END$$\n> DELIMITER ;\n\n3. CASE-WHEN-THEN-ELSE语句\n\n> DELIMITER $$\n> CREATE PROCEDURE proc4 (IN parameter INT)\n> BEGIN\n> DECLARE var INT;\n> SET var=parameter+1;\n> CASE var\n> WHEN 0 THEN\n> INSERT INTO t VALUES (17);\n> WHEN 1 THEN\n> INSERT INTO t VALUES (18);\n> ELSE\n> INSERT INTO t VALUES (19);\n> END CASE ;\n> END$$\n> DELIMITER;\n\n4. 循环语句 WHILE-DO…END-WHILE\n\n> DELIMITER $$\n> CREATE PROCEDURE proc5()\n> BEGIN\n> DECLARE var INT;\n> SET var=0;\n> WHILE var<6 DO\n> INSERT INTO t VALUES (var);\n> SET var=var+1;\n> END WHILE ;\n> END$$\n> DELIMITER;\n\n5. REPEAT...END REPEAT 此语句的特点是执行操作后检查结果\n\n> DELIMITER $$\n> CREATE PROCEDURE proc6 ()\n> BEGIN\n> DECLARE v INT;\n> SET v=0;\n> REPEAT\n> INSERT INTO t VALUES(v);\n> SET v=v+1;\n> UNTIL v>=5\n> END REPEAT;\n> END$$\n> DELIMITER ;\n\n6. LOOP...END LOOP\n\n> DELIMITER $$\n> CREATE PROCEDURE proc7 ()\n> BEGIN\n> DECLARE v INT;\n> SET v=0;\n> LOOP_LABLE:LOOP\n> INSERT INTO t VALUES(v);\n> SET v=v+1;\n> IF v >=5 THEN\n> LEAVE LOOP_LABLE;\n> END IF;\n> END LOOP;\n> END$$\n> DELIMITER ;\n\n7. LABLES标号:标号可以用在begin repeat while 或者loop 语句前，语句标号只能在合法的语句前面使用。可以跳出循环，使运行指令达到复合语句的最后一步。\n\n8. ITERATE迭代通过引用复合语句的标号,来从新开始复合语句\n\n> DELIMITER $$\n> CREATE PROCEDURE proc8()\n> BEGIN\n> DECLARE v INT;\n> SET v=0;\n> LOOP_LABLE:LOOP\n> IF v=3 THEN\n> SET v=v+1;\n> ITERATE LOOP_LABLE;\n> END IF;\n> INSERT INTO t VALUES(v);\n> SET v=v+1;\n> IF v>=5 THEN\n> LEAVE LOOP_LABLE;\n> END IF;\n> END LOOP;\n> END$$\n> DELIMITER ;\n\n## MySQL存储过程的基本函数\n\n1. 字符串类\n   > CHARSET(str) //返回字串字符集\n   CONCAT (string2 [,... ]) //连接字串\n   INSTR (string ,substring ) //返回substring首次在string中出现的位置,不存在返回0\n   LCASE (string2 ) //转换成小写\n   LEFT (string2 ,length ) //从string2中的左边起取length个字符\n   LENGTH (string ) //string长度\n   LOAD_FILE (file_name ) //从文件读取内容\n   LOCATE (substring , string [,start_position ] ) 同INSTR,但可指定开始位置\n   LPAD (string2 ,length ,pad ) //重复用pad加在string开头,直到字串长度为length\n   LTRIM (string2 ) //去除前端空格\n   REPEAT (string2 ,count ) //重复count次\n   REPLACE (str ,search_str ,replace_str ) //在str中用replace_str替换search_str\n   RPAD (string2 ,length ,pad) //在str后用pad补充,直到长度为length\n   RTRIM (string2 ) //去除后端空格\n   STRCMP (string1 ,string2 ) //逐字符比较两字串大小,\n   SUBSTRING (str , position [,length ]) //从str的position开始,取length个字符,\n   TRIM([[BOTH|LEADING|TRAILING] [padding] FROM]string2) //去除指定位置的指定字符\n   UCASE (string2 ) //转换成大写\n   RIGHT(string2,length) //取string2最后length个字符\n   SPACE(count) //生成count个空格\n   注：mysql中处理字符串时，默认第一个字符下标为1，即参数position必须大于等于1\n2. 数学类\n   > ABS (number2 ) //绝对值\n   BIN (decimal_number ) //十进制转二进制\n   CEILING (number2 ) //向上取整\n   CONV(number2,from_base,to_base) //进制转换\n   FLOOR (number2 ) //向下取整\n   FORMAT (number,decimal_places ) //保留小数位数\n   HEX (DecimalNumber ) //转十六进制\n   注：HEX()中可传入字符串，则返回其ASC-11码，如HEX('DEF')返回4142143\n   也可以传入十进制整数，返回其十六进制编码，如HEX(25)返回19\n   LEAST (number , number2 [,..]) //求最小值\n   MOD (numerator ,denominator ) //求余\n   POWER (number ,power ) //求指数\n   RAND([seed]) //随机数\n   ROUND (number [,decimals ]) //四舍五入,decimals为小数位数] 注：返回类型并非均为整数，如：\n   SIGN (number2 ) // 正数返回1，负数返回-1\n   MINUTE(datetime) //分返回符号,正负或0\n   SQRT(number2) //开平方\n\n3. 日期时间类\n   > ADDTIME (date2 ,time_interval ) //将time_interval加到date2\n   CONVERT_TZ (datetime2 ,fromTZ ,toTZ ) //转换时区\n   CURRENT_DATE ( ) //当前日期\n   CURRENT_TIME ( ) //当前时间\n   CURRENT_TIMESTAMP ( ) //当前时间戳\n   DATE (datetime ) //返回datetime的日期部分\n   DATE_ADD (date2 , INTERVAL d_value d_type ) //在date2中加上日期或时间\n   DATE_FORMAT (datetime ,FormatCodes ) //使用formatcodes格式显示datetime\n   DATE_SUB (date2 , INTERVAL d_value d_type ) //在date2上减去一个时间\n   DATEDIFF (date1 ,date2 ) //两个日期差\n   DAY (date ) //返回日期的天\n   DAYNAME (date ) //英文星期\n   DAYOFWEEK (date ) //星期(1-7) ,1为星期天\n   DAYOFYEAR (date ) //一年中的第几天\n   EXTRACT (interval_name FROM date ) //从date中提取日期的指定部分\n   MAKEDATE (year ,day ) //给出年及年中的第几天,生成日期串\n   MAKETIME (hour ,minute ,second ) //生成时间串\n   MONTHNAME (date ) //英文月份名\n   NOW ( ) //当前时间\n   SEC_TO_TIME (seconds ) //秒数转成时间\n   STR_TO_DATE (string ,format ) //字串转成时间,以format格式显示\n   TIMEDIFF (datetime1 ,datetime2 ) //两个时间差\n   TIME_TO_SEC (time ) //时间转秒数]\n   WEEK (date_time [,start_of_week ]) //第几周\n   YEAR (datetime ) //年份\n   DAYOFMONTH(datetime) //月的第几天\n   HOUR(datetime) //小时\n   LAST_DAY(date) //date的月的最后日期\n   MICROSECOND(datetime) //微秒\n   MONTH(datetime) //月\n\n<!--http://www.cnblogs.com/mark-chan/p/5384139.html-->\n\n## 注释\n\n\t单行：--或 #\n\t多行：/*  */ \n\n## mybatis调用存储过程\n\n\t<select id=\"proFindUser\" resultMap=\"BaseResultMap\" statementType=\"CALLABLE\">\n\t\t{\n\t\t\tCALL find_user(#{uid,mode=IN,jdbcType=BIGINT},#{name,mode=IN,jdbcType=VARCHAR})\n\t\t}\n\t</select>","source":"_posts/mysql存储过程.md","raw":"---\ntitle: \"mysql存储过程\"\ndate: 2016-08-12 09:00:00\ncategories: 数据库\ntags:\n\t- mysql\n---\n\n## 存储过程简介\n\n1. SQL语句需要先编译然后执行，而存储过程（Stored\n   Procedure）是一组为了完成特定功能的SQL语句集，经编译后存储在数据库中，用户通过指定存储过程的名字并给定参数（如果该存储过程带有参数）来调用执行它。\n\n2. 存储过程是可编程的函数，在数据库中创建并保存，可以由SQL语句和控制结构组成。当想要在不同的应用程序或平台上执行相同的函数，或者封装特定功能时，存储过程是非常有用的。\n\n## 存储过程的优点\n\n1. 增强SQL语言的功能和灵活性：存储过程可以用控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。\n\n2. 标准组件式编程：存储过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的SQL语句。减小程序业务的复杂性，在一定程度上降低了程序的耦合性。\n\n3.\n\n较快的执行速度：如果某一操作包含大量的Transaction-SQL代码或分别被多次执行，那么存储过程要比批处理的执行速度快很多。因为存储过程是预编译的。在首次运行一个存储过程时查询，优化器对其进行分析优化，并且给出最终被存储在系统表中的执行计划。而批处理的Transaction-SQL语句在每次运行时都要进行编译和优化，速度相对要慢一些。\n\n4. 减少网络流量：针对同一个数据库对象的操作（如查询、修改），如果这一操作所涉及的Transaction-SQL语句被组织进存储过程，那么当在客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而大大减少网络流量并降低了网络负载。\n\n5. 作为一种安全机制来充分利用：通过对执行某一存储过程的权限进行限制，能够实现对相应的数据的访问权限的限制，避免了非授权用户对数据的访问，保证了数据的安全。\n   不同的排序算法性质有所不同，衡量算法的效率，通常是用资源，例如`CPU`(时间)占用、内存占用、硬盘占用和网络占用。当讨论大`O`\n   表示法时，一般考虑的是`CPU`占用。\n\n## MySQL存储过程的\n\n**`语法`**\n> \tDELIMITER $$\n\n\tCREATE PROCEDURE  过程名([[IN|OUT|INOUT] 参数名 数据类型[,[IN|OUT|INOUT] 参数名 数据类型…]]) [特性 ...] 过程体\n\tDELIMITER ;\n\n**`分隔符`**\n> 所以要事先用“DELIMITER $$”声明当前段分隔符，让编译器把两个\"$$\"\n> 之间的内容当做存储过程的代码，不会执行这些代码；“DELIMITER;”的意为把分隔符还原。BEGIN ...\n> END之间是我们要编写的部分。MySQL默认以\";\"为分隔符，如果没有声明分割符，则编译器会把存储过程当成SQL语句进行处理，因此编译过程会报错。\n\n**`参数`**\n> 存储过程根据需要可能会有输入、输出、输入输出参数，如果有多个参数用\",\"\n> 分割开。MySQL存储过程的参数用在存储过程的定义，共有三种参数类型,IN,OUT,INOUT:\n\n- IN参数的值必须在调用存储过程时指定，在存储过程中修改该参数的值不能被返回，为默认值\n- OUT:该值可在存储过程内部被改变，并可返回\n- INOUT:调用时指定，并且可被改变和返回\n\n**`过程体`**\n> 过程体的开始与结束使用BEGIN与END进行标识。\n\n**`IN参数例子`**\n\n> \tDELIMITER $$\n\n\tCREATE\n\t    PROCEDURE p_in(IN parm_in INT)\n\t    BEGIN\n\t\t\tSELECT parm_in;#若注掉 结果：5\n\t\t    SET parm_in=5;\n\t\t    SELECT parm_in;\n\t    END$$\n\tDELIMITER ;\n\n调用\nSET @p_in=1;\nCALL p_in(@p_in);\nSELECT @p_in;\n结果：5\n\n**`OUT参数例子`**\n> \tDELIMITER $$\n\n\tCREATE\n\t    PROCEDURE p_out(IN parm_out INT)\n\t    BEGIN\n\t    SELECT parm_out;#若注掉 结果：5\n\t    SET parm_out=5;\n\t    SELECT parm_out;\n\t    END$$\n\tDELIMITER ;\n\n调用\nSET @p_out=1;\nCALL p_out(@p_out);\nSELECT @p_out;\n结果：1\n\n**`INOUT参数例子`**\n\n> DELIMITER $$\n> CREATE\n> PROCEDURE p_in_out(IN parm_in_out INT)\n> BEGIN\n> SELECT parm_in_out; #若注掉 结果：5\n> SET parm_in_out=5;\n> SELECT parm_in_out;\n> END$$\n> DELIMITER ;\n> 调用\n> SET @p_in_out=1;\n> CALL p_in_out(@p_in_out);\n> SELECT @p_in_out;\n> 结果：1\n\n**`动态拼接sql例子`**\n> DELIMITER $$\n> DROP PROCEDURE IF EXISTS dsql $$\n> CREATE PROCEDURE dsql(IN parameter INT,IN name1 VARCHAR(64))\n> BEGIN\n> SET @sql1='SELECT * FROM t_user u WHERE 1=1';\n> IF parameter IS NOT NULL THEN\n> SET @sql1= CONCAT(@sql1,' and u.id = ',parameter);\n> END IF ;\n> IF (name1 IS NOT NULL AND name1!='') THEN\n> SET @sql1= CONCAT(@sql1,' and u.name LIKE\\'%',name1,'%\\'');\n> END IF ;\n> PREPARE stmt FROM @sql1;\n> EXECUTE stmt;\n> END$$\n> DELIMITER ;\n\n**`实际例子`**\n> DELIMITER $$\n> DROP PROCEDURE IF EXISTS ckm $$\n> CREATE\n> PROCEDURE ckm(IN t1 INT)\n> BEGIN\n> DECLARE u_time TIMESTAMP;\n> SELECT t.update_time INTO u_time FROM tx_msg_task t ;\n> UPDATE tx_msg_task SET update_time=NOW();\n> DELETE uk FROM tx_msg_uk uk INNER JOIN tx_msg_hc h ON uk.msg_key=h.msg_key;\n\n\t\tPREPARE sql1 FROM 'SELECT * FROM tx_msg_uk u  WHERE DATE_SUB(NOW(),INTERVAL ? MINUTE) >=u.update_time';\n\t\tSET @a = t1;\n\t\tEXECUTE sql1 USING @a;#多个可以，分割\n\t\tDEALLOCATE PREPARE sql1;#清理资源\n\t    END$$\n\tDELIMITER ; \n\n## MySQL存储过程的调用\n\n\t用call和过程名以及一个括号，括号里面根据需要，加入参数，参数包括输入参数、输出参数、输入输出参数。CALL\n\n## MySQL存储过程的查询\n\n\tSELECT name FROM mysql.proc WHERE db='数据库名';\n\tSELECT routine_name FROM information_schema.routines WHERE routine_schema='数据库名';\n\tSHOW PROCEDURE STATUS WHERE db='数据库名';\n\n## MySQL存储过程的删除\n\n\tDROP PROCEDURE [过程1[,过程2…]]\n\t从MySQL的表格中删除一个或多个存储过程。\n\n## 存储程序中的变量\n\n1. DECLARE局部变量 DECLARE var_name[,...] type [DEFAULT value]<br>\n   这个语句被用来声明局部变量。 要给变量提供一个默认值，请包含一个DEFAULT子句。值可以被指定为一个表达式，不需要为一个常数。如果没有DEFAULT子句，初始值为NULL。\n   局部变量的作用范围在它被声明的BEGIN ... END块内。它可以被用在嵌套的块中，除了那些用相同名字声明变量的块。\n2. 变量SET语句 SET var_name = expr [, var_name = expr]<br>\n   在存储程序中的SET语句是一般SET语句的扩展版本。被参考变量可能是子程序内声明的变量，或者是全局服务器变量。\n   在存储程序中的SET语句作为预先存在的SET语法的一部分来实现。这允许SET a=x, b=y,\n   ...这样的扩展语法。其中不同的变量类型（局域声明变量及全局和集体变量）可以被混合起来。这也允许把局部变量和一些只对系统变量有意义的选项合并起来。\n3. SELECT ... INTO<br>\n   SELECT col_name[,...] INTO var_name[,...] table_expr这个SELECT语法把选定的列直接存储到变量。因此，只有单一的行可以被取回。\n   SELECT id,data INTO x,y FROM test.t1 LIMIT 1;\n\n列子：\n\n\tSELECT 'Hello World' INTO @a;\n\tSELECT @a;\n\t\n\tSET @b='Hello World';\n\tSELECT @b;\n\t\n\tSET @c=1+2+3;\n\tSELECT @c; \n\t\n\t#在存储过程中使用用户变量\n\tCREATE PROCEDURE sayHi() SELECT CONCAT(@hi,'...');\n\tSET @hi='hi';\n\tCALL sayHi(); \n\t#在存储过程间传递全局范围的用户变量\n\tCREATE PROCEDURE tp1() SET @param='p1';\n\tCREATE PROCEDURE tp2() SELECT CONCAT('param... ',@param);\n\tCALL tp1();\n\tCALL tp2(); \n\n## MySQL存储过程的控制语句\n\n1. 变量作用域: 内部变量在其作用域范围内享有更高的优先权，当执行到end时，内部变量消失，不再可见了，在存储\n   过程外再也找不到这个内部变量，但是可以通过out参数或者将其值指派给会话变量来保存其值。\n\n> DELIMITER $$\n> DROP PROCEDURE IF EXISTS `proc`$$\n> CREATE PROCEDURE proc()\n> BEGIN\n> DECLARE x1 VARCHAR(5) DEFAULT 'outer';\n> BEGIN\n> DECLARE x1 VARCHAR(5) DEFAULT 'inner';\n> SELECT x1;\n> END;\n> SELECT x1;\n> END$$\n> DELIMITER ;\n> #调用\n> CALL proc();\n> 结果：inner\n\n2. 条件语句 IF-THEN-ELSE\n\n> DROP PROCEDURE IF EXISTS proc3 ;\n> DELIMITER $$\n> CREATE PROCEDURE proc3(IN parameter INT)\n> BEGIN\n> DECLARE var INT;\n> SET var=parameter+1;\n> IF var=0 THEN\n> INSERT INTO t VALUES (17);\n> END IF ;\n> IF parameter=0 THEN\n> UPDATE t SET s1=s1+1;\n> ELSE\n> UPDATE t SET s1=s1+2;\n> END IF ;\n> END$$\n> DELIMITER ;\n\n3. CASE-WHEN-THEN-ELSE语句\n\n> DELIMITER $$\n> CREATE PROCEDURE proc4 (IN parameter INT)\n> BEGIN\n> DECLARE var INT;\n> SET var=parameter+1;\n> CASE var\n> WHEN 0 THEN\n> INSERT INTO t VALUES (17);\n> WHEN 1 THEN\n> INSERT INTO t VALUES (18);\n> ELSE\n> INSERT INTO t VALUES (19);\n> END CASE ;\n> END$$\n> DELIMITER;\n\n4. 循环语句 WHILE-DO…END-WHILE\n\n> DELIMITER $$\n> CREATE PROCEDURE proc5()\n> BEGIN\n> DECLARE var INT;\n> SET var=0;\n> WHILE var<6 DO\n> INSERT INTO t VALUES (var);\n> SET var=var+1;\n> END WHILE ;\n> END$$\n> DELIMITER;\n\n5. REPEAT...END REPEAT 此语句的特点是执行操作后检查结果\n\n> DELIMITER $$\n> CREATE PROCEDURE proc6 ()\n> BEGIN\n> DECLARE v INT;\n> SET v=0;\n> REPEAT\n> INSERT INTO t VALUES(v);\n> SET v=v+1;\n> UNTIL v>=5\n> END REPEAT;\n> END$$\n> DELIMITER ;\n\n6. LOOP...END LOOP\n\n> DELIMITER $$\n> CREATE PROCEDURE proc7 ()\n> BEGIN\n> DECLARE v INT;\n> SET v=0;\n> LOOP_LABLE:LOOP\n> INSERT INTO t VALUES(v);\n> SET v=v+1;\n> IF v >=5 THEN\n> LEAVE LOOP_LABLE;\n> END IF;\n> END LOOP;\n> END$$\n> DELIMITER ;\n\n7. LABLES标号:标号可以用在begin repeat while 或者loop 语句前，语句标号只能在合法的语句前面使用。可以跳出循环，使运行指令达到复合语句的最后一步。\n\n8. ITERATE迭代通过引用复合语句的标号,来从新开始复合语句\n\n> DELIMITER $$\n> CREATE PROCEDURE proc8()\n> BEGIN\n> DECLARE v INT;\n> SET v=0;\n> LOOP_LABLE:LOOP\n> IF v=3 THEN\n> SET v=v+1;\n> ITERATE LOOP_LABLE;\n> END IF;\n> INSERT INTO t VALUES(v);\n> SET v=v+1;\n> IF v>=5 THEN\n> LEAVE LOOP_LABLE;\n> END IF;\n> END LOOP;\n> END$$\n> DELIMITER ;\n\n## MySQL存储过程的基本函数\n\n1. 字符串类\n   > CHARSET(str) //返回字串字符集\n   CONCAT (string2 [,... ]) //连接字串\n   INSTR (string ,substring ) //返回substring首次在string中出现的位置,不存在返回0\n   LCASE (string2 ) //转换成小写\n   LEFT (string2 ,length ) //从string2中的左边起取length个字符\n   LENGTH (string ) //string长度\n   LOAD_FILE (file_name ) //从文件读取内容\n   LOCATE (substring , string [,start_position ] ) 同INSTR,但可指定开始位置\n   LPAD (string2 ,length ,pad ) //重复用pad加在string开头,直到字串长度为length\n   LTRIM (string2 ) //去除前端空格\n   REPEAT (string2 ,count ) //重复count次\n   REPLACE (str ,search_str ,replace_str ) //在str中用replace_str替换search_str\n   RPAD (string2 ,length ,pad) //在str后用pad补充,直到长度为length\n   RTRIM (string2 ) //去除后端空格\n   STRCMP (string1 ,string2 ) //逐字符比较两字串大小,\n   SUBSTRING (str , position [,length ]) //从str的position开始,取length个字符,\n   TRIM([[BOTH|LEADING|TRAILING] [padding] FROM]string2) //去除指定位置的指定字符\n   UCASE (string2 ) //转换成大写\n   RIGHT(string2,length) //取string2最后length个字符\n   SPACE(count) //生成count个空格\n   注：mysql中处理字符串时，默认第一个字符下标为1，即参数position必须大于等于1\n2. 数学类\n   > ABS (number2 ) //绝对值\n   BIN (decimal_number ) //十进制转二进制\n   CEILING (number2 ) //向上取整\n   CONV(number2,from_base,to_base) //进制转换\n   FLOOR (number2 ) //向下取整\n   FORMAT (number,decimal_places ) //保留小数位数\n   HEX (DecimalNumber ) //转十六进制\n   注：HEX()中可传入字符串，则返回其ASC-11码，如HEX('DEF')返回4142143\n   也可以传入十进制整数，返回其十六进制编码，如HEX(25)返回19\n   LEAST (number , number2 [,..]) //求最小值\n   MOD (numerator ,denominator ) //求余\n   POWER (number ,power ) //求指数\n   RAND([seed]) //随机数\n   ROUND (number [,decimals ]) //四舍五入,decimals为小数位数] 注：返回类型并非均为整数，如：\n   SIGN (number2 ) // 正数返回1，负数返回-1\n   MINUTE(datetime) //分返回符号,正负或0\n   SQRT(number2) //开平方\n\n3. 日期时间类\n   > ADDTIME (date2 ,time_interval ) //将time_interval加到date2\n   CONVERT_TZ (datetime2 ,fromTZ ,toTZ ) //转换时区\n   CURRENT_DATE ( ) //当前日期\n   CURRENT_TIME ( ) //当前时间\n   CURRENT_TIMESTAMP ( ) //当前时间戳\n   DATE (datetime ) //返回datetime的日期部分\n   DATE_ADD (date2 , INTERVAL d_value d_type ) //在date2中加上日期或时间\n   DATE_FORMAT (datetime ,FormatCodes ) //使用formatcodes格式显示datetime\n   DATE_SUB (date2 , INTERVAL d_value d_type ) //在date2上减去一个时间\n   DATEDIFF (date1 ,date2 ) //两个日期差\n   DAY (date ) //返回日期的天\n   DAYNAME (date ) //英文星期\n   DAYOFWEEK (date ) //星期(1-7) ,1为星期天\n   DAYOFYEAR (date ) //一年中的第几天\n   EXTRACT (interval_name FROM date ) //从date中提取日期的指定部分\n   MAKEDATE (year ,day ) //给出年及年中的第几天,生成日期串\n   MAKETIME (hour ,minute ,second ) //生成时间串\n   MONTHNAME (date ) //英文月份名\n   NOW ( ) //当前时间\n   SEC_TO_TIME (seconds ) //秒数转成时间\n   STR_TO_DATE (string ,format ) //字串转成时间,以format格式显示\n   TIMEDIFF (datetime1 ,datetime2 ) //两个时间差\n   TIME_TO_SEC (time ) //时间转秒数]\n   WEEK (date_time [,start_of_week ]) //第几周\n   YEAR (datetime ) //年份\n   DAYOFMONTH(datetime) //月的第几天\n   HOUR(datetime) //小时\n   LAST_DAY(date) //date的月的最后日期\n   MICROSECOND(datetime) //微秒\n   MONTH(datetime) //月\n\n<!--http://www.cnblogs.com/mark-chan/p/5384139.html-->\n\n## 注释\n\n\t单行：--或 #\n\t多行：/*  */ \n\n## mybatis调用存储过程\n\n\t<select id=\"proFindUser\" resultMap=\"BaseResultMap\" statementType=\"CALLABLE\">\n\t\t{\n\t\t\tCALL find_user(#{uid,mode=IN,jdbcType=BIGINT},#{name,mode=IN,jdbcType=VARCHAR})\n\t\t}\n\t</select>","slug":"mysql存储过程","published":1,"updated":"2024-11-27T03:20:35.291Z","_id":"cm3zaz9c6000ltgu6cdqk7y1i","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"存储过程简介\"><a href=\"#存储过程简介\" class=\"headerlink\" title=\"存储过程简介\"></a>存储过程简介</h2><ol>\n<li><p>SQL语句需要先编译然后执行，而存储过程（Stored<br>Procedure）是一组为了完成特定功能的SQL语句集，经编译后存储在数据库中，用户通过指定存储过程的名字并给定参数（如果该存储过程带有参数）来调用执行它。</p>\n</li>\n<li><p>存储过程是可编程的函数，在数据库中创建并保存，可以由SQL语句和控制结构组成。当想要在不同的应用程序或平台上执行相同的函数，或者封装特定功能时，存储过程是非常有用的。</p>\n</li>\n</ol>\n<h2 id=\"存储过程的优点\"><a href=\"#存储过程的优点\" class=\"headerlink\" title=\"存储过程的优点\"></a>存储过程的优点</h2><ol>\n<li><p>增强SQL语言的功能和灵活性：存储过程可以用控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。</p>\n</li>\n<li><p>标准组件式编程：存储过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的SQL语句。减小程序业务的复杂性，在一定程度上降低了程序的耦合性。</p>\n</li>\n<li></li>\n</ol>\n<p>较快的执行速度：如果某一操作包含大量的Transaction-SQL代码或分别被多次执行，那么存储过程要比批处理的执行速度快很多。因为存储过程是预编译的。在首次运行一个存储过程时查询，优化器对其进行分析优化，并且给出最终被存储在系统表中的执行计划。而批处理的Transaction-SQL语句在每次运行时都要进行编译和优化，速度相对要慢一些。</p>\n<ol start=\"4\">\n<li><p>减少网络流量：针对同一个数据库对象的操作（如查询、修改），如果这一操作所涉及的Transaction-SQL语句被组织进存储过程，那么当在客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而大大减少网络流量并降低了网络负载。</p>\n</li>\n<li><p>作为一种安全机制来充分利用：通过对执行某一存储过程的权限进行限制，能够实现对相应的数据的访问权限的限制，避免了非授权用户对数据的访问，保证了数据的安全。<br>不同的排序算法性质有所不同，衡量算法的效率，通常是用资源，例如<code>CPU</code>(时间)占用、内存占用、硬盘占用和网络占用。当讨论大<code>O</code><br>表示法时，一般考虑的是<code>CPU</code>占用。</p>\n</li>\n</ol>\n<h2 id=\"MySQL存储过程的\"><a href=\"#MySQL存储过程的\" class=\"headerlink\" title=\"MySQL存储过程的\"></a>MySQL存储过程的</h2><p><strong><code>语法</code></strong></p>\n<blockquote>\n<pre><code>DELIMITER $$\n</code></pre>\n</blockquote>\n<pre><code>CREATE PROCEDURE  过程名([[IN|OUT|INOUT] 参数名 数据类型[,[IN|OUT|INOUT] 参数名 数据类型…]]) [特性 ...] 过程体\nDELIMITER ;\n</code></pre>\n<p><strong><code>分隔符</code></strong></p>\n<blockquote>\n<p>所以要事先用“DELIMITER $$”声明当前段分隔符，让编译器把两个”$$”<br>之间的内容当做存储过程的代码，不会执行这些代码；“DELIMITER;”的意为把分隔符还原。BEGIN …<br>END之间是我们要编写的部分。MySQL默认以”;”为分隔符，如果没有声明分割符，则编译器会把存储过程当成SQL语句进行处理，因此编译过程会报错。</p>\n</blockquote>\n<p><strong><code>参数</code></strong></p>\n<blockquote>\n<p>存储过程根据需要可能会有输入、输出、输入输出参数，如果有多个参数用”,”<br>分割开。MySQL存储过程的参数用在存储过程的定义，共有三种参数类型,IN,OUT,INOUT:</p>\n</blockquote>\n<ul>\n<li>IN参数的值必须在调用存储过程时指定，在存储过程中修改该参数的值不能被返回，为默认值</li>\n<li>OUT:该值可在存储过程内部被改变，并可返回</li>\n<li>INOUT:调用时指定，并且可被改变和返回</li>\n</ul>\n<p><strong><code>过程体</code></strong></p>\n<blockquote>\n<p>过程体的开始与结束使用BEGIN与END进行标识。</p>\n</blockquote>\n<p><strong><code>IN参数例子</code></strong></p>\n<blockquote>\n<pre><code>DELIMITER $$\n</code></pre>\n</blockquote>\n<pre><code>CREATE\n    PROCEDURE p_in(IN parm_in INT)\n    BEGIN\n        SELECT parm_in;#若注掉 结果：5\n        SET parm_in=5;\n        SELECT parm_in;\n    END$$\nDELIMITER ;\n</code></pre>\n<p>调用<br>SET @p_in&#x3D;1;<br>CALL p_in(@p_in);<br>SELECT @p_in;<br>结果：5</p>\n<p><strong><code>OUT参数例子</code></strong></p>\n<blockquote>\n<pre><code>DELIMITER $$\n</code></pre>\n</blockquote>\n<pre><code>CREATE\n    PROCEDURE p_out(IN parm_out INT)\n    BEGIN\n    SELECT parm_out;#若注掉 结果：5\n    SET parm_out=5;\n    SELECT parm_out;\n    END$$\nDELIMITER ;\n</code></pre>\n<p>调用<br>SET @p_out&#x3D;1;<br>CALL p_out(@p_out);<br>SELECT @p_out;<br>结果：1</p>\n<p><strong><code>INOUT参数例子</code></strong></p>\n<blockquote>\n<p>DELIMITER $$<br>CREATE<br>PROCEDURE p_in_out(IN parm_in_out INT)<br>BEGIN<br>SELECT parm_in_out; #若注掉 结果：5<br>SET parm_in_out&#x3D;5;<br>SELECT parm_in_out;<br>END$$<br>DELIMITER ;<br>调用<br>SET @p_in_out&#x3D;1;<br>CALL p_in_out(@p_in_out);<br>SELECT @p_in_out;<br>结果：1</p>\n</blockquote>\n<p><strong><code>动态拼接sql例子</code></strong></p>\n<blockquote>\n<p>DELIMITER $$<br>DROP PROCEDURE IF EXISTS dsql $$<br>CREATE PROCEDURE dsql(IN parameter INT,IN name1 VARCHAR(64))<br>BEGIN<br>SET @sql1&#x3D;’SELECT * FROM t_user u WHERE 1&#x3D;1’;<br>IF parameter IS NOT NULL THEN<br>SET @sql1&#x3D; CONCAT(@sql1,’ and u.id &#x3D; ‘,parameter);<br>END IF ;<br>IF (name1 IS NOT NULL AND name1!&#x3D;’’) THEN<br>SET @sql1&#x3D; CONCAT(@sql1,’ and u.name LIKE&#39;%’,name1,’%&#39;‘);<br>END IF ;<br>PREPARE stmt FROM @sql1;<br>EXECUTE stmt;<br>END$$<br>DELIMITER ;</p>\n</blockquote>\n<p><strong><code>实际例子</code></strong></p>\n<blockquote>\n<p>DELIMITER $$<br>DROP PROCEDURE IF EXISTS ckm $$<br>CREATE<br>PROCEDURE ckm(IN t1 INT)<br>BEGIN<br>DECLARE u_time TIMESTAMP;<br>SELECT t.update_time INTO u_time FROM tx_msg_task t ;<br>UPDATE tx_msg_task SET update_time&#x3D;NOW();<br>DELETE uk FROM tx_msg_uk uk INNER JOIN tx_msg_hc h ON uk.msg_key&#x3D;h.msg_key;</p>\n</blockquote>\n<pre><code>    PREPARE sql1 FROM &#39;SELECT * FROM tx_msg_uk u  WHERE DATE_SUB(NOW(),INTERVAL ? MINUTE) &gt;=u.update_time&#39;;\n    SET @a = t1;\n    EXECUTE sql1 USING @a;#多个可以，分割\n    DEALLOCATE PREPARE sql1;#清理资源\n    END$$\nDELIMITER ; \n</code></pre>\n<h2 id=\"MySQL存储过程的调用\"><a href=\"#MySQL存储过程的调用\" class=\"headerlink\" title=\"MySQL存储过程的调用\"></a>MySQL存储过程的调用</h2><pre><code>用call和过程名以及一个括号，括号里面根据需要，加入参数，参数包括输入参数、输出参数、输入输出参数。CALL\n</code></pre>\n<h2 id=\"MySQL存储过程的查询\"><a href=\"#MySQL存储过程的查询\" class=\"headerlink\" title=\"MySQL存储过程的查询\"></a>MySQL存储过程的查询</h2><pre><code>SELECT name FROM mysql.proc WHERE db=&#39;数据库名&#39;;\nSELECT routine_name FROM information_schema.routines WHERE routine_schema=&#39;数据库名&#39;;\nSHOW PROCEDURE STATUS WHERE db=&#39;数据库名&#39;;\n</code></pre>\n<h2 id=\"MySQL存储过程的删除\"><a href=\"#MySQL存储过程的删除\" class=\"headerlink\" title=\"MySQL存储过程的删除\"></a>MySQL存储过程的删除</h2><pre><code>DROP PROCEDURE [过程1[,过程2…]]\n从MySQL的表格中删除一个或多个存储过程。\n</code></pre>\n<h2 id=\"存储程序中的变量\"><a href=\"#存储程序中的变量\" class=\"headerlink\" title=\"存储程序中的变量\"></a>存储程序中的变量</h2><ol>\n<li>DECLARE局部变量 DECLARE var_name[,…] type [DEFAULT value]<br><br>这个语句被用来声明局部变量。 要给变量提供一个默认值，请包含一个DEFAULT子句。值可以被指定为一个表达式，不需要为一个常数。如果没有DEFAULT子句，初始值为NULL。<br>局部变量的作用范围在它被声明的BEGIN … END块内。它可以被用在嵌套的块中，除了那些用相同名字声明变量的块。</li>\n<li>变量SET语句 SET var_name &#x3D; expr [, var_name &#x3D; expr]<br><br>在存储程序中的SET语句是一般SET语句的扩展版本。被参考变量可能是子程序内声明的变量，或者是全局服务器变量。<br>在存储程序中的SET语句作为预先存在的SET语法的一部分来实现。这允许SET a&#x3D;x, b&#x3D;y,<br>…这样的扩展语法。其中不同的变量类型（局域声明变量及全局和集体变量）可以被混合起来。这也允许把局部变量和一些只对系统变量有意义的选项合并起来。</li>\n<li>SELECT … INTO<br><br>SELECT col_name[,…] INTO var_name[,…] table_expr这个SELECT语法把选定的列直接存储到变量。因此，只有单一的行可以被取回。<br>SELECT id,data INTO x,y FROM test.t1 LIMIT 1;</li>\n</ol>\n<p>列子：</p>\n<pre><code>SELECT &#39;Hello World&#39; INTO @a;\nSELECT @a;\n\nSET @b=&#39;Hello World&#39;;\nSELECT @b;\n\nSET @c=1+2+3;\nSELECT @c; \n\n#在存储过程中使用用户变量\nCREATE PROCEDURE sayHi() SELECT CONCAT(@hi,&#39;...&#39;);\nSET @hi=&#39;hi&#39;;\nCALL sayHi(); \n#在存储过程间传递全局范围的用户变量\nCREATE PROCEDURE tp1() SET @param=&#39;p1&#39;;\nCREATE PROCEDURE tp2() SELECT CONCAT(&#39;param... &#39;,@param);\nCALL tp1();\nCALL tp2(); \n</code></pre>\n<h2 id=\"MySQL存储过程的控制语句\"><a href=\"#MySQL存储过程的控制语句\" class=\"headerlink\" title=\"MySQL存储过程的控制语句\"></a>MySQL存储过程的控制语句</h2><ol>\n<li>变量作用域: 内部变量在其作用域范围内享有更高的优先权，当执行到end时，内部变量消失，不再可见了，在存储<br>过程外再也找不到这个内部变量，但是可以通过out参数或者将其值指派给会话变量来保存其值。</li>\n</ol>\n<blockquote>\n<p>DELIMITER $$<br>DROP PROCEDURE IF EXISTS <code>proc</code>$$<br>CREATE PROCEDURE proc()<br>BEGIN<br>DECLARE x1 VARCHAR(5) DEFAULT ‘outer’;<br>BEGIN<br>DECLARE x1 VARCHAR(5) DEFAULT ‘inner’;<br>SELECT x1;<br>END;<br>SELECT x1;<br>END$$<br>DELIMITER ;<br>#调用<br>CALL proc();<br>结果：inner</p>\n</blockquote>\n<ol start=\"2\">\n<li>条件语句 IF-THEN-ELSE</li>\n</ol>\n<blockquote>\n<p>DROP PROCEDURE IF EXISTS proc3 ;<br>DELIMITER $$<br>CREATE PROCEDURE proc3(IN parameter INT)<br>BEGIN<br>DECLARE var INT;<br>SET var&#x3D;parameter+1;<br>IF var&#x3D;0 THEN<br>INSERT INTO t VALUES (17);<br>END IF ;<br>IF parameter&#x3D;0 THEN<br>UPDATE t SET s1&#x3D;s1+1;<br>ELSE<br>UPDATE t SET s1&#x3D;s1+2;<br>END IF ;<br>END$$<br>DELIMITER ;</p>\n</blockquote>\n<ol start=\"3\">\n<li>CASE-WHEN-THEN-ELSE语句</li>\n</ol>\n<blockquote>\n<p>DELIMITER $$<br>CREATE PROCEDURE proc4 (IN parameter INT)<br>BEGIN<br>DECLARE var INT;<br>SET var&#x3D;parameter+1;<br>CASE var<br>WHEN 0 THEN<br>INSERT INTO t VALUES (17);<br>WHEN 1 THEN<br>INSERT INTO t VALUES (18);<br>ELSE<br>INSERT INTO t VALUES (19);<br>END CASE ;<br>END$$<br>DELIMITER;</p>\n</blockquote>\n<ol start=\"4\">\n<li>循环语句 WHILE-DO…END-WHILE</li>\n</ol>\n<blockquote>\n<p>DELIMITER $$<br>CREATE PROCEDURE proc5()<br>BEGIN<br>DECLARE var INT;<br>SET var&#x3D;0;<br>WHILE var&lt;6 DO<br>INSERT INTO t VALUES (var);<br>SET var&#x3D;var+1;<br>END WHILE ;<br>END$$<br>DELIMITER;</p>\n</blockquote>\n<ol start=\"5\">\n<li>REPEAT…END REPEAT 此语句的特点是执行操作后检查结果</li>\n</ol>\n<blockquote>\n<p>DELIMITER $$<br>CREATE PROCEDURE proc6 ()<br>BEGIN<br>DECLARE v INT;<br>SET v&#x3D;0;<br>REPEAT<br>INSERT INTO t VALUES(v);<br>SET v&#x3D;v+1;<br>UNTIL v&gt;&#x3D;5<br>END REPEAT;<br>END$$<br>DELIMITER ;</p>\n</blockquote>\n<ol start=\"6\">\n<li>LOOP…END LOOP</li>\n</ol>\n<blockquote>\n<p>DELIMITER $$<br>CREATE PROCEDURE proc7 ()<br>BEGIN<br>DECLARE v INT;<br>SET v&#x3D;0;<br>LOOP_LABLE:LOOP<br>INSERT INTO t VALUES(v);<br>SET v&#x3D;v+1;<br>IF v &gt;&#x3D;5 THEN<br>LEAVE LOOP_LABLE;<br>END IF;<br>END LOOP;<br>END$$<br>DELIMITER ;</p>\n</blockquote>\n<ol start=\"7\">\n<li><p>LABLES标号:标号可以用在begin repeat while 或者loop 语句前，语句标号只能在合法的语句前面使用。可以跳出循环，使运行指令达到复合语句的最后一步。</p>\n</li>\n<li><p>ITERATE迭代通过引用复合语句的标号,来从新开始复合语句</p>\n</li>\n</ol>\n<blockquote>\n<p>DELIMITER $$<br>CREATE PROCEDURE proc8()<br>BEGIN<br>DECLARE v INT;<br>SET v&#x3D;0;<br>LOOP_LABLE:LOOP<br>IF v&#x3D;3 THEN<br>SET v&#x3D;v+1;<br>ITERATE LOOP_LABLE;<br>END IF;<br>INSERT INTO t VALUES(v);<br>SET v&#x3D;v+1;<br>IF v&gt;&#x3D;5 THEN<br>LEAVE LOOP_LABLE;<br>END IF;<br>END LOOP;<br>END$$<br>DELIMITER ;</p>\n</blockquote>\n<h2 id=\"MySQL存储过程的基本函数\"><a href=\"#MySQL存储过程的基本函数\" class=\"headerlink\" title=\"MySQL存储过程的基本函数\"></a>MySQL存储过程的基本函数</h2><ol>\n<li><p>字符串类</p>\n<blockquote>\n<p>CHARSET(str) &#x2F;&#x2F;返回字串字符集<br>CONCAT (string2 [,… ]) &#x2F;&#x2F;连接字串<br>INSTR (string ,substring ) &#x2F;&#x2F;返回substring首次在string中出现的位置,不存在返回0<br>LCASE (string2 ) &#x2F;&#x2F;转换成小写<br>LEFT (string2 ,length ) &#x2F;&#x2F;从string2中的左边起取length个字符<br>LENGTH (string ) &#x2F;&#x2F;string长度<br>LOAD_FILE (file_name ) &#x2F;&#x2F;从文件读取内容<br>LOCATE (substring , string [,start_position ] ) 同INSTR,但可指定开始位置<br>LPAD (string2 ,length ,pad ) &#x2F;&#x2F;重复用pad加在string开头,直到字串长度为length<br>LTRIM (string2 ) &#x2F;&#x2F;去除前端空格<br>REPEAT (string2 ,count ) &#x2F;&#x2F;重复count次<br>REPLACE (str ,search_str ,replace_str ) &#x2F;&#x2F;在str中用replace_str替换search_str<br>RPAD (string2 ,length ,pad) &#x2F;&#x2F;在str后用pad补充,直到长度为length<br>RTRIM (string2 ) &#x2F;&#x2F;去除后端空格<br>STRCMP (string1 ,string2 ) &#x2F;&#x2F;逐字符比较两字串大小,<br>SUBSTRING (str , position [,length ]) &#x2F;&#x2F;从str的position开始,取length个字符,<br>TRIM([[BOTH|LEADING|TRAILING] [padding] FROM]string2) &#x2F;&#x2F;去除指定位置的指定字符<br>UCASE (string2 ) &#x2F;&#x2F;转换成大写<br>RIGHT(string2,length) &#x2F;&#x2F;取string2最后length个字符<br>SPACE(count) &#x2F;&#x2F;生成count个空格<br>注：mysql中处理字符串时，默认第一个字符下标为1，即参数position必须大于等于1</p>\n</blockquote>\n</li>\n<li><p>数学类</p>\n<blockquote>\n<p>ABS (number2 ) &#x2F;&#x2F;绝对值<br>BIN (decimal_number ) &#x2F;&#x2F;十进制转二进制<br>CEILING (number2 ) &#x2F;&#x2F;向上取整<br>CONV(number2,from_base,to_base) &#x2F;&#x2F;进制转换<br>FLOOR (number2 ) &#x2F;&#x2F;向下取整<br>FORMAT (number,decimal_places ) &#x2F;&#x2F;保留小数位数<br>HEX (DecimalNumber ) &#x2F;&#x2F;转十六进制<br>注：HEX()中可传入字符串，则返回其ASC-11码，如HEX(‘DEF’)返回4142143<br>也可以传入十进制整数，返回其十六进制编码，如HEX(25)返回19<br>LEAST (number , number2 [,..]) &#x2F;&#x2F;求最小值<br>MOD (numerator ,denominator ) &#x2F;&#x2F;求余<br>POWER (number ,power ) &#x2F;&#x2F;求指数<br>RAND([seed]) &#x2F;&#x2F;随机数<br>ROUND (number [,decimals ]) &#x2F;&#x2F;四舍五入,decimals为小数位数] 注：返回类型并非均为整数，如：<br>SIGN (number2 ) &#x2F;&#x2F; 正数返回1，负数返回-1<br>MINUTE(datetime) &#x2F;&#x2F;分返回符号,正负或0<br>SQRT(number2) &#x2F;&#x2F;开平方</p>\n</blockquote>\n</li>\n<li><p>日期时间类</p>\n<blockquote>\n<p>ADDTIME (date2 ,time_interval ) &#x2F;&#x2F;将time_interval加到date2<br>CONVERT_TZ (datetime2 ,fromTZ ,toTZ ) &#x2F;&#x2F;转换时区<br>CURRENT_DATE ( ) &#x2F;&#x2F;当前日期<br>CURRENT_TIME ( ) &#x2F;&#x2F;当前时间<br>CURRENT_TIMESTAMP ( ) &#x2F;&#x2F;当前时间戳<br>DATE (datetime ) &#x2F;&#x2F;返回datetime的日期部分<br>DATE_ADD (date2 , INTERVAL d_value d_type ) &#x2F;&#x2F;在date2中加上日期或时间<br>DATE_FORMAT (datetime ,FormatCodes ) &#x2F;&#x2F;使用formatcodes格式显示datetime<br>DATE_SUB (date2 , INTERVAL d_value d_type ) &#x2F;&#x2F;在date2上减去一个时间<br>DATEDIFF (date1 ,date2 ) &#x2F;&#x2F;两个日期差<br>DAY (date ) &#x2F;&#x2F;返回日期的天<br>DAYNAME (date ) &#x2F;&#x2F;英文星期<br>DAYOFWEEK (date ) &#x2F;&#x2F;星期(1-7) ,1为星期天<br>DAYOFYEAR (date ) &#x2F;&#x2F;一年中的第几天<br>EXTRACT (interval_name FROM date ) &#x2F;&#x2F;从date中提取日期的指定部分<br>MAKEDATE (year ,day ) &#x2F;&#x2F;给出年及年中的第几天,生成日期串<br>MAKETIME (hour ,minute ,second ) &#x2F;&#x2F;生成时间串<br>MONTHNAME (date ) &#x2F;&#x2F;英文月份名<br>NOW ( ) &#x2F;&#x2F;当前时间<br>SEC_TO_TIME (seconds ) &#x2F;&#x2F;秒数转成时间<br>STR_TO_DATE (string ,format ) &#x2F;&#x2F;字串转成时间,以format格式显示<br>TIMEDIFF (datetime1 ,datetime2 ) &#x2F;&#x2F;两个时间差<br>TIME_TO_SEC (time ) &#x2F;&#x2F;时间转秒数]<br>WEEK (date_time [,start_of_week ]) &#x2F;&#x2F;第几周<br>YEAR (datetime ) &#x2F;&#x2F;年份<br>DAYOFMONTH(datetime) &#x2F;&#x2F;月的第几天<br>HOUR(datetime) &#x2F;&#x2F;小时<br>LAST_DAY(date) &#x2F;&#x2F;date的月的最后日期<br>MICROSECOND(datetime) &#x2F;&#x2F;微秒<br>MONTH(datetime) &#x2F;&#x2F;月</p>\n</blockquote>\n</li>\n</ol>\n<!--http://www.cnblogs.com/mark-chan/p/5384139.html-->\n\n<h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h2><pre><code>单行：--或 #\n多行：/*  */ \n</code></pre>\n<h2 id=\"mybatis调用存储过程\"><a href=\"#mybatis调用存储过程\" class=\"headerlink\" title=\"mybatis调用存储过程\"></a>mybatis调用存储过程</h2><pre><code>&lt;select id=&quot;proFindUser&quot; resultMap=&quot;BaseResultMap&quot; statementType=&quot;CALLABLE&quot;&gt;\n    &#123;\n        CALL find_user(#&#123;uid,mode=IN,jdbcType=BIGINT&#125;,#&#123;name,mode=IN,jdbcType=VARCHAR&#125;)\n    &#125;\n&lt;/select&gt;\n</code></pre>\n","excerpt":"","more":"<h2 id=\"存储过程简介\"><a href=\"#存储过程简介\" class=\"headerlink\" title=\"存储过程简介\"></a>存储过程简介</h2><ol>\n<li><p>SQL语句需要先编译然后执行，而存储过程（Stored<br>Procedure）是一组为了完成特定功能的SQL语句集，经编译后存储在数据库中，用户通过指定存储过程的名字并给定参数（如果该存储过程带有参数）来调用执行它。</p>\n</li>\n<li><p>存储过程是可编程的函数，在数据库中创建并保存，可以由SQL语句和控制结构组成。当想要在不同的应用程序或平台上执行相同的函数，或者封装特定功能时，存储过程是非常有用的。</p>\n</li>\n</ol>\n<h2 id=\"存储过程的优点\"><a href=\"#存储过程的优点\" class=\"headerlink\" title=\"存储过程的优点\"></a>存储过程的优点</h2><ol>\n<li><p>增强SQL语言的功能和灵活性：存储过程可以用控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。</p>\n</li>\n<li><p>标准组件式编程：存储过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的SQL语句。减小程序业务的复杂性，在一定程度上降低了程序的耦合性。</p>\n</li>\n<li></li>\n</ol>\n<p>较快的执行速度：如果某一操作包含大量的Transaction-SQL代码或分别被多次执行，那么存储过程要比批处理的执行速度快很多。因为存储过程是预编译的。在首次运行一个存储过程时查询，优化器对其进行分析优化，并且给出最终被存储在系统表中的执行计划。而批处理的Transaction-SQL语句在每次运行时都要进行编译和优化，速度相对要慢一些。</p>\n<ol start=\"4\">\n<li><p>减少网络流量：针对同一个数据库对象的操作（如查询、修改），如果这一操作所涉及的Transaction-SQL语句被组织进存储过程，那么当在客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而大大减少网络流量并降低了网络负载。</p>\n</li>\n<li><p>作为一种安全机制来充分利用：通过对执行某一存储过程的权限进行限制，能够实现对相应的数据的访问权限的限制，避免了非授权用户对数据的访问，保证了数据的安全。<br>不同的排序算法性质有所不同，衡量算法的效率，通常是用资源，例如<code>CPU</code>(时间)占用、内存占用、硬盘占用和网络占用。当讨论大<code>O</code><br>表示法时，一般考虑的是<code>CPU</code>占用。</p>\n</li>\n</ol>\n<h2 id=\"MySQL存储过程的\"><a href=\"#MySQL存储过程的\" class=\"headerlink\" title=\"MySQL存储过程的\"></a>MySQL存储过程的</h2><p><strong><code>语法</code></strong></p>\n<blockquote>\n<pre><code>DELIMITER $$\n</code></pre>\n</blockquote>\n<pre><code>CREATE PROCEDURE  过程名([[IN|OUT|INOUT] 参数名 数据类型[,[IN|OUT|INOUT] 参数名 数据类型…]]) [特性 ...] 过程体\nDELIMITER ;\n</code></pre>\n<p><strong><code>分隔符</code></strong></p>\n<blockquote>\n<p>所以要事先用“DELIMITER $$”声明当前段分隔符，让编译器把两个”$$”<br>之间的内容当做存储过程的代码，不会执行这些代码；“DELIMITER;”的意为把分隔符还原。BEGIN …<br>END之间是我们要编写的部分。MySQL默认以”;”为分隔符，如果没有声明分割符，则编译器会把存储过程当成SQL语句进行处理，因此编译过程会报错。</p>\n</blockquote>\n<p><strong><code>参数</code></strong></p>\n<blockquote>\n<p>存储过程根据需要可能会有输入、输出、输入输出参数，如果有多个参数用”,”<br>分割开。MySQL存储过程的参数用在存储过程的定义，共有三种参数类型,IN,OUT,INOUT:</p>\n</blockquote>\n<ul>\n<li>IN参数的值必须在调用存储过程时指定，在存储过程中修改该参数的值不能被返回，为默认值</li>\n<li>OUT:该值可在存储过程内部被改变，并可返回</li>\n<li>INOUT:调用时指定，并且可被改变和返回</li>\n</ul>\n<p><strong><code>过程体</code></strong></p>\n<blockquote>\n<p>过程体的开始与结束使用BEGIN与END进行标识。</p>\n</blockquote>\n<p><strong><code>IN参数例子</code></strong></p>\n<blockquote>\n<pre><code>DELIMITER $$\n</code></pre>\n</blockquote>\n<pre><code>CREATE\n    PROCEDURE p_in(IN parm_in INT)\n    BEGIN\n        SELECT parm_in;#若注掉 结果：5\n        SET parm_in=5;\n        SELECT parm_in;\n    END$$\nDELIMITER ;\n</code></pre>\n<p>调用<br>SET @p_in&#x3D;1;<br>CALL p_in(@p_in);<br>SELECT @p_in;<br>结果：5</p>\n<p><strong><code>OUT参数例子</code></strong></p>\n<blockquote>\n<pre><code>DELIMITER $$\n</code></pre>\n</blockquote>\n<pre><code>CREATE\n    PROCEDURE p_out(IN parm_out INT)\n    BEGIN\n    SELECT parm_out;#若注掉 结果：5\n    SET parm_out=5;\n    SELECT parm_out;\n    END$$\nDELIMITER ;\n</code></pre>\n<p>调用<br>SET @p_out&#x3D;1;<br>CALL p_out(@p_out);<br>SELECT @p_out;<br>结果：1</p>\n<p><strong><code>INOUT参数例子</code></strong></p>\n<blockquote>\n<p>DELIMITER $$<br>CREATE<br>PROCEDURE p_in_out(IN parm_in_out INT)<br>BEGIN<br>SELECT parm_in_out; #若注掉 结果：5<br>SET parm_in_out&#x3D;5;<br>SELECT parm_in_out;<br>END$$<br>DELIMITER ;<br>调用<br>SET @p_in_out&#x3D;1;<br>CALL p_in_out(@p_in_out);<br>SELECT @p_in_out;<br>结果：1</p>\n</blockquote>\n<p><strong><code>动态拼接sql例子</code></strong></p>\n<blockquote>\n<p>DELIMITER $$<br>DROP PROCEDURE IF EXISTS dsql $$<br>CREATE PROCEDURE dsql(IN parameter INT,IN name1 VARCHAR(64))<br>BEGIN<br>SET @sql1&#x3D;’SELECT * FROM t_user u WHERE 1&#x3D;1’;<br>IF parameter IS NOT NULL THEN<br>SET @sql1&#x3D; CONCAT(@sql1,’ and u.id &#x3D; ‘,parameter);<br>END IF ;<br>IF (name1 IS NOT NULL AND name1!&#x3D;’’) THEN<br>SET @sql1&#x3D; CONCAT(@sql1,’ and u.name LIKE&#39;%’,name1,’%&#39;‘);<br>END IF ;<br>PREPARE stmt FROM @sql1;<br>EXECUTE stmt;<br>END$$<br>DELIMITER ;</p>\n</blockquote>\n<p><strong><code>实际例子</code></strong></p>\n<blockquote>\n<p>DELIMITER $$<br>DROP PROCEDURE IF EXISTS ckm $$<br>CREATE<br>PROCEDURE ckm(IN t1 INT)<br>BEGIN<br>DECLARE u_time TIMESTAMP;<br>SELECT t.update_time INTO u_time FROM tx_msg_task t ;<br>UPDATE tx_msg_task SET update_time&#x3D;NOW();<br>DELETE uk FROM tx_msg_uk uk INNER JOIN tx_msg_hc h ON uk.msg_key&#x3D;h.msg_key;</p>\n</blockquote>\n<pre><code>    PREPARE sql1 FROM &#39;SELECT * FROM tx_msg_uk u  WHERE DATE_SUB(NOW(),INTERVAL ? MINUTE) &gt;=u.update_time&#39;;\n    SET @a = t1;\n    EXECUTE sql1 USING @a;#多个可以，分割\n    DEALLOCATE PREPARE sql1;#清理资源\n    END$$\nDELIMITER ; \n</code></pre>\n<h2 id=\"MySQL存储过程的调用\"><a href=\"#MySQL存储过程的调用\" class=\"headerlink\" title=\"MySQL存储过程的调用\"></a>MySQL存储过程的调用</h2><pre><code>用call和过程名以及一个括号，括号里面根据需要，加入参数，参数包括输入参数、输出参数、输入输出参数。CALL\n</code></pre>\n<h2 id=\"MySQL存储过程的查询\"><a href=\"#MySQL存储过程的查询\" class=\"headerlink\" title=\"MySQL存储过程的查询\"></a>MySQL存储过程的查询</h2><pre><code>SELECT name FROM mysql.proc WHERE db=&#39;数据库名&#39;;\nSELECT routine_name FROM information_schema.routines WHERE routine_schema=&#39;数据库名&#39;;\nSHOW PROCEDURE STATUS WHERE db=&#39;数据库名&#39;;\n</code></pre>\n<h2 id=\"MySQL存储过程的删除\"><a href=\"#MySQL存储过程的删除\" class=\"headerlink\" title=\"MySQL存储过程的删除\"></a>MySQL存储过程的删除</h2><pre><code>DROP PROCEDURE [过程1[,过程2…]]\n从MySQL的表格中删除一个或多个存储过程。\n</code></pre>\n<h2 id=\"存储程序中的变量\"><a href=\"#存储程序中的变量\" class=\"headerlink\" title=\"存储程序中的变量\"></a>存储程序中的变量</h2><ol>\n<li>DECLARE局部变量 DECLARE var_name[,…] type [DEFAULT value]<br><br>这个语句被用来声明局部变量。 要给变量提供一个默认值，请包含一个DEFAULT子句。值可以被指定为一个表达式，不需要为一个常数。如果没有DEFAULT子句，初始值为NULL。<br>局部变量的作用范围在它被声明的BEGIN … END块内。它可以被用在嵌套的块中，除了那些用相同名字声明变量的块。</li>\n<li>变量SET语句 SET var_name &#x3D; expr [, var_name &#x3D; expr]<br><br>在存储程序中的SET语句是一般SET语句的扩展版本。被参考变量可能是子程序内声明的变量，或者是全局服务器变量。<br>在存储程序中的SET语句作为预先存在的SET语法的一部分来实现。这允许SET a&#x3D;x, b&#x3D;y,<br>…这样的扩展语法。其中不同的变量类型（局域声明变量及全局和集体变量）可以被混合起来。这也允许把局部变量和一些只对系统变量有意义的选项合并起来。</li>\n<li>SELECT … INTO<br><br>SELECT col_name[,…] INTO var_name[,…] table_expr这个SELECT语法把选定的列直接存储到变量。因此，只有单一的行可以被取回。<br>SELECT id,data INTO x,y FROM test.t1 LIMIT 1;</li>\n</ol>\n<p>列子：</p>\n<pre><code>SELECT &#39;Hello World&#39; INTO @a;\nSELECT @a;\n\nSET @b=&#39;Hello World&#39;;\nSELECT @b;\n\nSET @c=1+2+3;\nSELECT @c; \n\n#在存储过程中使用用户变量\nCREATE PROCEDURE sayHi() SELECT CONCAT(@hi,&#39;...&#39;);\nSET @hi=&#39;hi&#39;;\nCALL sayHi(); \n#在存储过程间传递全局范围的用户变量\nCREATE PROCEDURE tp1() SET @param=&#39;p1&#39;;\nCREATE PROCEDURE tp2() SELECT CONCAT(&#39;param... &#39;,@param);\nCALL tp1();\nCALL tp2(); \n</code></pre>\n<h2 id=\"MySQL存储过程的控制语句\"><a href=\"#MySQL存储过程的控制语句\" class=\"headerlink\" title=\"MySQL存储过程的控制语句\"></a>MySQL存储过程的控制语句</h2><ol>\n<li>变量作用域: 内部变量在其作用域范围内享有更高的优先权，当执行到end时，内部变量消失，不再可见了，在存储<br>过程外再也找不到这个内部变量，但是可以通过out参数或者将其值指派给会话变量来保存其值。</li>\n</ol>\n<blockquote>\n<p>DELIMITER $$<br>DROP PROCEDURE IF EXISTS <code>proc</code>$$<br>CREATE PROCEDURE proc()<br>BEGIN<br>DECLARE x1 VARCHAR(5) DEFAULT ‘outer’;<br>BEGIN<br>DECLARE x1 VARCHAR(5) DEFAULT ‘inner’;<br>SELECT x1;<br>END;<br>SELECT x1;<br>END$$<br>DELIMITER ;<br>#调用<br>CALL proc();<br>结果：inner</p>\n</blockquote>\n<ol start=\"2\">\n<li>条件语句 IF-THEN-ELSE</li>\n</ol>\n<blockquote>\n<p>DROP PROCEDURE IF EXISTS proc3 ;<br>DELIMITER $$<br>CREATE PROCEDURE proc3(IN parameter INT)<br>BEGIN<br>DECLARE var INT;<br>SET var&#x3D;parameter+1;<br>IF var&#x3D;0 THEN<br>INSERT INTO t VALUES (17);<br>END IF ;<br>IF parameter&#x3D;0 THEN<br>UPDATE t SET s1&#x3D;s1+1;<br>ELSE<br>UPDATE t SET s1&#x3D;s1+2;<br>END IF ;<br>END$$<br>DELIMITER ;</p>\n</blockquote>\n<ol start=\"3\">\n<li>CASE-WHEN-THEN-ELSE语句</li>\n</ol>\n<blockquote>\n<p>DELIMITER $$<br>CREATE PROCEDURE proc4 (IN parameter INT)<br>BEGIN<br>DECLARE var INT;<br>SET var&#x3D;parameter+1;<br>CASE var<br>WHEN 0 THEN<br>INSERT INTO t VALUES (17);<br>WHEN 1 THEN<br>INSERT INTO t VALUES (18);<br>ELSE<br>INSERT INTO t VALUES (19);<br>END CASE ;<br>END$$<br>DELIMITER;</p>\n</blockquote>\n<ol start=\"4\">\n<li>循环语句 WHILE-DO…END-WHILE</li>\n</ol>\n<blockquote>\n<p>DELIMITER $$<br>CREATE PROCEDURE proc5()<br>BEGIN<br>DECLARE var INT;<br>SET var&#x3D;0;<br>WHILE var&lt;6 DO<br>INSERT INTO t VALUES (var);<br>SET var&#x3D;var+1;<br>END WHILE ;<br>END$$<br>DELIMITER;</p>\n</blockquote>\n<ol start=\"5\">\n<li>REPEAT…END REPEAT 此语句的特点是执行操作后检查结果</li>\n</ol>\n<blockquote>\n<p>DELIMITER $$<br>CREATE PROCEDURE proc6 ()<br>BEGIN<br>DECLARE v INT;<br>SET v&#x3D;0;<br>REPEAT<br>INSERT INTO t VALUES(v);<br>SET v&#x3D;v+1;<br>UNTIL v&gt;&#x3D;5<br>END REPEAT;<br>END$$<br>DELIMITER ;</p>\n</blockquote>\n<ol start=\"6\">\n<li>LOOP…END LOOP</li>\n</ol>\n<blockquote>\n<p>DELIMITER $$<br>CREATE PROCEDURE proc7 ()<br>BEGIN<br>DECLARE v INT;<br>SET v&#x3D;0;<br>LOOP_LABLE:LOOP<br>INSERT INTO t VALUES(v);<br>SET v&#x3D;v+1;<br>IF v &gt;&#x3D;5 THEN<br>LEAVE LOOP_LABLE;<br>END IF;<br>END LOOP;<br>END$$<br>DELIMITER ;</p>\n</blockquote>\n<ol start=\"7\">\n<li><p>LABLES标号:标号可以用在begin repeat while 或者loop 语句前，语句标号只能在合法的语句前面使用。可以跳出循环，使运行指令达到复合语句的最后一步。</p>\n</li>\n<li><p>ITERATE迭代通过引用复合语句的标号,来从新开始复合语句</p>\n</li>\n</ol>\n<blockquote>\n<p>DELIMITER $$<br>CREATE PROCEDURE proc8()<br>BEGIN<br>DECLARE v INT;<br>SET v&#x3D;0;<br>LOOP_LABLE:LOOP<br>IF v&#x3D;3 THEN<br>SET v&#x3D;v+1;<br>ITERATE LOOP_LABLE;<br>END IF;<br>INSERT INTO t VALUES(v);<br>SET v&#x3D;v+1;<br>IF v&gt;&#x3D;5 THEN<br>LEAVE LOOP_LABLE;<br>END IF;<br>END LOOP;<br>END$$<br>DELIMITER ;</p>\n</blockquote>\n<h2 id=\"MySQL存储过程的基本函数\"><a href=\"#MySQL存储过程的基本函数\" class=\"headerlink\" title=\"MySQL存储过程的基本函数\"></a>MySQL存储过程的基本函数</h2><ol>\n<li><p>字符串类</p>\n<blockquote>\n<p>CHARSET(str) &#x2F;&#x2F;返回字串字符集<br>CONCAT (string2 [,… ]) &#x2F;&#x2F;连接字串<br>INSTR (string ,substring ) &#x2F;&#x2F;返回substring首次在string中出现的位置,不存在返回0<br>LCASE (string2 ) &#x2F;&#x2F;转换成小写<br>LEFT (string2 ,length ) &#x2F;&#x2F;从string2中的左边起取length个字符<br>LENGTH (string ) &#x2F;&#x2F;string长度<br>LOAD_FILE (file_name ) &#x2F;&#x2F;从文件读取内容<br>LOCATE (substring , string [,start_position ] ) 同INSTR,但可指定开始位置<br>LPAD (string2 ,length ,pad ) &#x2F;&#x2F;重复用pad加在string开头,直到字串长度为length<br>LTRIM (string2 ) &#x2F;&#x2F;去除前端空格<br>REPEAT (string2 ,count ) &#x2F;&#x2F;重复count次<br>REPLACE (str ,search_str ,replace_str ) &#x2F;&#x2F;在str中用replace_str替换search_str<br>RPAD (string2 ,length ,pad) &#x2F;&#x2F;在str后用pad补充,直到长度为length<br>RTRIM (string2 ) &#x2F;&#x2F;去除后端空格<br>STRCMP (string1 ,string2 ) &#x2F;&#x2F;逐字符比较两字串大小,<br>SUBSTRING (str , position [,length ]) &#x2F;&#x2F;从str的position开始,取length个字符,<br>TRIM([[BOTH|LEADING|TRAILING] [padding] FROM]string2) &#x2F;&#x2F;去除指定位置的指定字符<br>UCASE (string2 ) &#x2F;&#x2F;转换成大写<br>RIGHT(string2,length) &#x2F;&#x2F;取string2最后length个字符<br>SPACE(count) &#x2F;&#x2F;生成count个空格<br>注：mysql中处理字符串时，默认第一个字符下标为1，即参数position必须大于等于1</p>\n</blockquote>\n</li>\n<li><p>数学类</p>\n<blockquote>\n<p>ABS (number2 ) &#x2F;&#x2F;绝对值<br>BIN (decimal_number ) &#x2F;&#x2F;十进制转二进制<br>CEILING (number2 ) &#x2F;&#x2F;向上取整<br>CONV(number2,from_base,to_base) &#x2F;&#x2F;进制转换<br>FLOOR (number2 ) &#x2F;&#x2F;向下取整<br>FORMAT (number,decimal_places ) &#x2F;&#x2F;保留小数位数<br>HEX (DecimalNumber ) &#x2F;&#x2F;转十六进制<br>注：HEX()中可传入字符串，则返回其ASC-11码，如HEX(‘DEF’)返回4142143<br>也可以传入十进制整数，返回其十六进制编码，如HEX(25)返回19<br>LEAST (number , number2 [,..]) &#x2F;&#x2F;求最小值<br>MOD (numerator ,denominator ) &#x2F;&#x2F;求余<br>POWER (number ,power ) &#x2F;&#x2F;求指数<br>RAND([seed]) &#x2F;&#x2F;随机数<br>ROUND (number [,decimals ]) &#x2F;&#x2F;四舍五入,decimals为小数位数] 注：返回类型并非均为整数，如：<br>SIGN (number2 ) &#x2F;&#x2F; 正数返回1，负数返回-1<br>MINUTE(datetime) &#x2F;&#x2F;分返回符号,正负或0<br>SQRT(number2) &#x2F;&#x2F;开平方</p>\n</blockquote>\n</li>\n<li><p>日期时间类</p>\n<blockquote>\n<p>ADDTIME (date2 ,time_interval ) &#x2F;&#x2F;将time_interval加到date2<br>CONVERT_TZ (datetime2 ,fromTZ ,toTZ ) &#x2F;&#x2F;转换时区<br>CURRENT_DATE ( ) &#x2F;&#x2F;当前日期<br>CURRENT_TIME ( ) &#x2F;&#x2F;当前时间<br>CURRENT_TIMESTAMP ( ) &#x2F;&#x2F;当前时间戳<br>DATE (datetime ) &#x2F;&#x2F;返回datetime的日期部分<br>DATE_ADD (date2 , INTERVAL d_value d_type ) &#x2F;&#x2F;在date2中加上日期或时间<br>DATE_FORMAT (datetime ,FormatCodes ) &#x2F;&#x2F;使用formatcodes格式显示datetime<br>DATE_SUB (date2 , INTERVAL d_value d_type ) &#x2F;&#x2F;在date2上减去一个时间<br>DATEDIFF (date1 ,date2 ) &#x2F;&#x2F;两个日期差<br>DAY (date ) &#x2F;&#x2F;返回日期的天<br>DAYNAME (date ) &#x2F;&#x2F;英文星期<br>DAYOFWEEK (date ) &#x2F;&#x2F;星期(1-7) ,1为星期天<br>DAYOFYEAR (date ) &#x2F;&#x2F;一年中的第几天<br>EXTRACT (interval_name FROM date ) &#x2F;&#x2F;从date中提取日期的指定部分<br>MAKEDATE (year ,day ) &#x2F;&#x2F;给出年及年中的第几天,生成日期串<br>MAKETIME (hour ,minute ,second ) &#x2F;&#x2F;生成时间串<br>MONTHNAME (date ) &#x2F;&#x2F;英文月份名<br>NOW ( ) &#x2F;&#x2F;当前时间<br>SEC_TO_TIME (seconds ) &#x2F;&#x2F;秒数转成时间<br>STR_TO_DATE (string ,format ) &#x2F;&#x2F;字串转成时间,以format格式显示<br>TIMEDIFF (datetime1 ,datetime2 ) &#x2F;&#x2F;两个时间差<br>TIME_TO_SEC (time ) &#x2F;&#x2F;时间转秒数]<br>WEEK (date_time [,start_of_week ]) &#x2F;&#x2F;第几周<br>YEAR (datetime ) &#x2F;&#x2F;年份<br>DAYOFMONTH(datetime) &#x2F;&#x2F;月的第几天<br>HOUR(datetime) &#x2F;&#x2F;小时<br>LAST_DAY(date) &#x2F;&#x2F;date的月的最后日期<br>MICROSECOND(datetime) &#x2F;&#x2F;微秒<br>MONTH(datetime) &#x2F;&#x2F;月</p>\n</blockquote>\n</li>\n</ol>\n<!--http://www.cnblogs.com/mark-chan/p/5384139.html-->\n\n<h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h2><pre><code>单行：--或 #\n多行：/*  */ \n</code></pre>\n<h2 id=\"mybatis调用存储过程\"><a href=\"#mybatis调用存储过程\" class=\"headerlink\" title=\"mybatis调用存储过程\"></a>mybatis调用存储过程</h2><pre><code>&lt;select id=&quot;proFindUser&quot; resultMap=&quot;BaseResultMap&quot; statementType=&quot;CALLABLE&quot;&gt;\n    &#123;\n        CALL find_user(#&#123;uid,mode=IN,jdbcType=BIGINT&#125;,#&#123;name,mode=IN,jdbcType=VARCHAR&#125;)\n    &#125;\n&lt;/select&gt;\n</code></pre>\n"},{"title":"mysql事件","date":"2016-08-15T01:00:00.000Z","_content":"\n## mysql事件\n\n- 事件:  事件（event）是MySQL在相应的时刻调用的过程式数据库对象。一个事件可调用一次，也可周期性的启动，它由一个特定的线程来管理的，也就是所谓的“事件调度器”。\n  事件可以取代定时任务来执行的工作。\n\n## 事件的优缺点\n\n- 优点：\n  一些对数据定时性操作不再依赖外部程序，而直接使用数据库本身提供的功能。\n  可以实现每秒钟执行一个任务，这在一些对实时性要求较高的环境下就非常实用了。\n- 缺点：\n  定时触发，不可以调用。\n\n**`语法`**\n> DELIMITER $$\n> CREATE EVENT EVENT_NAME\n> ON SCHEDULE EVENT_SCHEDULE\n[ON COMPLETION [NOT] PRESERVE]\n[ENABLE | DISABLE]\n> DO\n> BEGIN\n> ....;   \n> END$$\n> DELIMITER ;\n\n**`详解`**\n\n1. EVENT_NAME：名称最大长度可以是64个字节。名字必须是当前Dateabase中唯一 建议规则：动作名称_（INTO/FROM_）表名_TIME\n2. EVENT_SCHEDULE：有两种设定计划任务的方式\n    1. AT 时间戳，用来完成单次的计划任务。\n    2. EVERY 时间（单位）的数量时间单位[STARTS 时间戳] [ENDS时间戳]，用来完成重复的计划任 YEAR，MONTH，DAY，HOUR，MINUTE\n       或者SECOND。\n3. ON COMPLETION [NOT] PRESERVE ：PRESERVE 当event到期了,event会被disable,但是该event还是会存在,而not\n   preserve该event会被自动删除掉.\n4. ENABLE\\DISABLE参数Enable和Disable表示设定事件的状态。Enable表示系统将执行这个事件。Disable表示系统不执行该事件。\n5. BEGIN....END 中可以调用存储过程。\n\n**`例子`**\n> DELIMITER $$\n> CREATE EVENT event_first\n> ON SCHEDULE AT '2017-09-05 19:00:57'\n> ON COMPLETION NOT PRESERVE\n> ENABLE\n> DO\n> BEGIN\n> INSERT INTO t_user_tem(id,uid,uname,`time`) VALUES (NULL,1,NULL,NOW());\n> END$$\n> DELIMITER ;\n\n\n> DELIMITER $$\n> CREATE EVENT event_first2\n> ON SCHEDULE every 1 minute\n> ON COMPLETION NOT PRESERVE\n> ENABLE\n> DO\n> BEGIN\n> INSERT INTO t_user_tem(id,uid,uname,`time`) VALUES (NULL,1,NULL,NOW());\n> END$$\n> DELIMITER ;\n\n\n> DELIMITER $$\n> CREATE EVENT event_first2\n> ON SCHEDULE every 30 SECOND STARTS '2017-09-05 19:00:00' ENDS '2017-09-05 19:10:00'\n> ON COMPLETION NOT PRESERVE\n> ENABLE\n> DO\n> BEGIN\n> INSERT INTO t_user_tem(id,uid,uname,`time`) VALUES (NULL,1,NULL,NOW());\n> END$$\n> DELIMITER ;","source":"_posts/mysql事件.md","raw":"---\ntitle: mysql事件\ndate: 2016-08-15 09:00:00\ncategories: 数据库\ntags:\n  - mysql\n---\n\n## mysql事件\n\n- 事件:  事件（event）是MySQL在相应的时刻调用的过程式数据库对象。一个事件可调用一次，也可周期性的启动，它由一个特定的线程来管理的，也就是所谓的“事件调度器”。\n  事件可以取代定时任务来执行的工作。\n\n## 事件的优缺点\n\n- 优点：\n  一些对数据定时性操作不再依赖外部程序，而直接使用数据库本身提供的功能。\n  可以实现每秒钟执行一个任务，这在一些对实时性要求较高的环境下就非常实用了。\n- 缺点：\n  定时触发，不可以调用。\n\n**`语法`**\n> DELIMITER $$\n> CREATE EVENT EVENT_NAME\n> ON SCHEDULE EVENT_SCHEDULE\n[ON COMPLETION [NOT] PRESERVE]\n[ENABLE | DISABLE]\n> DO\n> BEGIN\n> ....;   \n> END$$\n> DELIMITER ;\n\n**`详解`**\n\n1. EVENT_NAME：名称最大长度可以是64个字节。名字必须是当前Dateabase中唯一 建议规则：动作名称_（INTO/FROM_）表名_TIME\n2. EVENT_SCHEDULE：有两种设定计划任务的方式\n    1. AT 时间戳，用来完成单次的计划任务。\n    2. EVERY 时间（单位）的数量时间单位[STARTS 时间戳] [ENDS时间戳]，用来完成重复的计划任 YEAR，MONTH，DAY，HOUR，MINUTE\n       或者SECOND。\n3. ON COMPLETION [NOT] PRESERVE ：PRESERVE 当event到期了,event会被disable,但是该event还是会存在,而not\n   preserve该event会被自动删除掉.\n4. ENABLE\\DISABLE参数Enable和Disable表示设定事件的状态。Enable表示系统将执行这个事件。Disable表示系统不执行该事件。\n5. BEGIN....END 中可以调用存储过程。\n\n**`例子`**\n> DELIMITER $$\n> CREATE EVENT event_first\n> ON SCHEDULE AT '2017-09-05 19:00:57'\n> ON COMPLETION NOT PRESERVE\n> ENABLE\n> DO\n> BEGIN\n> INSERT INTO t_user_tem(id,uid,uname,`time`) VALUES (NULL,1,NULL,NOW());\n> END$$\n> DELIMITER ;\n\n\n> DELIMITER $$\n> CREATE EVENT event_first2\n> ON SCHEDULE every 1 minute\n> ON COMPLETION NOT PRESERVE\n> ENABLE\n> DO\n> BEGIN\n> INSERT INTO t_user_tem(id,uid,uname,`time`) VALUES (NULL,1,NULL,NOW());\n> END$$\n> DELIMITER ;\n\n\n> DELIMITER $$\n> CREATE EVENT event_first2\n> ON SCHEDULE every 30 SECOND STARTS '2017-09-05 19:00:00' ENDS '2017-09-05 19:10:00'\n> ON COMPLETION NOT PRESERVE\n> ENABLE\n> DO\n> BEGIN\n> INSERT INTO t_user_tem(id,uid,uname,`time`) VALUES (NULL,1,NULL,NOW());\n> END$$\n> DELIMITER ;","slug":"mysql事件","published":1,"updated":"2024-11-27T03:20:35.248Z","_id":"cm3zaz9c6000ntgu63rl7f1o7","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"mysql事件\"><a href=\"#mysql事件\" class=\"headerlink\" title=\"mysql事件\"></a>mysql事件</h2><ul>\n<li>事件:  事件（event）是MySQL在相应的时刻调用的过程式数据库对象。一个事件可调用一次，也可周期性的启动，它由一个特定的线程来管理的，也就是所谓的“事件调度器”。<br>事件可以取代定时任务来执行的工作。</li>\n</ul>\n<h2 id=\"事件的优缺点\"><a href=\"#事件的优缺点\" class=\"headerlink\" title=\"事件的优缺点\"></a>事件的优缺点</h2><ul>\n<li>优点：<br>一些对数据定时性操作不再依赖外部程序，而直接使用数据库本身提供的功能。<br>可以实现每秒钟执行一个任务，这在一些对实时性要求较高的环境下就非常实用了。</li>\n<li>缺点：<br>定时触发，不可以调用。</li>\n</ul>\n<p><strong><code>语法</code></strong></p>\n<blockquote>\n<p>DELIMITER $$<br>CREATE EVENT EVENT_NAME<br>ON SCHEDULE EVENT_SCHEDULE<br>[ON COMPLETION [NOT] PRESERVE]<br>[ENABLE | DISABLE]<br>DO<br>BEGIN<br>….;<br>END$$<br>DELIMITER ;</p>\n</blockquote>\n<p><strong><code>详解</code></strong></p>\n<ol>\n<li>EVENT_NAME：名称最大长度可以是64个字节。名字必须是当前Dateabase中唯一 建议规则：动作名称_（INTO&#x2F;FROM_）表名_TIME</li>\n<li>EVENT_SCHEDULE：有两种设定计划任务的方式<ol>\n<li>AT 时间戳，用来完成单次的计划任务。</li>\n<li>EVERY 时间（单位）的数量时间单位[STARTS 时间戳] [ENDS时间戳]，用来完成重复的计划任 YEAR，MONTH，DAY，HOUR，MINUTE<br>或者SECOND。</li>\n</ol>\n</li>\n<li>ON COMPLETION [NOT] PRESERVE ：PRESERVE 当event到期了,event会被disable,但是该event还是会存在,而not<br>preserve该event会被自动删除掉.</li>\n<li>ENABLE\\DISABLE参数Enable和Disable表示设定事件的状态。Enable表示系统将执行这个事件。Disable表示系统不执行该事件。</li>\n<li>BEGIN….END 中可以调用存储过程。</li>\n</ol>\n<p><strong><code>例子</code></strong></p>\n<blockquote>\n<p>DELIMITER $$<br>CREATE EVENT event_first<br>ON SCHEDULE AT ‘2017-09-05 19:00:57’<br>ON COMPLETION NOT PRESERVE<br>ENABLE<br>DO<br>BEGIN<br>INSERT INTO t_user_tem(id,uid,uname,<code>time</code>) VALUES (NULL,1,NULL,NOW());<br>END$$<br>DELIMITER ;</p>\n</blockquote>\n<blockquote>\n<p>DELIMITER $$<br>CREATE EVENT event_first2<br>ON SCHEDULE every 1 minute<br>ON COMPLETION NOT PRESERVE<br>ENABLE<br>DO<br>BEGIN<br>INSERT INTO t_user_tem(id,uid,uname,<code>time</code>) VALUES (NULL,1,NULL,NOW());<br>END$$<br>DELIMITER ;</p>\n</blockquote>\n<blockquote>\n<p>DELIMITER $$<br>CREATE EVENT event_first2<br>ON SCHEDULE every 30 SECOND STARTS ‘2017-09-05 19:00:00’ ENDS ‘2017-09-05 19:10:00’<br>ON COMPLETION NOT PRESERVE<br>ENABLE<br>DO<br>BEGIN<br>INSERT INTO t_user_tem(id,uid,uname,<code>time</code>) VALUES (NULL,1,NULL,NOW());<br>END$$<br>DELIMITER ;</p>\n</blockquote>\n","excerpt":"","more":"<h2 id=\"mysql事件\"><a href=\"#mysql事件\" class=\"headerlink\" title=\"mysql事件\"></a>mysql事件</h2><ul>\n<li>事件:  事件（event）是MySQL在相应的时刻调用的过程式数据库对象。一个事件可调用一次，也可周期性的启动，它由一个特定的线程来管理的，也就是所谓的“事件调度器”。<br>事件可以取代定时任务来执行的工作。</li>\n</ul>\n<h2 id=\"事件的优缺点\"><a href=\"#事件的优缺点\" class=\"headerlink\" title=\"事件的优缺点\"></a>事件的优缺点</h2><ul>\n<li>优点：<br>一些对数据定时性操作不再依赖外部程序，而直接使用数据库本身提供的功能。<br>可以实现每秒钟执行一个任务，这在一些对实时性要求较高的环境下就非常实用了。</li>\n<li>缺点：<br>定时触发，不可以调用。</li>\n</ul>\n<p><strong><code>语法</code></strong></p>\n<blockquote>\n<p>DELIMITER $$<br>CREATE EVENT EVENT_NAME<br>ON SCHEDULE EVENT_SCHEDULE<br>[ON COMPLETION [NOT] PRESERVE]<br>[ENABLE | DISABLE]<br>DO<br>BEGIN<br>….;<br>END$$<br>DELIMITER ;</p>\n</blockquote>\n<p><strong><code>详解</code></strong></p>\n<ol>\n<li>EVENT_NAME：名称最大长度可以是64个字节。名字必须是当前Dateabase中唯一 建议规则：动作名称_（INTO&#x2F;FROM_）表名_TIME</li>\n<li>EVENT_SCHEDULE：有两种设定计划任务的方式<ol>\n<li>AT 时间戳，用来完成单次的计划任务。</li>\n<li>EVERY 时间（单位）的数量时间单位[STARTS 时间戳] [ENDS时间戳]，用来完成重复的计划任 YEAR，MONTH，DAY，HOUR，MINUTE<br>或者SECOND。</li>\n</ol>\n</li>\n<li>ON COMPLETION [NOT] PRESERVE ：PRESERVE 当event到期了,event会被disable,但是该event还是会存在,而not<br>preserve该event会被自动删除掉.</li>\n<li>ENABLE\\DISABLE参数Enable和Disable表示设定事件的状态。Enable表示系统将执行这个事件。Disable表示系统不执行该事件。</li>\n<li>BEGIN….END 中可以调用存储过程。</li>\n</ol>\n<p><strong><code>例子</code></strong></p>\n<blockquote>\n<p>DELIMITER $$<br>CREATE EVENT event_first<br>ON SCHEDULE AT ‘2017-09-05 19:00:57’<br>ON COMPLETION NOT PRESERVE<br>ENABLE<br>DO<br>BEGIN<br>INSERT INTO t_user_tem(id,uid,uname,<code>time</code>) VALUES (NULL,1,NULL,NOW());<br>END$$<br>DELIMITER ;</p>\n</blockquote>\n<blockquote>\n<p>DELIMITER $$<br>CREATE EVENT event_first2<br>ON SCHEDULE every 1 minute<br>ON COMPLETION NOT PRESERVE<br>ENABLE<br>DO<br>BEGIN<br>INSERT INTO t_user_tem(id,uid,uname,<code>time</code>) VALUES (NULL,1,NULL,NOW());<br>END$$<br>DELIMITER ;</p>\n</blockquote>\n<blockquote>\n<p>DELIMITER $$<br>CREATE EVENT event_first2<br>ON SCHEDULE every 30 SECOND STARTS ‘2017-09-05 19:00:00’ ENDS ‘2017-09-05 19:10:00’<br>ON COMPLETION NOT PRESERVE<br>ENABLE<br>DO<br>BEGIN<br>INSERT INTO t_user_tem(id,uid,uname,<code>time</code>) VALUES (NULL,1,NULL,NOW());<br>END$$<br>DELIMITER ;</p>\n</blockquote>\n"},{"title":"mysql的索引","date":"2016-08-01T01:00:00.000Z","_content":"\n## 索引是什么\n\n1. mysql索引:\n   是一种帮助mysql高效的获取数据的数据结构，这些数据结构以某种方式引用数据，这种结构就是索引。可简单理解为排好序的快速查找数据结构。如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。\n\n----------\n\n## 索引分类\n\n1. 单值索引:一个索引包含1个列 create index idx_XX on table(f1) 一个表可以建多个。\n2. 唯一索引: 索引列的值必须唯一，但允许有空值 create unique index idx_XX on table(f1)\n3. 复合索引: 一个索引包含多个列 如：create index idx_XX on table(f1,f2，..)\n\n----------\n\n## 索引结构\n\n1. BTree\n2. Hash索引\n3. full-text全文索引:\n\n----------\n\n## 什么情况建立索引\n\n1. 主键自动建立唯一索引\n2. 频繁作为查询条件的字段因该创建索引\n3. 查询中与其他表关联的字段，外键关系建立索引\n4. 频繁更新的字段不适合建立索引\n5. where条件里用不到的字段不建立索引\n6. 单键/复合索引的选择（高并发下倾向复合）\n7. 查询中排序的字段因建立索引\n8. 查询中统计或分组字段\n\n## 什么情况建不立索引\n\n1. 频繁增删改的表\n2. 表记录太少\n3. 数据重复且分布平均的表字段。（重复太多索引意义不大）\n\n----------\n\n## sql优化\n\n可以参考：{% post_link mysql的sql优化%}\n","source":"_posts/mysql的索引.md","raw":"---\ntitle: \"mysql的索引\"\ndate: 2016-08-01 09:00:00\ncategories: 数据库\ntags:\n  - mysql\n---\n\n## 索引是什么\n\n1. mysql索引:\n   是一种帮助mysql高效的获取数据的数据结构，这些数据结构以某种方式引用数据，这种结构就是索引。可简单理解为排好序的快速查找数据结构。如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。\n\n----------\n\n## 索引分类\n\n1. 单值索引:一个索引包含1个列 create index idx_XX on table(f1) 一个表可以建多个。\n2. 唯一索引: 索引列的值必须唯一，但允许有空值 create unique index idx_XX on table(f1)\n3. 复合索引: 一个索引包含多个列 如：create index idx_XX on table(f1,f2，..)\n\n----------\n\n## 索引结构\n\n1. BTree\n2. Hash索引\n3. full-text全文索引:\n\n----------\n\n## 什么情况建立索引\n\n1. 主键自动建立唯一索引\n2. 频繁作为查询条件的字段因该创建索引\n3. 查询中与其他表关联的字段，外键关系建立索引\n4. 频繁更新的字段不适合建立索引\n5. where条件里用不到的字段不建立索引\n6. 单键/复合索引的选择（高并发下倾向复合）\n7. 查询中排序的字段因建立索引\n8. 查询中统计或分组字段\n\n## 什么情况建不立索引\n\n1. 频繁增删改的表\n2. 表记录太少\n3. 数据重复且分布平均的表字段。（重复太多索引意义不大）\n\n----------\n\n## sql优化\n\n可以参考：{% post_link mysql的sql优化%}\n","slug":"mysql的索引","published":1,"updated":"2024-11-27T03:33:12.286Z","_id":"cm3zaz9c7000rtgu68k6b89fw","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"索引是什么\"><a href=\"#索引是什么\" class=\"headerlink\" title=\"索引是什么\"></a>索引是什么</h2><ol>\n<li>mysql索引:<br>是一种帮助mysql高效的获取数据的数据结构，这些数据结构以某种方式引用数据，这种结构就是索引。可简单理解为排好序的快速查找数据结构。如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。</li>\n</ol>\n<hr>\n<h2 id=\"索引分类\"><a href=\"#索引分类\" class=\"headerlink\" title=\"索引分类\"></a>索引分类</h2><ol>\n<li>单值索引:一个索引包含1个列 create index idx_XX on table(f1) 一个表可以建多个。</li>\n<li>唯一索引: 索引列的值必须唯一，但允许有空值 create unique index idx_XX on table(f1)</li>\n<li>复合索引: 一个索引包含多个列 如：create index idx_XX on table(f1,f2，..)</li>\n</ol>\n<hr>\n<h2 id=\"索引结构\"><a href=\"#索引结构\" class=\"headerlink\" title=\"索引结构\"></a>索引结构</h2><ol>\n<li>BTree</li>\n<li>Hash索引</li>\n<li>full-text全文索引:</li>\n</ol>\n<hr>\n<h2 id=\"什么情况建立索引\"><a href=\"#什么情况建立索引\" class=\"headerlink\" title=\"什么情况建立索引\"></a>什么情况建立索引</h2><ol>\n<li>主键自动建立唯一索引</li>\n<li>频繁作为查询条件的字段因该创建索引</li>\n<li>查询中与其他表关联的字段，外键关系建立索引</li>\n<li>频繁更新的字段不适合建立索引</li>\n<li>where条件里用不到的字段不建立索引</li>\n<li>单键&#x2F;复合索引的选择（高并发下倾向复合）</li>\n<li>查询中排序的字段因建立索引</li>\n<li>查询中统计或分组字段</li>\n</ol>\n<h2 id=\"什么情况建不立索引\"><a href=\"#什么情况建不立索引\" class=\"headerlink\" title=\"什么情况建不立索引\"></a>什么情况建不立索引</h2><ol>\n<li>频繁增删改的表</li>\n<li>表记录太少</li>\n<li>数据重复且分布平均的表字段。（重复太多索引意义不大）</li>\n</ol>\n<hr>\n<h2 id=\"sql优化\"><a href=\"#sql优化\" class=\"headerlink\" title=\"sql优化\"></a>sql优化</h2><p>可以参考：<a href=\"/2016/08/03/mysql%E7%9A%84sql%E4%BC%98%E5%8C%96/\" title=\"mysql的sql优化\">mysql的sql优化</a></p>\n","excerpt":"","more":"<h2 id=\"索引是什么\"><a href=\"#索引是什么\" class=\"headerlink\" title=\"索引是什么\"></a>索引是什么</h2><ol>\n<li>mysql索引:<br>是一种帮助mysql高效的获取数据的数据结构，这些数据结构以某种方式引用数据，这种结构就是索引。可简单理解为排好序的快速查找数据结构。如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。</li>\n</ol>\n<hr>\n<h2 id=\"索引分类\"><a href=\"#索引分类\" class=\"headerlink\" title=\"索引分类\"></a>索引分类</h2><ol>\n<li>单值索引:一个索引包含1个列 create index idx_XX on table(f1) 一个表可以建多个。</li>\n<li>唯一索引: 索引列的值必须唯一，但允许有空值 create unique index idx_XX on table(f1)</li>\n<li>复合索引: 一个索引包含多个列 如：create index idx_XX on table(f1,f2，..)</li>\n</ol>\n<hr>\n<h2 id=\"索引结构\"><a href=\"#索引结构\" class=\"headerlink\" title=\"索引结构\"></a>索引结构</h2><ol>\n<li>BTree</li>\n<li>Hash索引</li>\n<li>full-text全文索引:</li>\n</ol>\n<hr>\n<h2 id=\"什么情况建立索引\"><a href=\"#什么情况建立索引\" class=\"headerlink\" title=\"什么情况建立索引\"></a>什么情况建立索引</h2><ol>\n<li>主键自动建立唯一索引</li>\n<li>频繁作为查询条件的字段因该创建索引</li>\n<li>查询中与其他表关联的字段，外键关系建立索引</li>\n<li>频繁更新的字段不适合建立索引</li>\n<li>where条件里用不到的字段不建立索引</li>\n<li>单键&#x2F;复合索引的选择（高并发下倾向复合）</li>\n<li>查询中排序的字段因建立索引</li>\n<li>查询中统计或分组字段</li>\n</ol>\n<h2 id=\"什么情况建不立索引\"><a href=\"#什么情况建不立索引\" class=\"headerlink\" title=\"什么情况建不立索引\"></a>什么情况建不立索引</h2><ol>\n<li>频繁增删改的表</li>\n<li>表记录太少</li>\n<li>数据重复且分布平均的表字段。（重复太多索引意义不大）</li>\n</ol>\n<hr>\n<h2 id=\"sql优化\"><a href=\"#sql优化\" class=\"headerlink\" title=\"sql优化\"></a>sql优化</h2><p>可以参考：<a href=\"/2016/08/03/mysql%E7%9A%84sql%E4%BC%98%E5%8C%96/\" title=\"mysql的sql优化\">mysql的sql优化</a></p>\n"},{"title":"mysql触发器","date":"2016-08-14T01:00:00.000Z","_content":"\n## mysql触发器\n\n- 触发器: 触发器是一种与表操作有关的数据库对象，当触发器所在表上出现指定事件时，将调用该对象，即表的操作事件触发表上的触发器的执行。\n\n**`语法`**\n> DELIMITER $$\n> CREATE\n> TRIGGER <TRIGGER Name> BEFORE/AFTER INSERT/UPDATE/DELETE\n> ON <Table Name>\n> FOR EACH ROW BEGIN\n> ....;\n> END$$\n> DELIMITER ;\n\n\t1.\tINSERT | UPDATE | DELETE --触发器有执行的时间设置：可以设置为事件发生前或后。\n\t2.\tINSERT | UPDATE | DELETE --同样也能设定触发的事件：它们可以在执行insert、update或delete的过程中触发。\n\t3.\tFOR EACH ROW  每行受影响，触发器都执行，叫行级触发器。\n\n**`例子`**\n> DELIMITER $$\n> CREATE\n> TRIGGER tir_first BEFORE DELETE ON t_user\n> FOR EACH ROW BEGIN\n> INSERT INTO t_user_tem(id,uid,uname) VALUES (NULL,OLD.id,OLD.name);\n> END$$\n> DELIMITER;\n\n**`变量详解`**\n\n1. DECLARE var_name[,...] type [DEFAULT value] 来定义一局部变量,只能在 BEGIN … END 复合语句中使用，并且应该定义在复合语句的开头\n2. SET var_name = expr [,var_name = expr] 采用SET语句对变量赋值。\n3. NEW 与 OLD和 MS SQL Server 中的 INSERTED 和 DELETED 类似，MySQL中定义了 NEW 和 OLD，用来表示触发器的所在表中，触发了触发器的那一行数据。\n   在 INSERT 型触发器中，NEW 用来表示将要（BEFORE）或已经（AFTER）插入的新数据；\n   在 UPDATE 型触发器中，OLD 用来表示将要或已经被修改的原数据，NEW 用来表示将要或已经修改为的新数据；\n   在 DELETE 型触发器中，OLD 用来表示将要或已经被删除的原数据；\n   使用方法： NEW.columnName （columnName 为相应数据表某一列名）另外，OLD 是只读的，而 NEW 则可以在触发器中使用 SET\n   赋值，这样不会再次触发触发器，造成循环调用。\n\n**`触发器的执行事物`**\nInnoDB 数据库会有事务回滚：\n\n\t①如果 BEFORE 触发器执行失败，SQL 无法正确执行。\n\t②SQL 执行失败时，AFTER 型触发器不会触发。\n\t③AFTER 类型的触发器执行失败，SQL 会回滚","source":"_posts/mysql触发器.md","raw":"---\ntitle: \"mysql触发器\"\ndate: 2016-08-14 09:00:00\ncategories: 数据库\ntags:\n  - mysql\n---\n\n## mysql触发器\n\n- 触发器: 触发器是一种与表操作有关的数据库对象，当触发器所在表上出现指定事件时，将调用该对象，即表的操作事件触发表上的触发器的执行。\n\n**`语法`**\n> DELIMITER $$\n> CREATE\n> TRIGGER <TRIGGER Name> BEFORE/AFTER INSERT/UPDATE/DELETE\n> ON <Table Name>\n> FOR EACH ROW BEGIN\n> ....;\n> END$$\n> DELIMITER ;\n\n\t1.\tINSERT | UPDATE | DELETE --触发器有执行的时间设置：可以设置为事件发生前或后。\n\t2.\tINSERT | UPDATE | DELETE --同样也能设定触发的事件：它们可以在执行insert、update或delete的过程中触发。\n\t3.\tFOR EACH ROW  每行受影响，触发器都执行，叫行级触发器。\n\n**`例子`**\n> DELIMITER $$\n> CREATE\n> TRIGGER tir_first BEFORE DELETE ON t_user\n> FOR EACH ROW BEGIN\n> INSERT INTO t_user_tem(id,uid,uname) VALUES (NULL,OLD.id,OLD.name);\n> END$$\n> DELIMITER;\n\n**`变量详解`**\n\n1. DECLARE var_name[,...] type [DEFAULT value] 来定义一局部变量,只能在 BEGIN … END 复合语句中使用，并且应该定义在复合语句的开头\n2. SET var_name = expr [,var_name = expr] 采用SET语句对变量赋值。\n3. NEW 与 OLD和 MS SQL Server 中的 INSERTED 和 DELETED 类似，MySQL中定义了 NEW 和 OLD，用来表示触发器的所在表中，触发了触发器的那一行数据。\n   在 INSERT 型触发器中，NEW 用来表示将要（BEFORE）或已经（AFTER）插入的新数据；\n   在 UPDATE 型触发器中，OLD 用来表示将要或已经被修改的原数据，NEW 用来表示将要或已经修改为的新数据；\n   在 DELETE 型触发器中，OLD 用来表示将要或已经被删除的原数据；\n   使用方法： NEW.columnName （columnName 为相应数据表某一列名）另外，OLD 是只读的，而 NEW 则可以在触发器中使用 SET\n   赋值，这样不会再次触发触发器，造成循环调用。\n\n**`触发器的执行事物`**\nInnoDB 数据库会有事务回滚：\n\n\t①如果 BEFORE 触发器执行失败，SQL 无法正确执行。\n\t②SQL 执行失败时，AFTER 型触发器不会触发。\n\t③AFTER 类型的触发器执行失败，SQL 会回滚","slug":"mysql触发器","published":1,"updated":"2024-11-27T03:20:35.288Z","_id":"cm3zaz9c7000ttgu6c6fl5h73","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"mysql触发器\"><a href=\"#mysql触发器\" class=\"headerlink\" title=\"mysql触发器\"></a>mysql触发器</h2><ul>\n<li>触发器: 触发器是一种与表操作有关的数据库对象，当触发器所在表上出现指定事件时，将调用该对象，即表的操作事件触发表上的触发器的执行。</li>\n</ul>\n<p><strong><code>语法</code></strong></p>\n<blockquote>\n<p>DELIMITER $$<br>CREATE<br>TRIGGER <TRIGGER Name> BEFORE&#x2F;AFTER INSERT&#x2F;UPDATE&#x2F;DELETE<br>ON <Table Name><br>FOR EACH ROW BEGIN<br>….;<br>END$$<br>DELIMITER ;</p>\n</blockquote>\n<pre><code>1.\tINSERT | UPDATE | DELETE --触发器有执行的时间设置：可以设置为事件发生前或后。\n2.\tINSERT | UPDATE | DELETE --同样也能设定触发的事件：它们可以在执行insert、update或delete的过程中触发。\n3.\tFOR EACH ROW  每行受影响，触发器都执行，叫行级触发器。\n</code></pre>\n<p><strong><code>例子</code></strong></p>\n<blockquote>\n<p>DELIMITER $$<br>CREATE<br>TRIGGER tir_first BEFORE DELETE ON t_user<br>FOR EACH ROW BEGIN<br>INSERT INTO t_user_tem(id,uid,uname) VALUES (NULL,OLD.id,OLD.name);<br>END$$<br>DELIMITER;</p>\n</blockquote>\n<p><strong><code>变量详解</code></strong></p>\n<ol>\n<li>DECLARE var_name[,…] type [DEFAULT value] 来定义一局部变量,只能在 BEGIN … END 复合语句中使用，并且应该定义在复合语句的开头</li>\n<li>SET var_name &#x3D; expr [,var_name &#x3D; expr] 采用SET语句对变量赋值。</li>\n<li>NEW 与 OLD和 MS SQL Server 中的 INSERTED 和 DELETED 类似，MySQL中定义了 NEW 和 OLD，用来表示触发器的所在表中，触发了触发器的那一行数据。<br>在 INSERT 型触发器中，NEW 用来表示将要（BEFORE）或已经（AFTER）插入的新数据；<br>在 UPDATE 型触发器中，OLD 用来表示将要或已经被修改的原数据，NEW 用来表示将要或已经修改为的新数据；<br>在 DELETE 型触发器中，OLD 用来表示将要或已经被删除的原数据；<br>使用方法： NEW.columnName （columnName 为相应数据表某一列名）另外，OLD 是只读的，而 NEW 则可以在触发器中使用 SET<br>赋值，这样不会再次触发触发器，造成循环调用。</li>\n</ol>\n<p><strong><code>触发器的执行事物</code></strong><br>InnoDB 数据库会有事务回滚：</p>\n<pre><code>①如果 BEFORE 触发器执行失败，SQL 无法正确执行。\n②SQL 执行失败时，AFTER 型触发器不会触发。\n③AFTER 类型的触发器执行失败，SQL 会回滚\n</code></pre>\n","excerpt":"","more":"<h2 id=\"mysql触发器\"><a href=\"#mysql触发器\" class=\"headerlink\" title=\"mysql触发器\"></a>mysql触发器</h2><ul>\n<li>触发器: 触发器是一种与表操作有关的数据库对象，当触发器所在表上出现指定事件时，将调用该对象，即表的操作事件触发表上的触发器的执行。</li>\n</ul>\n<p><strong><code>语法</code></strong></p>\n<blockquote>\n<p>DELIMITER $$<br>CREATE<br>TRIGGER <TRIGGER Name> BEFORE&#x2F;AFTER INSERT&#x2F;UPDATE&#x2F;DELETE<br>ON <Table Name><br>FOR EACH ROW BEGIN<br>….;<br>END$$<br>DELIMITER ;</p>\n</blockquote>\n<pre><code>1.\tINSERT | UPDATE | DELETE --触发器有执行的时间设置：可以设置为事件发生前或后。\n2.\tINSERT | UPDATE | DELETE --同样也能设定触发的事件：它们可以在执行insert、update或delete的过程中触发。\n3.\tFOR EACH ROW  每行受影响，触发器都执行，叫行级触发器。\n</code></pre>\n<p><strong><code>例子</code></strong></p>\n<blockquote>\n<p>DELIMITER $$<br>CREATE<br>TRIGGER tir_first BEFORE DELETE ON t_user<br>FOR EACH ROW BEGIN<br>INSERT INTO t_user_tem(id,uid,uname) VALUES (NULL,OLD.id,OLD.name);<br>END$$<br>DELIMITER;</p>\n</blockquote>\n<p><strong><code>变量详解</code></strong></p>\n<ol>\n<li>DECLARE var_name[,…] type [DEFAULT value] 来定义一局部变量,只能在 BEGIN … END 复合语句中使用，并且应该定义在复合语句的开头</li>\n<li>SET var_name &#x3D; expr [,var_name &#x3D; expr] 采用SET语句对变量赋值。</li>\n<li>NEW 与 OLD和 MS SQL Server 中的 INSERTED 和 DELETED 类似，MySQL中定义了 NEW 和 OLD，用来表示触发器的所在表中，触发了触发器的那一行数据。<br>在 INSERT 型触发器中，NEW 用来表示将要（BEFORE）或已经（AFTER）插入的新数据；<br>在 UPDATE 型触发器中，OLD 用来表示将要或已经被修改的原数据，NEW 用来表示将要或已经修改为的新数据；<br>在 DELETE 型触发器中，OLD 用来表示将要或已经被删除的原数据；<br>使用方法： NEW.columnName （columnName 为相应数据表某一列名）另外，OLD 是只读的，而 NEW 则可以在触发器中使用 SET<br>赋值，这样不会再次触发触发器，造成循环调用。</li>\n</ol>\n<p><strong><code>触发器的执行事物</code></strong><br>InnoDB 数据库会有事务回滚：</p>\n<pre><code>①如果 BEFORE 触发器执行失败，SQL 无法正确执行。\n②SQL 执行失败时，AFTER 型触发器不会触发。\n③AFTER 类型的触发器执行失败，SQL 会回滚\n</code></pre>\n"},{"title":"mysql的sql优化","date":"2016-08-03T01:00:00.000Z","_content":"\n## 单值索引和复合索引的区别\n\n1. 首先来看没有索引的情况：可以看出 type 为 all 是全表扫描性能不高，优化就是建立索引。\n\n> EXPLAIN SELECT address,`name` FROM t_user u WHERE u.address='成都' AND u.name='haha'\n\n\t![](../images/mysql/y_h_1.jpg)\n\n----------\n\n2. 来看创建两个单值索引的情况：看到possible_keys为 idx_a,idx_n 但是key为idx_a说明只用了一个索引另一个索引没有使用（mysql会自动使用最优的索引）\n\n> CREATE INDEX idx_a ON t_user(address);\n> CREATE INDEX idx_n ON t_user(`name`);\n> EXPLAIN SELECT address,`name` FROM t_user u WHERE u.address='成都' AND u.name='haha'\n\n\t![](../images/mysql/y_h_2.jpg)\n\n----------\n\n3. 来看创建一个复合索引的情况：key为idx_a_n说明用了索引,ref为 const,const 说名这个复合索引对这两个字段都起作用。Extra中有Using\n   index（覆盖索引）sql性能很好。\n\n> CREATE INDEX idx_a_n ON t_user(address,`name`);\n> EXPLAIN SELECT address,`name` FROM t_user u WHERE u.address='成都' AND u.name='haha'\n\n\t![](../images/mysql/y_h_3.jpg)\n\n \n----------\n\n## join连接索引优化\n\n1. left join使用索引，索引应建立在右边。\n\n> 分析“FROM t_user u LEFT JOIN t_user_role ur ON u.id=ur.user_id LEFT JOIN t_role r ON ur.role_id =r.id”索引该如何建立.\n> 1、“t_user u LEFT JOIN t_user_role” 所以“u.id=ur.user_id”中user_id应建索引\n> 2、“LEFT JOIN t_role”所以“ur.role_id =r.id”中id应建索引。因为id为主键所以本身就是主键索引。\n\n\t![](../images/mysql/y_h_5.jpg)\n\n \n----------\n\n2. RIGHT join使用索引，索引应建立在左边。\n\n> 同理分析“FROM t_user u RIGHT JOIN t_user_role ur ON u.id=ur.user_id RIGHT JOIN t_role r ON ur.role_id =r.id”索引该如何建立.\n> 1、“RIGHT JOIN t_user_role ur” 所以“ u.id=ur.user_id”中id应建索引，因为id为主键所以本身就是主键索引。\n> 2、“RIGHT JOIN t_role r”所以“ur.role_id =r.id”中role_id应建索引。\n\n\t![](../images/mysql/y_h_6.jpg)\n\n \n----------\n\n## 索引失效\n\n**`索引失效的大致情况如下`**\n![](../images/mysql/index_lose.png)\n1、如index(a,b,c)=> whereb=5 and c=6 b,c不会使用索引.因为缺少a。<br/>\n3、如index(a,b,c)=> where a=1 and b>5 and c=6 那么a,b会用到索引，c不会使用索引.<br/>\n7、可以使用覆盖索引的方式解决：like'%..%'索引失效。<br/>\n9、可以使用 union 带替代 or<br/>\n \n----------\n\n## index列子分析\n\nindex(c1,c2,c3,c4):order by\n> where c1>50 order by c2 出现:filesort。\n> where 1=1 order by c1 asc,c2 desc 出现:filesort。\n> where 1=1 order by c1 asc,c2 desc 出现:filesort。\n> where c1=\"c1\" and c5='c5' order by c3,c2 出现:filesort。\n> where c1=\"c1\" and c5='c5' order by c2,c3 不出现:filesort。\n> where c1=\"c1\" and c5='c5' and c2='c2' order by c3,c2 不出现:filesort。\n\n\nindex(c1,c2,c3,c4):group by\n> where c1=\"c1\" and c4='c4' group by c2,c3 不出现:filesort、temp\n> where c1=\"c1\" and c4='c4' group by c3,c2 出现:filesort、temp。\n> where c1=\"c1\" and c4='c4' and c2='c2' group by c2,c3 不出现:filesort、temp。\n\ngroup by:分组之前基本需要排序，可能会有临时表产生很耗性能。\n![](../images/mysql/y_h_8.jpg)\n![](../images/mysql/y_h_4.jpg)\n \n----------\n\n## 小表驱动大表\n\n![](../images/mysql/y_h_10.jpg)\n\n\texists不一定性能比in高，exists是in的一个变种替代。\n\n----------\n\n## 慢查询开启及分析\n\n![](../images/mysql/sql_slow.jpg)\n\n## profile\n\n> SHOW VARIABLES LIKE'profiling';\n> SET profiling=ON;\n> SHOW PROFILES;\n> SHOW PROFILE cpu,block io FOR QUERY Query_ID;或将 cpu,block io 改为 all\n\n若：Status中出现以下4个中一个必须优化。\n![](../images/mysql/y_h_7.jpg)\n \n----------\n\n## 全局查询日志\n\n> SET GLOBAL general_log=1;#0为关闭 1为开启\n> SET GLOBAL log_output='Table';\n\n执行：SELECT * FROM mysql.general_log; 将看到执行过的sql信息。<br>\nsql优化过程步骤：\n![](../images/mysql/y_h_9.jpg)\n\n## Mysql的锁\n\n![](../images/mysql/y_h_11.jpg)","source":"_posts/mysql的sql优化.md","raw":"---\ntitle: \"mysql的sql优化\"\ndate: 2016-08-03 09:00:00\ncategories: 数据库\ntags:\n  - mysql\n---\n\n## 单值索引和复合索引的区别\n\n1. 首先来看没有索引的情况：可以看出 type 为 all 是全表扫描性能不高，优化就是建立索引。\n\n> EXPLAIN SELECT address,`name` FROM t_user u WHERE u.address='成都' AND u.name='haha'\n\n\t![](../images/mysql/y_h_1.jpg)\n\n----------\n\n2. 来看创建两个单值索引的情况：看到possible_keys为 idx_a,idx_n 但是key为idx_a说明只用了一个索引另一个索引没有使用（mysql会自动使用最优的索引）\n\n> CREATE INDEX idx_a ON t_user(address);\n> CREATE INDEX idx_n ON t_user(`name`);\n> EXPLAIN SELECT address,`name` FROM t_user u WHERE u.address='成都' AND u.name='haha'\n\n\t![](../images/mysql/y_h_2.jpg)\n\n----------\n\n3. 来看创建一个复合索引的情况：key为idx_a_n说明用了索引,ref为 const,const 说名这个复合索引对这两个字段都起作用。Extra中有Using\n   index（覆盖索引）sql性能很好。\n\n> CREATE INDEX idx_a_n ON t_user(address,`name`);\n> EXPLAIN SELECT address,`name` FROM t_user u WHERE u.address='成都' AND u.name='haha'\n\n\t![](../images/mysql/y_h_3.jpg)\n\n \n----------\n\n## join连接索引优化\n\n1. left join使用索引，索引应建立在右边。\n\n> 分析“FROM t_user u LEFT JOIN t_user_role ur ON u.id=ur.user_id LEFT JOIN t_role r ON ur.role_id =r.id”索引该如何建立.\n> 1、“t_user u LEFT JOIN t_user_role” 所以“u.id=ur.user_id”中user_id应建索引\n> 2、“LEFT JOIN t_role”所以“ur.role_id =r.id”中id应建索引。因为id为主键所以本身就是主键索引。\n\n\t![](../images/mysql/y_h_5.jpg)\n\n \n----------\n\n2. RIGHT join使用索引，索引应建立在左边。\n\n> 同理分析“FROM t_user u RIGHT JOIN t_user_role ur ON u.id=ur.user_id RIGHT JOIN t_role r ON ur.role_id =r.id”索引该如何建立.\n> 1、“RIGHT JOIN t_user_role ur” 所以“ u.id=ur.user_id”中id应建索引，因为id为主键所以本身就是主键索引。\n> 2、“RIGHT JOIN t_role r”所以“ur.role_id =r.id”中role_id应建索引。\n\n\t![](../images/mysql/y_h_6.jpg)\n\n \n----------\n\n## 索引失效\n\n**`索引失效的大致情况如下`**\n![](../images/mysql/index_lose.png)\n1、如index(a,b,c)=> whereb=5 and c=6 b,c不会使用索引.因为缺少a。<br/>\n3、如index(a,b,c)=> where a=1 and b>5 and c=6 那么a,b会用到索引，c不会使用索引.<br/>\n7、可以使用覆盖索引的方式解决：like'%..%'索引失效。<br/>\n9、可以使用 union 带替代 or<br/>\n \n----------\n\n## index列子分析\n\nindex(c1,c2,c3,c4):order by\n> where c1>50 order by c2 出现:filesort。\n> where 1=1 order by c1 asc,c2 desc 出现:filesort。\n> where 1=1 order by c1 asc,c2 desc 出现:filesort。\n> where c1=\"c1\" and c5='c5' order by c3,c2 出现:filesort。\n> where c1=\"c1\" and c5='c5' order by c2,c3 不出现:filesort。\n> where c1=\"c1\" and c5='c5' and c2='c2' order by c3,c2 不出现:filesort。\n\n\nindex(c1,c2,c3,c4):group by\n> where c1=\"c1\" and c4='c4' group by c2,c3 不出现:filesort、temp\n> where c1=\"c1\" and c4='c4' group by c3,c2 出现:filesort、temp。\n> where c1=\"c1\" and c4='c4' and c2='c2' group by c2,c3 不出现:filesort、temp。\n\ngroup by:分组之前基本需要排序，可能会有临时表产生很耗性能。\n![](../images/mysql/y_h_8.jpg)\n![](../images/mysql/y_h_4.jpg)\n \n----------\n\n## 小表驱动大表\n\n![](../images/mysql/y_h_10.jpg)\n\n\texists不一定性能比in高，exists是in的一个变种替代。\n\n----------\n\n## 慢查询开启及分析\n\n![](../images/mysql/sql_slow.jpg)\n\n## profile\n\n> SHOW VARIABLES LIKE'profiling';\n> SET profiling=ON;\n> SHOW PROFILES;\n> SHOW PROFILE cpu,block io FOR QUERY Query_ID;或将 cpu,block io 改为 all\n\n若：Status中出现以下4个中一个必须优化。\n![](../images/mysql/y_h_7.jpg)\n \n----------\n\n## 全局查询日志\n\n> SET GLOBAL general_log=1;#0为关闭 1为开启\n> SET GLOBAL log_output='Table';\n\n执行：SELECT * FROM mysql.general_log; 将看到执行过的sql信息。<br>\nsql优化过程步骤：\n![](../images/mysql/y_h_9.jpg)\n\n## Mysql的锁\n\n![](../images/mysql/y_h_11.jpg)","slug":"mysql的sql优化","published":1,"updated":"2024-11-27T03:20:35.280Z","_id":"cm3zaz9c7000wtgu60poz6tww","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"单值索引和复合索引的区别\"><a href=\"#单值索引和复合索引的区别\" class=\"headerlink\" title=\"单值索引和复合索引的区别\"></a>单值索引和复合索引的区别</h2><ol>\n<li>首先来看没有索引的情况：可以看出 type 为 all 是全表扫描性能不高，优化就是建立索引。</li>\n</ol>\n<blockquote>\n<p>EXPLAIN SELECT address,<code>name</code> FROM t_user u WHERE u.address&#x3D;’成都’ AND u.name&#x3D;’haha’</p>\n</blockquote>\n<pre><code>![](../images/mysql/y_h_1.jpg)\n</code></pre>\n<hr>\n<ol start=\"2\">\n<li>来看创建两个单值索引的情况：看到possible_keys为 idx_a,idx_n 但是key为idx_a说明只用了一个索引另一个索引没有使用（mysql会自动使用最优的索引）</li>\n</ol>\n<blockquote>\n<p>CREATE INDEX idx_a ON t_user(address);<br>CREATE INDEX idx_n ON t_user(<code>name</code>);<br>EXPLAIN SELECT address,<code>name</code> FROM t_user u WHERE u.address&#x3D;’成都’ AND u.name&#x3D;’haha’</p>\n</blockquote>\n<pre><code>![](../images/mysql/y_h_2.jpg)\n</code></pre>\n<hr>\n<ol start=\"3\">\n<li>来看创建一个复合索引的情况：key为idx_a_n说明用了索引,ref为 const,const 说名这个复合索引对这两个字段都起作用。Extra中有Using<br>index（覆盖索引）sql性能很好。</li>\n</ol>\n<blockquote>\n<p>CREATE INDEX idx_a_n ON t_user(address,<code>name</code>);<br>EXPLAIN SELECT address,<code>name</code> FROM t_user u WHERE u.address&#x3D;’成都’ AND u.name&#x3D;’haha’</p>\n</blockquote>\n<pre><code>![](../images/mysql/y_h_3.jpg)\n</code></pre>\n<hr>\n<h2 id=\"join连接索引优化\"><a href=\"#join连接索引优化\" class=\"headerlink\" title=\"join连接索引优化\"></a>join连接索引优化</h2><ol>\n<li>left join使用索引，索引应建立在右边。</li>\n</ol>\n<blockquote>\n<p>分析“FROM t_user u LEFT JOIN t_user_role ur ON u.id&#x3D;ur.user_id LEFT JOIN t_role r ON ur.role_id &#x3D;r.id”索引该如何建立.<br>1、“t_user u LEFT JOIN t_user_role” 所以“u.id&#x3D;ur.user_id”中user_id应建索引<br>2、“LEFT JOIN t_role”所以“ur.role_id &#x3D;r.id”中id应建索引。因为id为主键所以本身就是主键索引。</p>\n</blockquote>\n<pre><code>![](../images/mysql/y_h_5.jpg)\n</code></pre>\n<hr>\n<ol start=\"2\">\n<li>RIGHT join使用索引，索引应建立在左边。</li>\n</ol>\n<blockquote>\n<p>同理分析“FROM t_user u RIGHT JOIN t_user_role ur ON u.id&#x3D;ur.user_id RIGHT JOIN t_role r ON ur.role_id &#x3D;r.id”索引该如何建立.<br>1、“RIGHT JOIN t_user_role ur” 所以“ u.id&#x3D;ur.user_id”中id应建索引，因为id为主键所以本身就是主键索引。<br>2、“RIGHT JOIN t_role r”所以“ur.role_id &#x3D;r.id”中role_id应建索引。</p>\n</blockquote>\n<pre><code>![](../images/mysql/y_h_6.jpg)\n</code></pre>\n<hr>\n<h2 id=\"索引失效\"><a href=\"#索引失效\" class=\"headerlink\" title=\"索引失效\"></a>索引失效</h2><h2 id=\"索引失效的大致情况如下1、如index-a-b-c-whereb-5-and-c-6-b-c不会使用索引-因为缺少a。3、如index-a-b-c-where-a-1-and-b-5-and-c-6-那么a-b会用到索引，c不会使用索引-7、可以使用覆盖索引的方式解决：like’-’索引失效。9、可以使用-union-带替代-or\"><a href=\"#索引失效的大致情况如下1、如index-a-b-c-whereb-5-and-c-6-b-c不会使用索引-因为缺少a。3、如index-a-b-c-where-a-1-and-b-5-and-c-6-那么a-b会用到索引，c不会使用索引-7、可以使用覆盖索引的方式解决：like’-’索引失效。9、可以使用-union-带替代-or\" class=\"headerlink\" title=\"索引失效的大致情况如下1、如index(a,b,c)&#x3D;&gt; whereb&#x3D;5 and c&#x3D;6 b,c不会使用索引.因为缺少a。3、如index(a,b,c)&#x3D;&gt; where a&#x3D;1 and b&gt;5 and c&#x3D;6 那么a,b会用到索引，c不会使用索引.7、可以使用覆盖索引的方式解决：like’%..%’索引失效。9、可以使用 union 带替代 or\n \"></a><strong><code>索引失效的大致情况如下</code></strong><br><img src=\"/../images/mysql/index_lose.png\"><br>1、如index(a,b,c)&#x3D;&gt; whereb&#x3D;5 and c&#x3D;6 b,c不会使用索引.因为缺少a。<br/><br>3、如index(a,b,c)&#x3D;&gt; where a&#x3D;1 and b&gt;5 and c&#x3D;6 那么a,b会用到索引，c不会使用索引.<br/><br>7、可以使用覆盖索引的方式解决：like’%..%’索引失效。<br/><br>9、可以使用 union 带替代 or<br/>\n </h2><h2 id=\"index列子分析\"><a href=\"#index列子分析\" class=\"headerlink\" title=\"index列子分析\"></a>index列子分析</h2><p>index(c1,c2,c3,c4):order by</p>\n<blockquote>\n<p>where c1&gt;50 order by c2 出现:filesort。<br>where 1&#x3D;1 order by c1 asc,c2 desc 出现:filesort。<br>where 1&#x3D;1 order by c1 asc,c2 desc 出现:filesort。<br>where c1&#x3D;”c1” and c5&#x3D;’c5’ order by c3,c2 出现:filesort。<br>where c1&#x3D;”c1” and c5&#x3D;’c5’ order by c2,c3 不出现:filesort。<br>where c1&#x3D;”c1” and c5&#x3D;’c5’ and c2&#x3D;’c2’ order by c3,c2 不出现:filesort。</p>\n</blockquote>\n<p>index(c1,c2,c3,c4):group by</p>\n<blockquote>\n<p>where c1&#x3D;”c1” and c4&#x3D;’c4’ group by c2,c3 不出现:filesort、temp<br>where c1&#x3D;”c1” and c4&#x3D;’c4’ group by c3,c2 出现:filesort、temp。<br>where c1&#x3D;”c1” and c4&#x3D;’c4’ and c2&#x3D;’c2’ group by c2,c3 不出现:filesort、temp。</p>\n</blockquote>\n<h2 id=\"group-by-分组之前基本需要排序，可能会有临时表产生很耗性能。\"><a href=\"#group-by-分组之前基本需要排序，可能会有临时表产生很耗性能。\" class=\"headerlink\" title=\"group by:分组之前基本需要排序，可能会有临时表产生很耗性能。\n \"></a>group by:分组之前基本需要排序，可能会有临时表产生很耗性能。<br><img src=\"/../images/mysql/y_h_8.jpg\"><br><img src=\"/../images/mysql/y_h_4.jpg\">\n </h2><h2 id=\"小表驱动大表\"><a href=\"#小表驱动大表\" class=\"headerlink\" title=\"小表驱动大表\"></a>小表驱动大表</h2><p><img src=\"/../images/mysql/y_h_10.jpg\"></p>\n<pre><code>exists不一定性能比in高，exists是in的一个变种替代。\n</code></pre>\n<hr>\n<h2 id=\"慢查询开启及分析\"><a href=\"#慢查询开启及分析\" class=\"headerlink\" title=\"慢查询开启及分析\"></a>慢查询开启及分析</h2><p><img src=\"/../images/mysql/sql_slow.jpg\"></p>\n<h2 id=\"profile\"><a href=\"#profile\" class=\"headerlink\" title=\"profile\"></a>profile</h2><blockquote>\n<p>SHOW VARIABLES LIKE’profiling’;<br>SET profiling&#x3D;ON;<br>SHOW PROFILES;<br>SHOW PROFILE cpu,block io FOR QUERY Query_ID;或将 cpu,block io 改为 all</p>\n</blockquote>\n<h2 id=\"若：Status中出现以下4个中一个必须优化。\"><a href=\"#若：Status中出现以下4个中一个必须优化。\" class=\"headerlink\" title=\"若：Status中出现以下4个中一个必须优化。\n \"></a>若：Status中出现以下4个中一个必须优化。<br><img src=\"/../images/mysql/y_h_7.jpg\">\n </h2><h2 id=\"全局查询日志\"><a href=\"#全局查询日志\" class=\"headerlink\" title=\"全局查询日志\"></a>全局查询日志</h2><blockquote>\n<p>SET GLOBAL general_log&#x3D;1;#0为关闭 1为开启<br>SET GLOBAL log_output&#x3D;’Table’;</p>\n</blockquote>\n<p>执行：SELECT * FROM mysql.general_log; 将看到执行过的sql信息。<br><br>sql优化过程步骤：<br><img src=\"/../images/mysql/y_h_9.jpg\"></p>\n<h2 id=\"Mysql的锁\"><a href=\"#Mysql的锁\" class=\"headerlink\" title=\"Mysql的锁\"></a>Mysql的锁</h2><p><img src=\"/../images/mysql/y_h_11.jpg\"></p>\n","excerpt":"","more":"<h2 id=\"单值索引和复合索引的区别\"><a href=\"#单值索引和复合索引的区别\" class=\"headerlink\" title=\"单值索引和复合索引的区别\"></a>单值索引和复合索引的区别</h2><ol>\n<li>首先来看没有索引的情况：可以看出 type 为 all 是全表扫描性能不高，优化就是建立索引。</li>\n</ol>\n<blockquote>\n<p>EXPLAIN SELECT address,<code>name</code> FROM t_user u WHERE u.address&#x3D;’成都’ AND u.name&#x3D;’haha’</p>\n</blockquote>\n<pre><code>![](../images/mysql/y_h_1.jpg)\n</code></pre>\n<hr>\n<ol start=\"2\">\n<li>来看创建两个单值索引的情况：看到possible_keys为 idx_a,idx_n 但是key为idx_a说明只用了一个索引另一个索引没有使用（mysql会自动使用最优的索引）</li>\n</ol>\n<blockquote>\n<p>CREATE INDEX idx_a ON t_user(address);<br>CREATE INDEX idx_n ON t_user(<code>name</code>);<br>EXPLAIN SELECT address,<code>name</code> FROM t_user u WHERE u.address&#x3D;’成都’ AND u.name&#x3D;’haha’</p>\n</blockquote>\n<pre><code>![](../images/mysql/y_h_2.jpg)\n</code></pre>\n<hr>\n<ol start=\"3\">\n<li>来看创建一个复合索引的情况：key为idx_a_n说明用了索引,ref为 const,const 说名这个复合索引对这两个字段都起作用。Extra中有Using<br>index（覆盖索引）sql性能很好。</li>\n</ol>\n<blockquote>\n<p>CREATE INDEX idx_a_n ON t_user(address,<code>name</code>);<br>EXPLAIN SELECT address,<code>name</code> FROM t_user u WHERE u.address&#x3D;’成都’ AND u.name&#x3D;’haha’</p>\n</blockquote>\n<pre><code>![](../images/mysql/y_h_3.jpg)\n</code></pre>\n<hr>\n<h2 id=\"join连接索引优化\"><a href=\"#join连接索引优化\" class=\"headerlink\" title=\"join连接索引优化\"></a>join连接索引优化</h2><ol>\n<li>left join使用索引，索引应建立在右边。</li>\n</ol>\n<blockquote>\n<p>分析“FROM t_user u LEFT JOIN t_user_role ur ON u.id&#x3D;ur.user_id LEFT JOIN t_role r ON ur.role_id &#x3D;r.id”索引该如何建立.<br>1、“t_user u LEFT JOIN t_user_role” 所以“u.id&#x3D;ur.user_id”中user_id应建索引<br>2、“LEFT JOIN t_role”所以“ur.role_id &#x3D;r.id”中id应建索引。因为id为主键所以本身就是主键索引。</p>\n</blockquote>\n<pre><code>![](../images/mysql/y_h_5.jpg)\n</code></pre>\n<hr>\n<ol start=\"2\">\n<li>RIGHT join使用索引，索引应建立在左边。</li>\n</ol>\n<blockquote>\n<p>同理分析“FROM t_user u RIGHT JOIN t_user_role ur ON u.id&#x3D;ur.user_id RIGHT JOIN t_role r ON ur.role_id &#x3D;r.id”索引该如何建立.<br>1、“RIGHT JOIN t_user_role ur” 所以“ u.id&#x3D;ur.user_id”中id应建索引，因为id为主键所以本身就是主键索引。<br>2、“RIGHT JOIN t_role r”所以“ur.role_id &#x3D;r.id”中role_id应建索引。</p>\n</blockquote>\n<pre><code>![](../images/mysql/y_h_6.jpg)\n</code></pre>\n<hr>\n<h2 id=\"索引失效\"><a href=\"#索引失效\" class=\"headerlink\" title=\"索引失效\"></a>索引失效</h2><h2 id=\"索引失效的大致情况如下1、如index-a-b-c-whereb-5-and-c-6-b-c不会使用索引-因为缺少a。3、如index-a-b-c-where-a-1-and-b-5-and-c-6-那么a-b会用到索引，c不会使用索引-7、可以使用覆盖索引的方式解决：like’-’索引失效。9、可以使用-union-带替代-or\"><a href=\"#索引失效的大致情况如下1、如index-a-b-c-whereb-5-and-c-6-b-c不会使用索引-因为缺少a。3、如index-a-b-c-where-a-1-and-b-5-and-c-6-那么a-b会用到索引，c不会使用索引-7、可以使用覆盖索引的方式解决：like’-’索引失效。9、可以使用-union-带替代-or\" class=\"headerlink\" title=\"索引失效的大致情况如下1、如index(a,b,c)&#x3D;&gt; whereb&#x3D;5 and c&#x3D;6 b,c不会使用索引.因为缺少a。3、如index(a,b,c)&#x3D;&gt; where a&#x3D;1 and b&gt;5 and c&#x3D;6 那么a,b会用到索引，c不会使用索引.7、可以使用覆盖索引的方式解决：like’%..%’索引失效。9、可以使用 union 带替代 or\n \"></a><strong><code>索引失效的大致情况如下</code></strong><br><img src=\"/../images/mysql/index_lose.png\"><br>1、如index(a,b,c)&#x3D;&gt; whereb&#x3D;5 and c&#x3D;6 b,c不会使用索引.因为缺少a。<br/><br>3、如index(a,b,c)&#x3D;&gt; where a&#x3D;1 and b&gt;5 and c&#x3D;6 那么a,b会用到索引，c不会使用索引.<br/><br>7、可以使用覆盖索引的方式解决：like’%..%’索引失效。<br/><br>9、可以使用 union 带替代 or<br/>\n </h2><h2 id=\"index列子分析\"><a href=\"#index列子分析\" class=\"headerlink\" title=\"index列子分析\"></a>index列子分析</h2><p>index(c1,c2,c3,c4):order by</p>\n<blockquote>\n<p>where c1&gt;50 order by c2 出现:filesort。<br>where 1&#x3D;1 order by c1 asc,c2 desc 出现:filesort。<br>where 1&#x3D;1 order by c1 asc,c2 desc 出现:filesort。<br>where c1&#x3D;”c1” and c5&#x3D;’c5’ order by c3,c2 出现:filesort。<br>where c1&#x3D;”c1” and c5&#x3D;’c5’ order by c2,c3 不出现:filesort。<br>where c1&#x3D;”c1” and c5&#x3D;’c5’ and c2&#x3D;’c2’ order by c3,c2 不出现:filesort。</p>\n</blockquote>\n<p>index(c1,c2,c3,c4):group by</p>\n<blockquote>\n<p>where c1&#x3D;”c1” and c4&#x3D;’c4’ group by c2,c3 不出现:filesort、temp<br>where c1&#x3D;”c1” and c4&#x3D;’c4’ group by c3,c2 出现:filesort、temp。<br>where c1&#x3D;”c1” and c4&#x3D;’c4’ and c2&#x3D;’c2’ group by c2,c3 不出现:filesort、temp。</p>\n</blockquote>\n<h2 id=\"group-by-分组之前基本需要排序，可能会有临时表产生很耗性能。\"><a href=\"#group-by-分组之前基本需要排序，可能会有临时表产生很耗性能。\" class=\"headerlink\" title=\"group by:分组之前基本需要排序，可能会有临时表产生很耗性能。\n \"></a>group by:分组之前基本需要排序，可能会有临时表产生很耗性能。<br><img src=\"/../images/mysql/y_h_8.jpg\"><br><img src=\"/../images/mysql/y_h_4.jpg\">\n </h2><h2 id=\"小表驱动大表\"><a href=\"#小表驱动大表\" class=\"headerlink\" title=\"小表驱动大表\"></a>小表驱动大表</h2><p><img src=\"/../images/mysql/y_h_10.jpg\"></p>\n<pre><code>exists不一定性能比in高，exists是in的一个变种替代。\n</code></pre>\n<hr>\n<h2 id=\"慢查询开启及分析\"><a href=\"#慢查询开启及分析\" class=\"headerlink\" title=\"慢查询开启及分析\"></a>慢查询开启及分析</h2><p><img src=\"/../images/mysql/sql_slow.jpg\"></p>\n<h2 id=\"profile\"><a href=\"#profile\" class=\"headerlink\" title=\"profile\"></a>profile</h2><blockquote>\n<p>SHOW VARIABLES LIKE’profiling’;<br>SET profiling&#x3D;ON;<br>SHOW PROFILES;<br>SHOW PROFILE cpu,block io FOR QUERY Query_ID;或将 cpu,block io 改为 all</p>\n</blockquote>\n<h2 id=\"若：Status中出现以下4个中一个必须优化。\"><a href=\"#若：Status中出现以下4个中一个必须优化。\" class=\"headerlink\" title=\"若：Status中出现以下4个中一个必须优化。\n \"></a>若：Status中出现以下4个中一个必须优化。<br><img src=\"/../images/mysql/y_h_7.jpg\">\n </h2><h2 id=\"全局查询日志\"><a href=\"#全局查询日志\" class=\"headerlink\" title=\"全局查询日志\"></a>全局查询日志</h2><blockquote>\n<p>SET GLOBAL general_log&#x3D;1;#0为关闭 1为开启<br>SET GLOBAL log_output&#x3D;’Table’;</p>\n</blockquote>\n<p>执行：SELECT * FROM mysql.general_log; 将看到执行过的sql信息。<br><br>sql优化过程步骤：<br><img src=\"/../images/mysql/y_h_9.jpg\"></p>\n<h2 id=\"Mysql的锁\"><a href=\"#Mysql的锁\" class=\"headerlink\" title=\"Mysql的锁\"></a>Mysql的锁</h2><p><img src=\"/../images/mysql/y_h_11.jpg\"></p>\n"},{"title":"mysql自定义函数","date":"2016-08-11T01:00:00.000Z","_content":"\n## 自定义函数\n\n- 自定义函数:  自定义函数 (user-defined function UDF)就是用一个象ABS() 或 CONCAT()\n  这样的固有（内建）函数一样作用的新函数去扩展MySQL。所以UDF是对MySQL功能的一个扩展\n\n**`语法`**\n> DELIMITER $$\n> CREATE\n> FUNCTION FUNCTION_NAME(PARAM TYPE,[PARAM TYPE,...])\n> RETURNS TYPE\n> BEGIN\n> ...........;\n> END$$\n> DELIMITER ;\n\n----------\n\n**`详解`**\n\n1. FUNCTION_NAME：名字必须是当前Dateabase中唯一\n2. PARAM：参数名\n3. PARAM TYPE：TYPE是参数类型，如 VARCHAR\n4. RETURNS TYPE：返回类型，如 VARCHAR\n\n**`变量和控制流程`**\n\n1. mysql的变量设置，流程控制。在**`存储过程`**、**`函数`**、**`事件`**、**`触发器`**\n   中的脚本规则都是一样的，可以参考：{% post_link mysql存储过程 %}\n\n----------\n\n**`例子`**\n> DELIMITER $$\n> CREATE\n> FUNCTION func(str VARCHAR(10))\n> RETURNS VARCHAR(100)\n> BEGIN\n> RETURN CONCAT(str,', hi');\n> END$$\n> DELIMITER ;\n\n----------\n\n**`删除`**\n> DROP FUNCTION FUNCTION_NAME;","source":"_posts/mysql自定义函数.md","raw":"---\ntitle: \"mysql自定义函数\"\ndate: 2016-08-11 09:00:00\ncategories: 数据库\ntags:\n  - mysql\n---\n\n## 自定义函数\n\n- 自定义函数:  自定义函数 (user-defined function UDF)就是用一个象ABS() 或 CONCAT()\n  这样的固有（内建）函数一样作用的新函数去扩展MySQL。所以UDF是对MySQL功能的一个扩展\n\n**`语法`**\n> DELIMITER $$\n> CREATE\n> FUNCTION FUNCTION_NAME(PARAM TYPE,[PARAM TYPE,...])\n> RETURNS TYPE\n> BEGIN\n> ...........;\n> END$$\n> DELIMITER ;\n\n----------\n\n**`详解`**\n\n1. FUNCTION_NAME：名字必须是当前Dateabase中唯一\n2. PARAM：参数名\n3. PARAM TYPE：TYPE是参数类型，如 VARCHAR\n4. RETURNS TYPE：返回类型，如 VARCHAR\n\n**`变量和控制流程`**\n\n1. mysql的变量设置，流程控制。在**`存储过程`**、**`函数`**、**`事件`**、**`触发器`**\n   中的脚本规则都是一样的，可以参考：{% post_link mysql存储过程 %}\n\n----------\n\n**`例子`**\n> DELIMITER $$\n> CREATE\n> FUNCTION func(str VARCHAR(10))\n> RETURNS VARCHAR(100)\n> BEGIN\n> RETURN CONCAT(str,', hi');\n> END$$\n> DELIMITER ;\n\n----------\n\n**`删除`**\n> DROP FUNCTION FUNCTION_NAME;","slug":"mysql自定义函数","published":1,"updated":"2024-11-27T03:33:45.046Z","_id":"cm3zaz9c8000ztgu64mke1hth","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"自定义函数\"><a href=\"#自定义函数\" class=\"headerlink\" title=\"自定义函数\"></a>自定义函数</h2><ul>\n<li>自定义函数:  自定义函数 (user-defined function UDF)就是用一个象ABS() 或 CONCAT()<br>这样的固有（内建）函数一样作用的新函数去扩展MySQL。所以UDF是对MySQL功能的一个扩展</li>\n</ul>\n<p><strong><code>语法</code></strong></p>\n<blockquote>\n<p>DELIMITER $$<br>CREATE<br>FUNCTION FUNCTION_NAME(PARAM TYPE,[PARAM TYPE,…])<br>RETURNS TYPE<br>BEGIN<br>………..;<br>END$$<br>DELIMITER ;</p>\n</blockquote>\n<hr>\n<p><strong><code>详解</code></strong></p>\n<ol>\n<li>FUNCTION_NAME：名字必须是当前Dateabase中唯一</li>\n<li>PARAM：参数名</li>\n<li>PARAM TYPE：TYPE是参数类型，如 VARCHAR</li>\n<li>RETURNS TYPE：返回类型，如 VARCHAR</li>\n</ol>\n<p><strong><code>变量和控制流程</code></strong></p>\n<ol>\n<li>mysql的变量设置，流程控制。在**<code>存储过程</code><strong>、</strong><code>函数</code><strong>、</strong><code>事件</code><strong>、</strong><code>触发器</code>**<br>中的脚本规则都是一样的，可以参考：<a href=\"/2016/08/12/mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/\" title=\"mysql存储过程\">mysql存储过程</a></li>\n</ol>\n<hr>\n<p><strong><code>例子</code></strong></p>\n<blockquote>\n<p>DELIMITER $$<br>CREATE<br>FUNCTION func(str VARCHAR(10))<br>RETURNS VARCHAR(100)<br>BEGIN<br>RETURN CONCAT(str,’, hi’);<br>END$$<br>DELIMITER ;</p>\n</blockquote>\n<hr>\n<p><strong><code>删除</code></strong></p>\n<blockquote>\n<p>DROP FUNCTION FUNCTION_NAME;</p>\n</blockquote>\n","excerpt":"","more":"<h2 id=\"自定义函数\"><a href=\"#自定义函数\" class=\"headerlink\" title=\"自定义函数\"></a>自定义函数</h2><ul>\n<li>自定义函数:  自定义函数 (user-defined function UDF)就是用一个象ABS() 或 CONCAT()<br>这样的固有（内建）函数一样作用的新函数去扩展MySQL。所以UDF是对MySQL功能的一个扩展</li>\n</ul>\n<p><strong><code>语法</code></strong></p>\n<blockquote>\n<p>DELIMITER $$<br>CREATE<br>FUNCTION FUNCTION_NAME(PARAM TYPE,[PARAM TYPE,…])<br>RETURNS TYPE<br>BEGIN<br>………..;<br>END$$<br>DELIMITER ;</p>\n</blockquote>\n<hr>\n<p><strong><code>详解</code></strong></p>\n<ol>\n<li>FUNCTION_NAME：名字必须是当前Dateabase中唯一</li>\n<li>PARAM：参数名</li>\n<li>PARAM TYPE：TYPE是参数类型，如 VARCHAR</li>\n<li>RETURNS TYPE：返回类型，如 VARCHAR</li>\n</ol>\n<p><strong><code>变量和控制流程</code></strong></p>\n<ol>\n<li>mysql的变量设置，流程控制。在**<code>存储过程</code><strong>、</strong><code>函数</code><strong>、</strong><code>事件</code><strong>、</strong><code>触发器</code>**<br>中的脚本规则都是一样的，可以参考：<a href=\"/2016/08/12/mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/\" title=\"mysql存储过程\">mysql存储过程</a></li>\n</ol>\n<hr>\n<p><strong><code>例子</code></strong></p>\n<blockquote>\n<p>DELIMITER $$<br>CREATE<br>FUNCTION func(str VARCHAR(10))<br>RETURNS VARCHAR(100)<br>BEGIN<br>RETURN CONCAT(str,’, hi’);<br>END$$<br>DELIMITER ;</p>\n</blockquote>\n<hr>\n<p><strong><code>删除</code></strong></p>\n<blockquote>\n<p>DROP FUNCTION FUNCTION_NAME;</p>\n</blockquote>\n"},{"title":"spring单元测试","date":"2017-10-17T01:00:00.000Z","_content":"\n## spring 单元测试\n\n    package com.demo.test;\n\timport org.junit.Test;\n\timport org.junit.runner.RunWith;\n\timport org.springframework.test.context.ContextConfiguration;\n\timport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\t\n\t@RunWith(SpringJUnit4ClassRunner.class)\n\t@ContextConfiguration(\"classpath:spring-mybatis.xml\")\n\tpublic class TestService {\n\t\t@Test\n\t\tpublic void testproFindUser() {\n\t\t\tSystem.out.println();\n\t\t}\n\t\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:spring-mybatis.xml\");\n\t\tcontext.start();\n\t}\n","source":"_posts/spring单元测试.md","raw":"---\ntitle: \"spring单元测试\"\ndate: 2017-10-17 09:00:00\ncategories: Spring\ntags:\n  - 单元测试\n---\n\n## spring 单元测试\n\n    package com.demo.test;\n\timport org.junit.Test;\n\timport org.junit.runner.RunWith;\n\timport org.springframework.test.context.ContextConfiguration;\n\timport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\t\n\t@RunWith(SpringJUnit4ClassRunner.class)\n\t@ContextConfiguration(\"classpath:spring-mybatis.xml\")\n\tpublic class TestService {\n\t\t@Test\n\t\tpublic void testproFindUser() {\n\t\t\tSystem.out.println();\n\t\t}\n\t\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:spring-mybatis.xml\");\n\t\tcontext.start();\n\t}\n","slug":"spring单元测试","published":1,"updated":"2024-11-27T03:20:35.295Z","_id":"cm3zaz9c80012tgu66de3b47z","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"spring-单元测试\"><a href=\"#spring-单元测试\" class=\"headerlink\" title=\"spring 单元测试\"></a>spring 单元测试</h2><pre><code>package com.demo.test;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(&quot;classpath:spring-mybatis.xml&quot;)\npublic class TestService &#123;\n    @Test\n    public void testproFindUser() &#123;\n        System.out.println();\n    &#125;\n\n&#125;\n\npublic static void main(String[] args) &#123;\n    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:spring-mybatis.xml&quot;);\n    context.start();\n&#125;\n</code></pre>\n","excerpt":"","more":"<h2 id=\"spring-单元测试\"><a href=\"#spring-单元测试\" class=\"headerlink\" title=\"spring 单元测试\"></a>spring 单元测试</h2><pre><code>package com.demo.test;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(&quot;classpath:spring-mybatis.xml&quot;)\npublic class TestService &#123;\n    @Test\n    public void testproFindUser() &#123;\n        System.out.println();\n    &#125;\n\n&#125;\n\npublic static void main(String[] args) &#123;\n    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:spring-mybatis.xml&quot;);\n    context.start();\n&#125;\n</code></pre>\n"},{"layout":"post","title":"mysql视图","date":"2016-08-13T01:00:00.000Z","_content":" \n## mysql视图\n\n- 视图: 视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。\n\n**`为什么使用视图`**\n> 1、重用sql语句。\n> 2、简化复杂的sql操作。在编写查询后，可以很方便的重用他，而不必知道他的基本查询细节。\n> 3、使用表的组成部分而不是整个表。\n> 4、保护数据。可以给用户授予表的特定部分的访问权限。\n> 5、更改数据的格式和表示。视图可返回与底层表的表示与格式不同的数据。\n\n**`规则和限制`**\n> 1、与表一样视图必须唯一命名。（不能给视图取和别的视图或者是表相同的名字）\n> 2、对于可以创建的视图个数是没有限制的。\n> 3、为了创建视图，必须有足够的权限，这些权限是有数据库管理员授予的。\n> 4、视图可以嵌套，即可以利用从其他视图中检索数据的查询来构建一视图。\n> 5、ORDER BY可以使用在视图上，但是如果从该视图中检索数据的SELECT中如果也包含ORDER BY 语句，则视图中的ORDER 将会被覆盖。\n> 6、视图不能有索引，也不能有关联的触发器或默认值。\n> 7、视图可以和表一起使用。例如，编写一条连接视图与表的SELECT语句。\n> 8、视图是不允许数据修改的（除了只从一个实表抽出若干列，而且没统计列和groupby，相关没涉及列修改符合表约束，这种视图部分DBMS允许修改）。\n\n**`视图的创建`**\n> CREATE VIEW view_name AS(\n> SELECT column_name(s)\n> FROM table_name\n> WHERE condition\n)\n\n**`使用视图`**\n> 1、使用CREATE VIEW来创建视图\n> 2、使用SHOW CREATE VIEW viewname，来查看创建视图的语句。\n> 3、使用DROP VIEW viewname来删除视图。\n> 4、更新视图的时候可以先用DROP 在用CREATE，也可以直接使用CREATE OR REPLACE VIEW\n> 。如果要更新的视图不存在，第二种更新的语句将会创建一个视图。如果更新的视图存在，则在第二条更新语句使用后将会替换以前的视图。\n\n\n**`分析视图`**\n\n1. 首先创建视图：\n2. 执行: EXPLAIN SELECT * FROM ur WHERE ur.uname='文杰'\n3. 结果: 看结果发现： ur.uname='文杰' 使用了全表扫描。\n   ![](../images/mysql/result1.jpg)\n\n3. 在真实表数据上创建索引视图能否使用呢：CREATE INDEX idx_name ON t_user (`name`);\n   看结果发现： ur.uname='文杰' 使用了索引。<br>\n   总结：查询视图的性能与组成视图的sql直接相关。当你查询视图的时候，数据库会先执行生成视图的语句，再在视图的基础上进行查询。\n   若视图数据列的来源列上建了索引（ur.uname和t_user.name的关系），那么视图也会使用索引。\n   ![](../images/mysql/result2.jpg)\n\n----------\n\n## mysql执行计划分析：\n\n![](../images/mysql/idx_.jpg)\n","source":"_posts/mysql视图.md","raw":"---\nlayout: post\ntitle: \"mysql视图\"\ndate: 2016-08-13 09:00:00\ncategories: 数据库\ntags:\n  - mysql\n---\n \n## mysql视图\n\n- 视图: 视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。\n\n**`为什么使用视图`**\n> 1、重用sql语句。\n> 2、简化复杂的sql操作。在编写查询后，可以很方便的重用他，而不必知道他的基本查询细节。\n> 3、使用表的组成部分而不是整个表。\n> 4、保护数据。可以给用户授予表的特定部分的访问权限。\n> 5、更改数据的格式和表示。视图可返回与底层表的表示与格式不同的数据。\n\n**`规则和限制`**\n> 1、与表一样视图必须唯一命名。（不能给视图取和别的视图或者是表相同的名字）\n> 2、对于可以创建的视图个数是没有限制的。\n> 3、为了创建视图，必须有足够的权限，这些权限是有数据库管理员授予的。\n> 4、视图可以嵌套，即可以利用从其他视图中检索数据的查询来构建一视图。\n> 5、ORDER BY可以使用在视图上，但是如果从该视图中检索数据的SELECT中如果也包含ORDER BY 语句，则视图中的ORDER 将会被覆盖。\n> 6、视图不能有索引，也不能有关联的触发器或默认值。\n> 7、视图可以和表一起使用。例如，编写一条连接视图与表的SELECT语句。\n> 8、视图是不允许数据修改的（除了只从一个实表抽出若干列，而且没统计列和groupby，相关没涉及列修改符合表约束，这种视图部分DBMS允许修改）。\n\n**`视图的创建`**\n> CREATE VIEW view_name AS(\n> SELECT column_name(s)\n> FROM table_name\n> WHERE condition\n)\n\n**`使用视图`**\n> 1、使用CREATE VIEW来创建视图\n> 2、使用SHOW CREATE VIEW viewname，来查看创建视图的语句。\n> 3、使用DROP VIEW viewname来删除视图。\n> 4、更新视图的时候可以先用DROP 在用CREATE，也可以直接使用CREATE OR REPLACE VIEW\n> 。如果要更新的视图不存在，第二种更新的语句将会创建一个视图。如果更新的视图存在，则在第二条更新语句使用后将会替换以前的视图。\n\n\n**`分析视图`**\n\n1. 首先创建视图：\n2. 执行: EXPLAIN SELECT * FROM ur WHERE ur.uname='文杰'\n3. 结果: 看结果发现： ur.uname='文杰' 使用了全表扫描。\n   ![](../images/mysql/result1.jpg)\n\n3. 在真实表数据上创建索引视图能否使用呢：CREATE INDEX idx_name ON t_user (`name`);\n   看结果发现： ur.uname='文杰' 使用了索引。<br>\n   总结：查询视图的性能与组成视图的sql直接相关。当你查询视图的时候，数据库会先执行生成视图的语句，再在视图的基础上进行查询。\n   若视图数据列的来源列上建了索引（ur.uname和t_user.name的关系），那么视图也会使用索引。\n   ![](../images/mysql/result2.jpg)\n\n----------\n\n## mysql执行计划分析：\n\n![](../images/mysql/idx_.jpg)\n","slug":"mysql视图","published":1,"updated":"2024-11-27T03:20:35.284Z","_id":"cm3zaz9c80015tgu68c9odqb2","comments":1,"photos":[],"content":"<h2 id=\"mysql视图\"><a href=\"#mysql视图\" class=\"headerlink\" title=\"mysql视图\"></a>mysql视图</h2><ul>\n<li>视图: 视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。</li>\n</ul>\n<p><strong><code>为什么使用视图</code></strong></p>\n<blockquote>\n<p>1、重用sql语句。<br>2、简化复杂的sql操作。在编写查询后，可以很方便的重用他，而不必知道他的基本查询细节。<br>3、使用表的组成部分而不是整个表。<br>4、保护数据。可以给用户授予表的特定部分的访问权限。<br>5、更改数据的格式和表示。视图可返回与底层表的表示与格式不同的数据。</p>\n</blockquote>\n<p><strong><code>规则和限制</code></strong></p>\n<blockquote>\n<p>1、与表一样视图必须唯一命名。（不能给视图取和别的视图或者是表相同的名字）<br>2、对于可以创建的视图个数是没有限制的。<br>3、为了创建视图，必须有足够的权限，这些权限是有数据库管理员授予的。<br>4、视图可以嵌套，即可以利用从其他视图中检索数据的查询来构建一视图。<br>5、ORDER BY可以使用在视图上，但是如果从该视图中检索数据的SELECT中如果也包含ORDER BY 语句，则视图中的ORDER 将会被覆盖。<br>6、视图不能有索引，也不能有关联的触发器或默认值。<br>7、视图可以和表一起使用。例如，编写一条连接视图与表的SELECT语句。<br>8、视图是不允许数据修改的（除了只从一个实表抽出若干列，而且没统计列和groupby，相关没涉及列修改符合表约束，这种视图部分DBMS允许修改）。</p>\n</blockquote>\n<p><strong><code>视图的创建</code></strong></p>\n<blockquote>\n<p>CREATE VIEW view_name AS(<br>SELECT column_name(s)<br>FROM table_name<br>WHERE condition<br>)</p>\n</blockquote>\n<p><strong><code>使用视图</code></strong></p>\n<blockquote>\n<p>1、使用CREATE VIEW来创建视图<br>2、使用SHOW CREATE VIEW viewname，来查看创建视图的语句。<br>3、使用DROP VIEW viewname来删除视图。<br>4、更新视图的时候可以先用DROP 在用CREATE，也可以直接使用CREATE OR REPLACE VIEW<br>。如果要更新的视图不存在，第二种更新的语句将会创建一个视图。如果更新的视图存在，则在第二条更新语句使用后将会替换以前的视图。</p>\n</blockquote>\n<p><strong><code>分析视图</code></strong></p>\n<ol>\n<li><p>首先创建视图：</p>\n</li>\n<li><p>执行: EXPLAIN SELECT * FROM ur WHERE ur.uname&#x3D;’文杰’</p>\n</li>\n<li><p>结果: 看结果发现： ur.uname&#x3D;’文杰’ 使用了全表扫描。<br><img src=\"/../images/mysql/result1.jpg\"></p>\n</li>\n<li><p>在真实表数据上创建索引视图能否使用呢：CREATE INDEX idx_name ON t_user (<code>name</code>);<br>看结果发现： ur.uname&#x3D;’文杰’ 使用了索引。<br><br>总结：查询视图的性能与组成视图的sql直接相关。当你查询视图的时候，数据库会先执行生成视图的语句，再在视图的基础上进行查询。<br>若视图数据列的来源列上建了索引（ur.uname和t_user.name的关系），那么视图也会使用索引。<br><img src=\"/../images/mysql/result2.jpg\"></p>\n</li>\n</ol>\n<hr>\n<h2 id=\"mysql执行计划分析：\"><a href=\"#mysql执行计划分析：\" class=\"headerlink\" title=\"mysql执行计划分析：\"></a>mysql执行计划分析：</h2><p><img src=\"/../images/mysql/idx_.jpg\"></p>\n","excerpt":"","more":"<h2 id=\"mysql视图\"><a href=\"#mysql视图\" class=\"headerlink\" title=\"mysql视图\"></a>mysql视图</h2><ul>\n<li>视图: 视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。</li>\n</ul>\n<p><strong><code>为什么使用视图</code></strong></p>\n<blockquote>\n<p>1、重用sql语句。<br>2、简化复杂的sql操作。在编写查询后，可以很方便的重用他，而不必知道他的基本查询细节。<br>3、使用表的组成部分而不是整个表。<br>4、保护数据。可以给用户授予表的特定部分的访问权限。<br>5、更改数据的格式和表示。视图可返回与底层表的表示与格式不同的数据。</p>\n</blockquote>\n<p><strong><code>规则和限制</code></strong></p>\n<blockquote>\n<p>1、与表一样视图必须唯一命名。（不能给视图取和别的视图或者是表相同的名字）<br>2、对于可以创建的视图个数是没有限制的。<br>3、为了创建视图，必须有足够的权限，这些权限是有数据库管理员授予的。<br>4、视图可以嵌套，即可以利用从其他视图中检索数据的查询来构建一视图。<br>5、ORDER BY可以使用在视图上，但是如果从该视图中检索数据的SELECT中如果也包含ORDER BY 语句，则视图中的ORDER 将会被覆盖。<br>6、视图不能有索引，也不能有关联的触发器或默认值。<br>7、视图可以和表一起使用。例如，编写一条连接视图与表的SELECT语句。<br>8、视图是不允许数据修改的（除了只从一个实表抽出若干列，而且没统计列和groupby，相关没涉及列修改符合表约束，这种视图部分DBMS允许修改）。</p>\n</blockquote>\n<p><strong><code>视图的创建</code></strong></p>\n<blockquote>\n<p>CREATE VIEW view_name AS(<br>SELECT column_name(s)<br>FROM table_name<br>WHERE condition<br>)</p>\n</blockquote>\n<p><strong><code>使用视图</code></strong></p>\n<blockquote>\n<p>1、使用CREATE VIEW来创建视图<br>2、使用SHOW CREATE VIEW viewname，来查看创建视图的语句。<br>3、使用DROP VIEW viewname来删除视图。<br>4、更新视图的时候可以先用DROP 在用CREATE，也可以直接使用CREATE OR REPLACE VIEW<br>。如果要更新的视图不存在，第二种更新的语句将会创建一个视图。如果更新的视图存在，则在第二条更新语句使用后将会替换以前的视图。</p>\n</blockquote>\n<p><strong><code>分析视图</code></strong></p>\n<ol>\n<li><p>首先创建视图：</p>\n</li>\n<li><p>执行: EXPLAIN SELECT * FROM ur WHERE ur.uname&#x3D;’文杰’</p>\n</li>\n<li><p>结果: 看结果发现： ur.uname&#x3D;’文杰’ 使用了全表扫描。<br><img src=\"/../images/mysql/result1.jpg\"></p>\n</li>\n<li><p>在真实表数据上创建索引视图能否使用呢：CREATE INDEX idx_name ON t_user (<code>name</code>);<br>看结果发现： ur.uname&#x3D;’文杰’ 使用了索引。<br><br>总结：查询视图的性能与组成视图的sql直接相关。当你查询视图的时候，数据库会先执行生成视图的语句，再在视图的基础上进行查询。<br>若视图数据列的来源列上建了索引（ur.uname和t_user.name的关系），那么视图也会使用索引。<br><img src=\"/../images/mysql/result2.jpg\"></p>\n</li>\n</ol>\n<hr>\n<h2 id=\"mysql执行计划分析：\"><a href=\"#mysql执行计划分析：\" class=\"headerlink\" title=\"mysql执行计划分析：\"></a>mysql执行计划分析：</h2><p><img src=\"/../images/mysql/idx_.jpg\"></p>\n"},{"title":"spring定时任务","date":"2016-04-30T16:00:00.000Z","_content":"\n#### spring 定时任务实现3中方式 推荐第二种\n\n###### 1.在spring xml中定义好 scheduler，在容器中的bean 方法上加上@Scheduled注解\n\n    xmlns:task=\"http://www.springframework.org/schema/task\"\n    \n    http://www.springframework.org/schema/task \n    http://www.springframework.org/schema/task/spring-task.xsd\n    \n    <task:annotation-driven />\n    <task:scheduled-tasks scheduler=\"myScheduler\">  \n        <task:scheduled ref=\"scheduledTaskManager\" method=\"autoCardCalculate\" cron=\"1/5 * * * * *\"/>  \n    </task:scheduled-tasks>  \n    <task:scheduler id=\"myScheduler\" pool-size=\"10\"/>  \n    \n    @Scheduled(cron = \"0/5 * * * * *\" )\n    public void doSomething() {\n        System.err.println(Thread.currentThread().getName() + \"   doSomething statrt.................\");\n    }\n\n###### 2.使用注解启用 schedul，同样可以在容器中的bean 方法上加上@Scheduled注解来标识是调度，或者手动注册\n\n    　\n    @Configuration\n    @EnableScheduling\n    public class AppConfig implements SchedulingConfigurer {\n    \t@Override\n    \tpublic void configureTasks(ScheduledTaskRegistrar taskRegistrar) {\n    \t\ttaskRegistrar.setScheduler(taskScheduler());\n    \t\ttaskRegistrar.addTriggerTask(myTask(), new CustomTrigger(\"0/5 * * * * *\"));\n    \t}\n    \n    \t@Bean(destroyMethod = \"shutdown\")\n    \tpublic Executor taskScheduler() {\n    \t\tScheduledThreadPoolExecutor scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(5);\n    \t\t// Executor executor=new ThreadPoolExecutor(4, 10, 60L, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(10000));\n    \t\treturn scheduledThreadPoolExecutor;\n    \t}\n    \n    \t@Bean\n    \tpublic MyTask myTask() {\n    \t\treturn new MyTask();\n    \t}\n    \t\n    \t@Scheduled(cron = \"0/5 * * * * *\" )\n    \tpublic void doSomething() {\n    \t\tSystem.err.println(Thread.currentThread().getName() + \"   doSomething statrt.................\");\n    \t}\n    }\n    \n    class MyTask implements Runnable {\n    \t@Override\n    \tpublic void run() {\n    \t\tSystem.err.println(Thread.currentThread().getName() + \"   MyTask statrt.................\");\n    \t\ttry {\n    \t\t\tThread.sleep(10000);\n    \t\t} catch (InterruptedException e) {\n    \t\t\t// TODO Auto-generated catch block\n    \t\t\te.printStackTrace();\n    \t\t}\n    \t\tSystem.err.println(Thread.currentThread().getName() + \"   MyTask end.................\");\n    \t}\n    }\n    \n    class CustomTrigger implements Trigger {\n    \n    \tprivate String cron;\n    \n    \tCustomTrigger(String cron) {\n    \t\tthis.cron = cron;\n    \t}\n    \n    \t@Override\n    \tpublic Date nextExecutionTime(TriggerContext triggerContext) {\n    \t\tCronTrigger trigger = new CronTrigger(cron);\n    \t\tDate nextExec = trigger.nextExecutionTime(triggerContext);\n    \t\treturn nextExec;\n    \t}\n    }\n\n###### 3.使用 quartz 在spring 中代码 如下\n\n    <bean id=\"payTask\" class=\"cn.bookingsmart.jp.task.OrderTask\"/>\n    <!-- 支付超时 -->\n    <bean id=\"handlePayTimeout\" class=\"org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean\">\n    \t<property name=\"targetObject\">\n    \t\t<ref bean=\"payTask\" />\n    \t</property>\n    \t<property name=\"targetMethod\">\n    \t\t<value>handlePayTimeout</value>\n    \t</property>\n    \t<property name=\"concurrent\" value=\"false\" />\n    </bean>\n    \n    <bean id=\"handlePayTimeoutTrigger\" class=\"org.springframework.scheduling.quartz.CronTriggerFactoryBean\">\n    \t<property name=\"jobDetail\">\n    \t\t<ref bean=\"handlePayTimeout\" />\n    \t</property>\n    \t<property name=\"cronExpression\">\n    \t\t<value>0 0/5 * * * ? *</value>\n    \t</property>\n    </bean>\n    \n    <bean class=\"org.springframework.scheduling.quartz.SchedulerFactoryBean\">\n    \t<property name=\"triggers\">\n    \t\t<list>\n    \t\t\t<ref bean=\"handlePayTimeoutTrigger\" />\n    \t\t\t<ref bean=\"handlePayErrTrigger\" />\n    \t\t\t<ref bean=\"handleTicketTrigger\" />\n    \t\t</list>\n    \t</property>\n    </bean>\n    \n    <bean id=\"threadPoolTaskExecutor\" class=\"org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor\">\n      <!-- 核心线程数，默认为1 -->\n      <property name=\"corePoolSize\" value=\"3\" />\n      <!-- 最大线程数，默认为Integer.MAX_VALUE -->\n      <property name=\"maxPoolSize\" value=\"10\" />\n      <!-- 队列最大长度，一般需要设置值>=notifyScheduledMainExecutor.maxNum；默认为Integer.MAX_VALUE -->\n      <property name=\"queueCapacity\" value=\"1000\" />\n      <!-- 线程池维护线程所允许的空闲时间，默认为60s -->\n      <property name=\"keepAliveSeconds\" value=\"300\" />\n      <!-- 线程池对拒绝任务（无线程可用）的处理策略，目前只支持AbortPolicy、CallerRunsPolicy；默认为后者 -->\n      <property name=\"rejectedExecutionHandler\">\n          <!-- AbortPolicy:直接抛出java.util.concurrent.RejectedExecutionException异常 -->\n          <!-- CallerRunsPolicy:主线程直接执行该任务，执行完之后尝试添加下一个任务到线程池中，可以有效降低向线程池内添加任务的速度 -->\n          <!-- DiscardOldestPolicy:抛弃旧的任务、暂不支持；会导致被丢弃的任务无法再次被执行 -->\n          <!-- DiscardPolicy:抛弃当前任务、暂不支持；会导致被丢弃的任务无法再次被执行 -->\n          <bean class=\"java.util.concurrent.ThreadPoolExecutor$CallerRunsPolicy\" />\n      </property>\n    </bean>\n    \n    \n    public class OrderTask {\n    \t@Resource\n    \tprivate OrderService orderService;\n    \t@Resource\n    \tprivate QaeService qaeService;\n \n    \tpublic void handlePayTimeout() {\n    \t \n    \t}\n    \t\n    \tpublic void handlePayErr() {\n    \t\t \n    \t}\n    \t\n    \tpublic void handNoTicket() {\n    \t\t \n    \t}\n\t\n    }","source":"_posts/spring定时任务.md","raw":"---\ntitle: spring定时任务\ndate: 2016-05-01 00:00:00\ncategories: Spring\ntags:\n  - 定时任务\n---\n\n#### spring 定时任务实现3中方式 推荐第二种\n\n###### 1.在spring xml中定义好 scheduler，在容器中的bean 方法上加上@Scheduled注解\n\n    xmlns:task=\"http://www.springframework.org/schema/task\"\n    \n    http://www.springframework.org/schema/task \n    http://www.springframework.org/schema/task/spring-task.xsd\n    \n    <task:annotation-driven />\n    <task:scheduled-tasks scheduler=\"myScheduler\">  \n        <task:scheduled ref=\"scheduledTaskManager\" method=\"autoCardCalculate\" cron=\"1/5 * * * * *\"/>  \n    </task:scheduled-tasks>  \n    <task:scheduler id=\"myScheduler\" pool-size=\"10\"/>  \n    \n    @Scheduled(cron = \"0/5 * * * * *\" )\n    public void doSomething() {\n        System.err.println(Thread.currentThread().getName() + \"   doSomething statrt.................\");\n    }\n\n###### 2.使用注解启用 schedul，同样可以在容器中的bean 方法上加上@Scheduled注解来标识是调度，或者手动注册\n\n    　\n    @Configuration\n    @EnableScheduling\n    public class AppConfig implements SchedulingConfigurer {\n    \t@Override\n    \tpublic void configureTasks(ScheduledTaskRegistrar taskRegistrar) {\n    \t\ttaskRegistrar.setScheduler(taskScheduler());\n    \t\ttaskRegistrar.addTriggerTask(myTask(), new CustomTrigger(\"0/5 * * * * *\"));\n    \t}\n    \n    \t@Bean(destroyMethod = \"shutdown\")\n    \tpublic Executor taskScheduler() {\n    \t\tScheduledThreadPoolExecutor scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(5);\n    \t\t// Executor executor=new ThreadPoolExecutor(4, 10, 60L, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(10000));\n    \t\treturn scheduledThreadPoolExecutor;\n    \t}\n    \n    \t@Bean\n    \tpublic MyTask myTask() {\n    \t\treturn new MyTask();\n    \t}\n    \t\n    \t@Scheduled(cron = \"0/5 * * * * *\" )\n    \tpublic void doSomething() {\n    \t\tSystem.err.println(Thread.currentThread().getName() + \"   doSomething statrt.................\");\n    \t}\n    }\n    \n    class MyTask implements Runnable {\n    \t@Override\n    \tpublic void run() {\n    \t\tSystem.err.println(Thread.currentThread().getName() + \"   MyTask statrt.................\");\n    \t\ttry {\n    \t\t\tThread.sleep(10000);\n    \t\t} catch (InterruptedException e) {\n    \t\t\t// TODO Auto-generated catch block\n    \t\t\te.printStackTrace();\n    \t\t}\n    \t\tSystem.err.println(Thread.currentThread().getName() + \"   MyTask end.................\");\n    \t}\n    }\n    \n    class CustomTrigger implements Trigger {\n    \n    \tprivate String cron;\n    \n    \tCustomTrigger(String cron) {\n    \t\tthis.cron = cron;\n    \t}\n    \n    \t@Override\n    \tpublic Date nextExecutionTime(TriggerContext triggerContext) {\n    \t\tCronTrigger trigger = new CronTrigger(cron);\n    \t\tDate nextExec = trigger.nextExecutionTime(triggerContext);\n    \t\treturn nextExec;\n    \t}\n    }\n\n###### 3.使用 quartz 在spring 中代码 如下\n\n    <bean id=\"payTask\" class=\"cn.bookingsmart.jp.task.OrderTask\"/>\n    <!-- 支付超时 -->\n    <bean id=\"handlePayTimeout\" class=\"org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean\">\n    \t<property name=\"targetObject\">\n    \t\t<ref bean=\"payTask\" />\n    \t</property>\n    \t<property name=\"targetMethod\">\n    \t\t<value>handlePayTimeout</value>\n    \t</property>\n    \t<property name=\"concurrent\" value=\"false\" />\n    </bean>\n    \n    <bean id=\"handlePayTimeoutTrigger\" class=\"org.springframework.scheduling.quartz.CronTriggerFactoryBean\">\n    \t<property name=\"jobDetail\">\n    \t\t<ref bean=\"handlePayTimeout\" />\n    \t</property>\n    \t<property name=\"cronExpression\">\n    \t\t<value>0 0/5 * * * ? *</value>\n    \t</property>\n    </bean>\n    \n    <bean class=\"org.springframework.scheduling.quartz.SchedulerFactoryBean\">\n    \t<property name=\"triggers\">\n    \t\t<list>\n    \t\t\t<ref bean=\"handlePayTimeoutTrigger\" />\n    \t\t\t<ref bean=\"handlePayErrTrigger\" />\n    \t\t\t<ref bean=\"handleTicketTrigger\" />\n    \t\t</list>\n    \t</property>\n    </bean>\n    \n    <bean id=\"threadPoolTaskExecutor\" class=\"org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor\">\n      <!-- 核心线程数，默认为1 -->\n      <property name=\"corePoolSize\" value=\"3\" />\n      <!-- 最大线程数，默认为Integer.MAX_VALUE -->\n      <property name=\"maxPoolSize\" value=\"10\" />\n      <!-- 队列最大长度，一般需要设置值>=notifyScheduledMainExecutor.maxNum；默认为Integer.MAX_VALUE -->\n      <property name=\"queueCapacity\" value=\"1000\" />\n      <!-- 线程池维护线程所允许的空闲时间，默认为60s -->\n      <property name=\"keepAliveSeconds\" value=\"300\" />\n      <!-- 线程池对拒绝任务（无线程可用）的处理策略，目前只支持AbortPolicy、CallerRunsPolicy；默认为后者 -->\n      <property name=\"rejectedExecutionHandler\">\n          <!-- AbortPolicy:直接抛出java.util.concurrent.RejectedExecutionException异常 -->\n          <!-- CallerRunsPolicy:主线程直接执行该任务，执行完之后尝试添加下一个任务到线程池中，可以有效降低向线程池内添加任务的速度 -->\n          <!-- DiscardOldestPolicy:抛弃旧的任务、暂不支持；会导致被丢弃的任务无法再次被执行 -->\n          <!-- DiscardPolicy:抛弃当前任务、暂不支持；会导致被丢弃的任务无法再次被执行 -->\n          <bean class=\"java.util.concurrent.ThreadPoolExecutor$CallerRunsPolicy\" />\n      </property>\n    </bean>\n    \n    \n    public class OrderTask {\n    \t@Resource\n    \tprivate OrderService orderService;\n    \t@Resource\n    \tprivate QaeService qaeService;\n \n    \tpublic void handlePayTimeout() {\n    \t \n    \t}\n    \t\n    \tpublic void handlePayErr() {\n    \t\t \n    \t}\n    \t\n    \tpublic void handNoTicket() {\n    \t\t \n    \t}\n\t\n    }","slug":"spring定时任务","published":1,"updated":"2024-11-27T03:22:21.049Z","_id":"cm3zaz9c90018tgu66ki1awf3","comments":1,"layout":"post","photos":[],"content":"<h4 id=\"spring-定时任务实现3中方式-推荐第二种\"><a href=\"#spring-定时任务实现3中方式-推荐第二种\" class=\"headerlink\" title=\"spring 定时任务实现3中方式 推荐第二种\"></a>spring 定时任务实现3中方式 推荐第二种</h4><h6 id=\"1-在spring-xml中定义好-scheduler，在容器中的bean-方法上加上-Scheduled注解\"><a href=\"#1-在spring-xml中定义好-scheduler，在容器中的bean-方法上加上-Scheduled注解\" class=\"headerlink\" title=\"1.在spring xml中定义好 scheduler，在容器中的bean 方法上加上@Scheduled注解\"></a>1.在spring xml中定义好 scheduler，在容器中的bean 方法上加上@Scheduled注解</h6><pre><code>xmlns:task=&quot;http://www.springframework.org/schema/task&quot;\n\nhttp://www.springframework.org/schema/task \nhttp://www.springframework.org/schema/task/spring-task.xsd\n\n&lt;task:annotation-driven /&gt;\n&lt;task:scheduled-tasks scheduler=&quot;myScheduler&quot;&gt;  \n    &lt;task:scheduled ref=&quot;scheduledTaskManager&quot; method=&quot;autoCardCalculate&quot; cron=&quot;1/5 * * * * *&quot;/&gt;  \n&lt;/task:scheduled-tasks&gt;  \n&lt;task:scheduler id=&quot;myScheduler&quot; pool-size=&quot;10&quot;/&gt;  \n\n@Scheduled(cron = &quot;0/5 * * * * *&quot; )\npublic void doSomething() &#123;\n    System.err.println(Thread.currentThread().getName() + &quot;   doSomething statrt.................&quot;);\n&#125;\n</code></pre>\n<h6 id=\"2-使用注解启用-schedul，同样可以在容器中的bean-方法上加上-Scheduled注解来标识是调度，或者手动注册\"><a href=\"#2-使用注解启用-schedul，同样可以在容器中的bean-方法上加上-Scheduled注解来标识是调度，或者手动注册\" class=\"headerlink\" title=\"2.使用注解启用 schedul，同样可以在容器中的bean 方法上加上@Scheduled注解来标识是调度，或者手动注册\"></a>2.使用注解启用 schedul，同样可以在容器中的bean 方法上加上@Scheduled注解来标识是调度，或者手动注册</h6><pre><code>　\n@Configuration\n@EnableScheduling\npublic class AppConfig implements SchedulingConfigurer &#123;\n    @Override\n    public void configureTasks(ScheduledTaskRegistrar taskRegistrar) &#123;\n        taskRegistrar.setScheduler(taskScheduler());\n        taskRegistrar.addTriggerTask(myTask(), new CustomTrigger(&quot;0/5 * * * * *&quot;));\n    &#125;\n\n    @Bean(destroyMethod = &quot;shutdown&quot;)\n    public Executor taskScheduler() &#123;\n        ScheduledThreadPoolExecutor scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(5);\n        // Executor executor=new ThreadPoolExecutor(4, 10, 60L, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(10000));\n        return scheduledThreadPoolExecutor;\n    &#125;\n\n    @Bean\n    public MyTask myTask() &#123;\n        return new MyTask();\n    &#125;\n    \n    @Scheduled(cron = &quot;0/5 * * * * *&quot; )\n    public void doSomething() &#123;\n        System.err.println(Thread.currentThread().getName() + &quot;   doSomething statrt.................&quot;);\n    &#125;\n&#125;\n\nclass MyTask implements Runnable &#123;\n    @Override\n    public void run() &#123;\n        System.err.println(Thread.currentThread().getName() + &quot;   MyTask statrt.................&quot;);\n        try &#123;\n            Thread.sleep(10000);\n        &#125; catch (InterruptedException e) &#123;\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        &#125;\n        System.err.println(Thread.currentThread().getName() + &quot;   MyTask end.................&quot;);\n    &#125;\n&#125;\n\nclass CustomTrigger implements Trigger &#123;\n\n    private String cron;\n\n    CustomTrigger(String cron) &#123;\n        this.cron = cron;\n    &#125;\n\n    @Override\n    public Date nextExecutionTime(TriggerContext triggerContext) &#123;\n        CronTrigger trigger = new CronTrigger(cron);\n        Date nextExec = trigger.nextExecutionTime(triggerContext);\n        return nextExec;\n    &#125;\n&#125;\n</code></pre>\n<h6 id=\"3-使用-quartz-在spring-中代码-如下\"><a href=\"#3-使用-quartz-在spring-中代码-如下\" class=\"headerlink\" title=\"3.使用 quartz 在spring 中代码 如下\"></a>3.使用 quartz 在spring 中代码 如下</h6><pre><code>&lt;bean id=&quot;payTask&quot; class=&quot;cn.bookingsmart.jp.task.OrderTask&quot;/&gt;\n&lt;!-- 支付超时 --&gt;\n&lt;bean id=&quot;handlePayTimeout&quot; class=&quot;org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean&quot;&gt;\n    &lt;property name=&quot;targetObject&quot;&gt;\n        &lt;ref bean=&quot;payTask&quot; /&gt;\n    &lt;/property&gt;\n    &lt;property name=&quot;targetMethod&quot;&gt;\n        &lt;value&gt;handlePayTimeout&lt;/value&gt;\n    &lt;/property&gt;\n    &lt;property name=&quot;concurrent&quot; value=&quot;false&quot; /&gt;\n&lt;/bean&gt;\n\n&lt;bean id=&quot;handlePayTimeoutTrigger&quot; class=&quot;org.springframework.scheduling.quartz.CronTriggerFactoryBean&quot;&gt;\n    &lt;property name=&quot;jobDetail&quot;&gt;\n        &lt;ref bean=&quot;handlePayTimeout&quot; /&gt;\n    &lt;/property&gt;\n    &lt;property name=&quot;cronExpression&quot;&gt;\n        &lt;value&gt;0 0/5 * * * ? *&lt;/value&gt;\n    &lt;/property&gt;\n&lt;/bean&gt;\n\n&lt;bean class=&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt;\n    &lt;property name=&quot;triggers&quot;&gt;\n        &lt;list&gt;\n            &lt;ref bean=&quot;handlePayTimeoutTrigger&quot; /&gt;\n            &lt;ref bean=&quot;handlePayErrTrigger&quot; /&gt;\n            &lt;ref bean=&quot;handleTicketTrigger&quot; /&gt;\n        &lt;/list&gt;\n    &lt;/property&gt;\n&lt;/bean&gt;\n\n&lt;bean id=&quot;threadPoolTaskExecutor&quot; class=&quot;org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor&quot;&gt;\n  &lt;!-- 核心线程数，默认为1 --&gt;\n  &lt;property name=&quot;corePoolSize&quot; value=&quot;3&quot; /&gt;\n  &lt;!-- 最大线程数，默认为Integer.MAX_VALUE --&gt;\n  &lt;property name=&quot;maxPoolSize&quot; value=&quot;10&quot; /&gt;\n  &lt;!-- 队列最大长度，一般需要设置值&gt;=notifyScheduledMainExecutor.maxNum；默认为Integer.MAX_VALUE --&gt;\n  &lt;property name=&quot;queueCapacity&quot; value=&quot;1000&quot; /&gt;\n  &lt;!-- 线程池维护线程所允许的空闲时间，默认为60s --&gt;\n  &lt;property name=&quot;keepAliveSeconds&quot; value=&quot;300&quot; /&gt;\n  &lt;!-- 线程池对拒绝任务（无线程可用）的处理策略，目前只支持AbortPolicy、CallerRunsPolicy；默认为后者 --&gt;\n  &lt;property name=&quot;rejectedExecutionHandler&quot;&gt;\n      &lt;!-- AbortPolicy:直接抛出java.util.concurrent.RejectedExecutionException异常 --&gt;\n      &lt;!-- CallerRunsPolicy:主线程直接执行该任务，执行完之后尝试添加下一个任务到线程池中，可以有效降低向线程池内添加任务的速度 --&gt;\n      &lt;!-- DiscardOldestPolicy:抛弃旧的任务、暂不支持；会导致被丢弃的任务无法再次被执行 --&gt;\n      &lt;!-- DiscardPolicy:抛弃当前任务、暂不支持；会导致被丢弃的任务无法再次被执行 --&gt;\n      &lt;bean class=&quot;java.util.concurrent.ThreadPoolExecutor$CallerRunsPolicy&quot; /&gt;\n  &lt;/property&gt;\n&lt;/bean&gt;\n\n\npublic class OrderTask &#123;\n    @Resource\n    private OrderService orderService;\n    @Resource\n    private QaeService qaeService;\n\n    public void handlePayTimeout() &#123;\n     \n    &#125;\n    \n    public void handlePayErr() &#123;\n         \n    &#125;\n    \n    public void handNoTicket() &#123;\n         \n    &#125;\n\n&#125;\n</code></pre>\n","excerpt":"","more":"<h4 id=\"spring-定时任务实现3中方式-推荐第二种\"><a href=\"#spring-定时任务实现3中方式-推荐第二种\" class=\"headerlink\" title=\"spring 定时任务实现3中方式 推荐第二种\"></a>spring 定时任务实现3中方式 推荐第二种</h4><h6 id=\"1-在spring-xml中定义好-scheduler，在容器中的bean-方法上加上-Scheduled注解\"><a href=\"#1-在spring-xml中定义好-scheduler，在容器中的bean-方法上加上-Scheduled注解\" class=\"headerlink\" title=\"1.在spring xml中定义好 scheduler，在容器中的bean 方法上加上@Scheduled注解\"></a>1.在spring xml中定义好 scheduler，在容器中的bean 方法上加上@Scheduled注解</h6><pre><code>xmlns:task=&quot;http://www.springframework.org/schema/task&quot;\n\nhttp://www.springframework.org/schema/task \nhttp://www.springframework.org/schema/task/spring-task.xsd\n\n&lt;task:annotation-driven /&gt;\n&lt;task:scheduled-tasks scheduler=&quot;myScheduler&quot;&gt;  \n    &lt;task:scheduled ref=&quot;scheduledTaskManager&quot; method=&quot;autoCardCalculate&quot; cron=&quot;1/5 * * * * *&quot;/&gt;  \n&lt;/task:scheduled-tasks&gt;  \n&lt;task:scheduler id=&quot;myScheduler&quot; pool-size=&quot;10&quot;/&gt;  \n\n@Scheduled(cron = &quot;0/5 * * * * *&quot; )\npublic void doSomething() &#123;\n    System.err.println(Thread.currentThread().getName() + &quot;   doSomething statrt.................&quot;);\n&#125;\n</code></pre>\n<h6 id=\"2-使用注解启用-schedul，同样可以在容器中的bean-方法上加上-Scheduled注解来标识是调度，或者手动注册\"><a href=\"#2-使用注解启用-schedul，同样可以在容器中的bean-方法上加上-Scheduled注解来标识是调度，或者手动注册\" class=\"headerlink\" title=\"2.使用注解启用 schedul，同样可以在容器中的bean 方法上加上@Scheduled注解来标识是调度，或者手动注册\"></a>2.使用注解启用 schedul，同样可以在容器中的bean 方法上加上@Scheduled注解来标识是调度，或者手动注册</h6><pre><code>　\n@Configuration\n@EnableScheduling\npublic class AppConfig implements SchedulingConfigurer &#123;\n    @Override\n    public void configureTasks(ScheduledTaskRegistrar taskRegistrar) &#123;\n        taskRegistrar.setScheduler(taskScheduler());\n        taskRegistrar.addTriggerTask(myTask(), new CustomTrigger(&quot;0/5 * * * * *&quot;));\n    &#125;\n\n    @Bean(destroyMethod = &quot;shutdown&quot;)\n    public Executor taskScheduler() &#123;\n        ScheduledThreadPoolExecutor scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(5);\n        // Executor executor=new ThreadPoolExecutor(4, 10, 60L, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(10000));\n        return scheduledThreadPoolExecutor;\n    &#125;\n\n    @Bean\n    public MyTask myTask() &#123;\n        return new MyTask();\n    &#125;\n    \n    @Scheduled(cron = &quot;0/5 * * * * *&quot; )\n    public void doSomething() &#123;\n        System.err.println(Thread.currentThread().getName() + &quot;   doSomething statrt.................&quot;);\n    &#125;\n&#125;\n\nclass MyTask implements Runnable &#123;\n    @Override\n    public void run() &#123;\n        System.err.println(Thread.currentThread().getName() + &quot;   MyTask statrt.................&quot;);\n        try &#123;\n            Thread.sleep(10000);\n        &#125; catch (InterruptedException e) &#123;\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        &#125;\n        System.err.println(Thread.currentThread().getName() + &quot;   MyTask end.................&quot;);\n    &#125;\n&#125;\n\nclass CustomTrigger implements Trigger &#123;\n\n    private String cron;\n\n    CustomTrigger(String cron) &#123;\n        this.cron = cron;\n    &#125;\n\n    @Override\n    public Date nextExecutionTime(TriggerContext triggerContext) &#123;\n        CronTrigger trigger = new CronTrigger(cron);\n        Date nextExec = trigger.nextExecutionTime(triggerContext);\n        return nextExec;\n    &#125;\n&#125;\n</code></pre>\n<h6 id=\"3-使用-quartz-在spring-中代码-如下\"><a href=\"#3-使用-quartz-在spring-中代码-如下\" class=\"headerlink\" title=\"3.使用 quartz 在spring 中代码 如下\"></a>3.使用 quartz 在spring 中代码 如下</h6><pre><code>&lt;bean id=&quot;payTask&quot; class=&quot;cn.bookingsmart.jp.task.OrderTask&quot;/&gt;\n&lt;!-- 支付超时 --&gt;\n&lt;bean id=&quot;handlePayTimeout&quot; class=&quot;org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean&quot;&gt;\n    &lt;property name=&quot;targetObject&quot;&gt;\n        &lt;ref bean=&quot;payTask&quot; /&gt;\n    &lt;/property&gt;\n    &lt;property name=&quot;targetMethod&quot;&gt;\n        &lt;value&gt;handlePayTimeout&lt;/value&gt;\n    &lt;/property&gt;\n    &lt;property name=&quot;concurrent&quot; value=&quot;false&quot; /&gt;\n&lt;/bean&gt;\n\n&lt;bean id=&quot;handlePayTimeoutTrigger&quot; class=&quot;org.springframework.scheduling.quartz.CronTriggerFactoryBean&quot;&gt;\n    &lt;property name=&quot;jobDetail&quot;&gt;\n        &lt;ref bean=&quot;handlePayTimeout&quot; /&gt;\n    &lt;/property&gt;\n    &lt;property name=&quot;cronExpression&quot;&gt;\n        &lt;value&gt;0 0/5 * * * ? *&lt;/value&gt;\n    &lt;/property&gt;\n&lt;/bean&gt;\n\n&lt;bean class=&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt;\n    &lt;property name=&quot;triggers&quot;&gt;\n        &lt;list&gt;\n            &lt;ref bean=&quot;handlePayTimeoutTrigger&quot; /&gt;\n            &lt;ref bean=&quot;handlePayErrTrigger&quot; /&gt;\n            &lt;ref bean=&quot;handleTicketTrigger&quot; /&gt;\n        &lt;/list&gt;\n    &lt;/property&gt;\n&lt;/bean&gt;\n\n&lt;bean id=&quot;threadPoolTaskExecutor&quot; class=&quot;org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor&quot;&gt;\n  &lt;!-- 核心线程数，默认为1 --&gt;\n  &lt;property name=&quot;corePoolSize&quot; value=&quot;3&quot; /&gt;\n  &lt;!-- 最大线程数，默认为Integer.MAX_VALUE --&gt;\n  &lt;property name=&quot;maxPoolSize&quot; value=&quot;10&quot; /&gt;\n  &lt;!-- 队列最大长度，一般需要设置值&gt;=notifyScheduledMainExecutor.maxNum；默认为Integer.MAX_VALUE --&gt;\n  &lt;property name=&quot;queueCapacity&quot; value=&quot;1000&quot; /&gt;\n  &lt;!-- 线程池维护线程所允许的空闲时间，默认为60s --&gt;\n  &lt;property name=&quot;keepAliveSeconds&quot; value=&quot;300&quot; /&gt;\n  &lt;!-- 线程池对拒绝任务（无线程可用）的处理策略，目前只支持AbortPolicy、CallerRunsPolicy；默认为后者 --&gt;\n  &lt;property name=&quot;rejectedExecutionHandler&quot;&gt;\n      &lt;!-- AbortPolicy:直接抛出java.util.concurrent.RejectedExecutionException异常 --&gt;\n      &lt;!-- CallerRunsPolicy:主线程直接执行该任务，执行完之后尝试添加下一个任务到线程池中，可以有效降低向线程池内添加任务的速度 --&gt;\n      &lt;!-- DiscardOldestPolicy:抛弃旧的任务、暂不支持；会导致被丢弃的任务无法再次被执行 --&gt;\n      &lt;!-- DiscardPolicy:抛弃当前任务、暂不支持；会导致被丢弃的任务无法再次被执行 --&gt;\n      &lt;bean class=&quot;java.util.concurrent.ThreadPoolExecutor$CallerRunsPolicy&quot; /&gt;\n  &lt;/property&gt;\n&lt;/bean&gt;\n\n\npublic class OrderTask &#123;\n    @Resource\n    private OrderService orderService;\n    @Resource\n    private QaeService qaeService;\n\n    public void handlePayTimeout() &#123;\n     \n    &#125;\n    \n    public void handlePayErr() &#123;\n         \n    &#125;\n    \n    public void handNoTicket() &#123;\n         \n    &#125;\n\n&#125;\n</code></pre>\n"},{"title":"spring 整合 ActiveMQ ","date":"2016-12-13T01:00:00.000Z","_content":"\n###### spring 整合 ActiveMQ xml如下：\n\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <beans xmlns=\"http://www.springframework.org/schema/beans\"\n    \txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\"\n    \txmlns:context=\"http://www.springframework.org/schema/context\"\n    \txmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\"\n    \txsi:schemaLocation=\"http://www.springframework.org/schema/beans  \n               http://www.springframework.org/schema/beans/spring-beans-3.2.xsd  \n               http://www.springframework.org/schema/aop   \n               http://www.springframework.org/schema/aop/spring-aop-3.2.xsd  \n               http://www.springframework.org/schema/tx  \n               http://www.springframework.org/schema/tx/spring-tx-3.2.xsd  \n               http://www.springframework.org/schema/context  \n               http://www.springframework.org/schema/context/spring-context-3.2.xsd\"\n    \tdefault-autowire=\"byName\" default-lazy-init=\"false\">\n    \n    \n    \t<!-- 第三方MQ工厂: ConnectionFactory -->\n    \t<bean id=\"targetConnectionFactory\" class=\"org.apache.activemq.ActiveMQConnectionFactory\">\n    \t\t<!-- ActiveMQ服务地址 -->\n            <property name=\"brokerURL\" value=\"${activemq.brokerURL}\" />\n            <property name=\"userName\" value=\"${activemq.userName}\"></property>\n            <property name=\"password\" value=\"${activemq.password}\"></property> \n    \t</bean>\n    \t\n        <!-- \n        \tActiveMQ为我们提供了一个PooledConnectionFactory，通过往里面注入一个ActiveMQConnectionFactory\n        \t可以用来将Connection、Session和MessageProducer池化，这样可以大大的减少我们的资源消耗,要依赖于 activemq-pool包\n         -->\n    \t<bean id=\"pooledConnectionFactory\" class=\"org.apache.activemq.pool.PooledConnectionFactory\">\n    \t\t<property name=\"connectionFactory\" ref=\"targetConnectionFactory\" />\n    \t\t<property name=\"maxConnections\" value=\"${activemq.pool.maxConnections}\" />\n    \t</bean>\n    \n    \t<!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory -->\n    \t<bean id=\"connectionFactory\" class=\"org.springframework.jms.connection.SingleConnectionFactory\">\n    \t\t<!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory -->\n    \t\t<property name=\"targetConnectionFactory\" ref=\"pooledConnectionFactory\" />\n    \t</bean>\n    \t\n    \t<!-- Spring提供的JMS工具类，它可以进行消息发送、接收等 -->\n    \t\n    \t<!-- 队列模板 -->\n    \t<bean id=\"jmsTemplate\" class=\"org.springframework.jms.core.JmsTemplate\">  \n    \t    <!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 -->  \n    \t    <property name=\"connectionFactory\" ref=\"connectionFactory\"/>  \n    \t    <property name=\"defaultDestinationName\" value=\"${activemq.queueName}\"></property>\n    \t</bean> \n    \t\n    \t<!--这个是目的地:mailQueue -->\n    \t<bean id=\"mailQueue\" class=\"org.apache.activemq.command.ActiveMQQueue\">\n    \t\t<constructor-arg>\n    \t\t\t<value>${activemq.queueName}</value>\n    \t\t</constructor-arg>\n    \t</bean>\n    \n    \t<!-- 配置自定义监听：MessageListener -->\n    \t<bean id=\"mailQueueMessageListener\" class=\"bhz.mq.MailQueueMessageListener\"></bean>\n    \n    \t<!-- 将连接工厂、目标对了、自定义监听注入jms模板 -->\n    \t<bean id=\"sessionAwareListenerContainer\" class=\"org.springframework.jms.listener.DefaultMessageListenerContainer\">\n    \t\t<property name=\"connectionFactory\" ref=\"connectionFactory\" />\n    \t\t<property name=\"destination\" ref=\"mailQueue\" />\n    \t\t<property name=\"messageListener\" ref=\"mailQueueMessageListener\" />\n    \t</bean>\n    </beans>","source":"_posts/spring整合ActiveMQ.md","raw":"---\ntitle: \"spring 整合 ActiveMQ \"\ndate: 2016-12-13 09:00:00\ncategories: Spring\ntags:\n  - 整合\n---\n\n###### spring 整合 ActiveMQ xml如下：\n\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <beans xmlns=\"http://www.springframework.org/schema/beans\"\n    \txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\"\n    \txmlns:context=\"http://www.springframework.org/schema/context\"\n    \txmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\"\n    \txsi:schemaLocation=\"http://www.springframework.org/schema/beans  \n               http://www.springframework.org/schema/beans/spring-beans-3.2.xsd  \n               http://www.springframework.org/schema/aop   \n               http://www.springframework.org/schema/aop/spring-aop-3.2.xsd  \n               http://www.springframework.org/schema/tx  \n               http://www.springframework.org/schema/tx/spring-tx-3.2.xsd  \n               http://www.springframework.org/schema/context  \n               http://www.springframework.org/schema/context/spring-context-3.2.xsd\"\n    \tdefault-autowire=\"byName\" default-lazy-init=\"false\">\n    \n    \n    \t<!-- 第三方MQ工厂: ConnectionFactory -->\n    \t<bean id=\"targetConnectionFactory\" class=\"org.apache.activemq.ActiveMQConnectionFactory\">\n    \t\t<!-- ActiveMQ服务地址 -->\n            <property name=\"brokerURL\" value=\"${activemq.brokerURL}\" />\n            <property name=\"userName\" value=\"${activemq.userName}\"></property>\n            <property name=\"password\" value=\"${activemq.password}\"></property> \n    \t</bean>\n    \t\n        <!-- \n        \tActiveMQ为我们提供了一个PooledConnectionFactory，通过往里面注入一个ActiveMQConnectionFactory\n        \t可以用来将Connection、Session和MessageProducer池化，这样可以大大的减少我们的资源消耗,要依赖于 activemq-pool包\n         -->\n    \t<bean id=\"pooledConnectionFactory\" class=\"org.apache.activemq.pool.PooledConnectionFactory\">\n    \t\t<property name=\"connectionFactory\" ref=\"targetConnectionFactory\" />\n    \t\t<property name=\"maxConnections\" value=\"${activemq.pool.maxConnections}\" />\n    \t</bean>\n    \n    \t<!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory -->\n    \t<bean id=\"connectionFactory\" class=\"org.springframework.jms.connection.SingleConnectionFactory\">\n    \t\t<!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory -->\n    \t\t<property name=\"targetConnectionFactory\" ref=\"pooledConnectionFactory\" />\n    \t</bean>\n    \t\n    \t<!-- Spring提供的JMS工具类，它可以进行消息发送、接收等 -->\n    \t\n    \t<!-- 队列模板 -->\n    \t<bean id=\"jmsTemplate\" class=\"org.springframework.jms.core.JmsTemplate\">  \n    \t    <!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 -->  \n    \t    <property name=\"connectionFactory\" ref=\"connectionFactory\"/>  \n    \t    <property name=\"defaultDestinationName\" value=\"${activemq.queueName}\"></property>\n    \t</bean> \n    \t\n    \t<!--这个是目的地:mailQueue -->\n    \t<bean id=\"mailQueue\" class=\"org.apache.activemq.command.ActiveMQQueue\">\n    \t\t<constructor-arg>\n    \t\t\t<value>${activemq.queueName}</value>\n    \t\t</constructor-arg>\n    \t</bean>\n    \n    \t<!-- 配置自定义监听：MessageListener -->\n    \t<bean id=\"mailQueueMessageListener\" class=\"bhz.mq.MailQueueMessageListener\"></bean>\n    \n    \t<!-- 将连接工厂、目标对了、自定义监听注入jms模板 -->\n    \t<bean id=\"sessionAwareListenerContainer\" class=\"org.springframework.jms.listener.DefaultMessageListenerContainer\">\n    \t\t<property name=\"connectionFactory\" ref=\"connectionFactory\" />\n    \t\t<property name=\"destination\" ref=\"mailQueue\" />\n    \t\t<property name=\"messageListener\" ref=\"mailQueueMessageListener\" />\n    \t</bean>\n    </beans>","slug":"spring整合ActiveMQ","published":1,"updated":"2024-11-27T03:20:35.244Z","_id":"cm3zaz9c9001btgu6htozetxl","comments":1,"layout":"post","photos":[],"content":"<h6 id=\"spring-整合-ActiveMQ-xml如下：\"><a href=\"#spring-整合-ActiveMQ-xml如下：\" class=\"headerlink\" title=\"spring 整合 ActiveMQ xml如下：\"></a>spring 整合 ActiveMQ xml如下：</h6><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;\n    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;\n    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans  \n           http://www.springframework.org/schema/beans/spring-beans-3.2.xsd  \n           http://www.springframework.org/schema/aop   \n           http://www.springframework.org/schema/aop/spring-aop-3.2.xsd  \n           http://www.springframework.org/schema/tx  \n           http://www.springframework.org/schema/tx/spring-tx-3.2.xsd  \n           http://www.springframework.org/schema/context  \n           http://www.springframework.org/schema/context/spring-context-3.2.xsd&quot;\n    default-autowire=&quot;byName&quot; default-lazy-init=&quot;false&quot;&gt;\n\n\n    &lt;!-- 第三方MQ工厂: ConnectionFactory --&gt;\n    &lt;bean id=&quot;targetConnectionFactory&quot; class=&quot;org.apache.activemq.ActiveMQConnectionFactory&quot;&gt;\n        &lt;!-- ActiveMQ服务地址 --&gt;\n        &lt;property name=&quot;brokerURL&quot; value=&quot;$&#123;activemq.brokerURL&#125;&quot; /&gt;\n        &lt;property name=&quot;userName&quot; value=&quot;$&#123;activemq.userName&#125;&quot;&gt;&lt;/property&gt;\n        &lt;property name=&quot;password&quot; value=&quot;$&#123;activemq.password&#125;&quot;&gt;&lt;/property&gt; \n    &lt;/bean&gt;\n    \n    &lt;!-- \n        ActiveMQ为我们提供了一个PooledConnectionFactory，通过往里面注入一个ActiveMQConnectionFactory\n        可以用来将Connection、Session和MessageProducer池化，这样可以大大的减少我们的资源消耗,要依赖于 activemq-pool包\n     --&gt;\n    &lt;bean id=&quot;pooledConnectionFactory&quot; class=&quot;org.apache.activemq.pool.PooledConnectionFactory&quot;&gt;\n        &lt;property name=&quot;connectionFactory&quot; ref=&quot;targetConnectionFactory&quot; /&gt;\n        &lt;property name=&quot;maxConnections&quot; value=&quot;$&#123;activemq.pool.maxConnections&#125;&quot; /&gt;\n    &lt;/bean&gt;\n\n    &lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt;\n    &lt;bean id=&quot;connectionFactory&quot; class=&quot;org.springframework.jms.connection.SingleConnectionFactory&quot;&gt;\n        &lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt;\n        &lt;property name=&quot;targetConnectionFactory&quot; ref=&quot;pooledConnectionFactory&quot; /&gt;\n    &lt;/bean&gt;\n    \n    &lt;!-- Spring提供的JMS工具类，它可以进行消息发送、接收等 --&gt;\n    \n    &lt;!-- 队列模板 --&gt;\n    &lt;bean id=&quot;jmsTemplate&quot; class=&quot;org.springframework.jms.core.JmsTemplate&quot;&gt;  \n        &lt;!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 --&gt;  \n        &lt;property name=&quot;connectionFactory&quot; ref=&quot;connectionFactory&quot;/&gt;  \n        &lt;property name=&quot;defaultDestinationName&quot; value=&quot;$&#123;activemq.queueName&#125;&quot;&gt;&lt;/property&gt;\n    &lt;/bean&gt; \n    \n    &lt;!--这个是目的地:mailQueue --&gt;\n    &lt;bean id=&quot;mailQueue&quot; class=&quot;org.apache.activemq.command.ActiveMQQueue&quot;&gt;\n        &lt;constructor-arg&gt;\n            &lt;value&gt;$&#123;activemq.queueName&#125;&lt;/value&gt;\n        &lt;/constructor-arg&gt;\n    &lt;/bean&gt;\n\n    &lt;!-- 配置自定义监听：MessageListener --&gt;\n    &lt;bean id=&quot;mailQueueMessageListener&quot; class=&quot;bhz.mq.MailQueueMessageListener&quot;&gt;&lt;/bean&gt;\n\n    &lt;!-- 将连接工厂、目标对了、自定义监听注入jms模板 --&gt;\n    &lt;bean id=&quot;sessionAwareListenerContainer&quot; class=&quot;org.springframework.jms.listener.DefaultMessageListenerContainer&quot;&gt;\n        &lt;property name=&quot;connectionFactory&quot; ref=&quot;connectionFactory&quot; /&gt;\n        &lt;property name=&quot;destination&quot; ref=&quot;mailQueue&quot; /&gt;\n        &lt;property name=&quot;messageListener&quot; ref=&quot;mailQueueMessageListener&quot; /&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;\n</code></pre>\n","excerpt":"","more":"<h6 id=\"spring-整合-ActiveMQ-xml如下：\"><a href=\"#spring-整合-ActiveMQ-xml如下：\" class=\"headerlink\" title=\"spring 整合 ActiveMQ xml如下：\"></a>spring 整合 ActiveMQ xml如下：</h6><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;\n    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;\n    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans  \n           http://www.springframework.org/schema/beans/spring-beans-3.2.xsd  \n           http://www.springframework.org/schema/aop   \n           http://www.springframework.org/schema/aop/spring-aop-3.2.xsd  \n           http://www.springframework.org/schema/tx  \n           http://www.springframework.org/schema/tx/spring-tx-3.2.xsd  \n           http://www.springframework.org/schema/context  \n           http://www.springframework.org/schema/context/spring-context-3.2.xsd&quot;\n    default-autowire=&quot;byName&quot; default-lazy-init=&quot;false&quot;&gt;\n\n\n    &lt;!-- 第三方MQ工厂: ConnectionFactory --&gt;\n    &lt;bean id=&quot;targetConnectionFactory&quot; class=&quot;org.apache.activemq.ActiveMQConnectionFactory&quot;&gt;\n        &lt;!-- ActiveMQ服务地址 --&gt;\n        &lt;property name=&quot;brokerURL&quot; value=&quot;$&#123;activemq.brokerURL&#125;&quot; /&gt;\n        &lt;property name=&quot;userName&quot; value=&quot;$&#123;activemq.userName&#125;&quot;&gt;&lt;/property&gt;\n        &lt;property name=&quot;password&quot; value=&quot;$&#123;activemq.password&#125;&quot;&gt;&lt;/property&gt; \n    &lt;/bean&gt;\n    \n    &lt;!-- \n        ActiveMQ为我们提供了一个PooledConnectionFactory，通过往里面注入一个ActiveMQConnectionFactory\n        可以用来将Connection、Session和MessageProducer池化，这样可以大大的减少我们的资源消耗,要依赖于 activemq-pool包\n     --&gt;\n    &lt;bean id=&quot;pooledConnectionFactory&quot; class=&quot;org.apache.activemq.pool.PooledConnectionFactory&quot;&gt;\n        &lt;property name=&quot;connectionFactory&quot; ref=&quot;targetConnectionFactory&quot; /&gt;\n        &lt;property name=&quot;maxConnections&quot; value=&quot;$&#123;activemq.pool.maxConnections&#125;&quot; /&gt;\n    &lt;/bean&gt;\n\n    &lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt;\n    &lt;bean id=&quot;connectionFactory&quot; class=&quot;org.springframework.jms.connection.SingleConnectionFactory&quot;&gt;\n        &lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt;\n        &lt;property name=&quot;targetConnectionFactory&quot; ref=&quot;pooledConnectionFactory&quot; /&gt;\n    &lt;/bean&gt;\n    \n    &lt;!-- Spring提供的JMS工具类，它可以进行消息发送、接收等 --&gt;\n    \n    &lt;!-- 队列模板 --&gt;\n    &lt;bean id=&quot;jmsTemplate&quot; class=&quot;org.springframework.jms.core.JmsTemplate&quot;&gt;  \n        &lt;!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 --&gt;  \n        &lt;property name=&quot;connectionFactory&quot; ref=&quot;connectionFactory&quot;/&gt;  \n        &lt;property name=&quot;defaultDestinationName&quot; value=&quot;$&#123;activemq.queueName&#125;&quot;&gt;&lt;/property&gt;\n    &lt;/bean&gt; \n    \n    &lt;!--这个是目的地:mailQueue --&gt;\n    &lt;bean id=&quot;mailQueue&quot; class=&quot;org.apache.activemq.command.ActiveMQQueue&quot;&gt;\n        &lt;constructor-arg&gt;\n            &lt;value&gt;$&#123;activemq.queueName&#125;&lt;/value&gt;\n        &lt;/constructor-arg&gt;\n    &lt;/bean&gt;\n\n    &lt;!-- 配置自定义监听：MessageListener --&gt;\n    &lt;bean id=&quot;mailQueueMessageListener&quot; class=&quot;bhz.mq.MailQueueMessageListener&quot;&gt;&lt;/bean&gt;\n\n    &lt;!-- 将连接工厂、目标对了、自定义监听注入jms模板 --&gt;\n    &lt;bean id=&quot;sessionAwareListenerContainer&quot; class=&quot;org.springframework.jms.listener.DefaultMessageListenerContainer&quot;&gt;\n        &lt;property name=&quot;connectionFactory&quot; ref=&quot;connectionFactory&quot; /&gt;\n        &lt;property name=&quot;destination&quot; ref=&quot;mailQueue&quot; /&gt;\n        &lt;property name=&quot;messageListener&quot; ref=&quot;mailQueueMessageListener&quot; /&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;\n</code></pre>\n"},{"title":"windows下安装redis","date":"2016-11-16T01:00:00.000Z","_content":" \n# windows 下安装redis步骤：\n\n##### 1.点击 <a href=\"https://github.com/MicrosoftArchive/redis/releases\">redis</a> 选择zip版本，下载并解压\n\n##### 2.修改配置\n\n1. maxheap 在 redis.windows.conf 找到 # maxheap <bytes> maxheap 1024000000（这是设置最大数据堆的大小）\n2. requirepass redis.windows.conf 搜索# requirepass foobared 修改密码,去掉‘#’\n3. port 修改端口 redis.windows.conf 搜索port 6379\n\n##### 3.运行\n\n    redis-server.exe redis.windows.conf\n\n##### 4.安装成windows服务\n\n    redis-server --service-install redis.windows.conf --loglevel verbose  --service-name Redis  注册为服务（要以管理员权限运行 cmd）\n\n##### 5.图形化工具 <a href=\"https://redisdesktop.com/download\">下载</a>\n\n    \n     ","source":"_posts/windows下安装redis.md","raw":"---\ntitle: \"windows下安装redis\"\ndate: 2016-11-16 09:00:00\ncategories: Redis\ntags:\n  - redis\n---\n \n# windows 下安装redis步骤：\n\n##### 1.点击 <a href=\"https://github.com/MicrosoftArchive/redis/releases\">redis</a> 选择zip版本，下载并解压\n\n##### 2.修改配置\n\n1. maxheap 在 redis.windows.conf 找到 # maxheap <bytes> maxheap 1024000000（这是设置最大数据堆的大小）\n2. requirepass redis.windows.conf 搜索# requirepass foobared 修改密码,去掉‘#’\n3. port 修改端口 redis.windows.conf 搜索port 6379\n\n##### 3.运行\n\n    redis-server.exe redis.windows.conf\n\n##### 4.安装成windows服务\n\n    redis-server --service-install redis.windows.conf --loglevel verbose  --service-name Redis  注册为服务（要以管理员权限运行 cmd）\n\n##### 5.图形化工具 <a href=\"https://redisdesktop.com/download\">下载</a>\n\n    \n     ","slug":"windows下安装redis","published":1,"updated":"2024-11-27T03:20:35.222Z","_id":"cm3zaz9c9001etgu676wjby5x","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"windows-下安装redis步骤：\"><a href=\"#windows-下安装redis步骤：\" class=\"headerlink\" title=\"windows 下安装redis步骤：\"></a>windows 下安装redis步骤：</h1><h5 id=\"1-点击-redis-选择zip版本，下载并解压\"><a href=\"#1-点击-redis-选择zip版本，下载并解压\" class=\"headerlink\" title=\"1.点击 redis 选择zip版本，下载并解压\"></a>1.点击 <a href=\"https://github.com/MicrosoftArchive/redis/releases\">redis</a> 选择zip版本，下载并解压</h5><h5 id=\"2-修改配置\"><a href=\"#2-修改配置\" class=\"headerlink\" title=\"2.修改配置\"></a>2.修改配置</h5><ol>\n<li>maxheap 在 redis.windows.conf 找到 # maxheap <bytes> maxheap 1024000000（这是设置最大数据堆的大小）</li>\n<li>requirepass redis.windows.conf 搜索# requirepass foobared 修改密码,去掉‘#’</li>\n<li>port 修改端口 redis.windows.conf 搜索port 6379</li>\n</ol>\n<h5 id=\"3-运行\"><a href=\"#3-运行\" class=\"headerlink\" title=\"3.运行\"></a>3.运行</h5><pre><code>redis-server.exe redis.windows.conf\n</code></pre>\n<h5 id=\"4-安装成windows服务\"><a href=\"#4-安装成windows服务\" class=\"headerlink\" title=\"4.安装成windows服务\"></a>4.安装成windows服务</h5><pre><code>redis-server --service-install redis.windows.conf --loglevel verbose  --service-name Redis  注册为服务（要以管理员权限运行 cmd）\n</code></pre>\n<h5 id=\"5-图形化工具-下载\"><a href=\"#5-图形化工具-下载\" class=\"headerlink\" title=\"5.图形化工具 下载\"></a>5.图形化工具 <a href=\"https://redisdesktop.com/download\">下载</a></h5>","excerpt":"","more":"<h1 id=\"windows-下安装redis步骤：\"><a href=\"#windows-下安装redis步骤：\" class=\"headerlink\" title=\"windows 下安装redis步骤：\"></a>windows 下安装redis步骤：</h1><h5 id=\"1-点击-redis-选择zip版本，下载并解压\"><a href=\"#1-点击-redis-选择zip版本，下载并解压\" class=\"headerlink\" title=\"1.点击 redis 选择zip版本，下载并解压\"></a>1.点击 <a href=\"https://github.com/MicrosoftArchive/redis/releases\">redis</a> 选择zip版本，下载并解压</h5><h5 id=\"2-修改配置\"><a href=\"#2-修改配置\" class=\"headerlink\" title=\"2.修改配置\"></a>2.修改配置</h5><ol>\n<li>maxheap 在 redis.windows.conf 找到 # maxheap <bytes> maxheap 1024000000（这是设置最大数据堆的大小）</li>\n<li>requirepass redis.windows.conf 搜索# requirepass foobared 修改密码,去掉‘#’</li>\n<li>port 修改端口 redis.windows.conf 搜索port 6379</li>\n</ol>\n<h5 id=\"3-运行\"><a href=\"#3-运行\" class=\"headerlink\" title=\"3.运行\"></a>3.运行</h5><pre><code>redis-server.exe redis.windows.conf\n</code></pre>\n<h5 id=\"4-安装成windows服务\"><a href=\"#4-安装成windows服务\" class=\"headerlink\" title=\"4.安装成windows服务\"></a>4.安装成windows服务</h5><pre><code>redis-server --service-install redis.windows.conf --loglevel verbose  --service-name Redis  注册为服务（要以管理员权限运行 cmd）\n</code></pre>\n<h5 id=\"5-图形化工具-下载\"><a href=\"#5-图形化工具-下载\" class=\"headerlink\" title=\"5.图形化工具 下载\"></a>5.图形化工具 <a href=\"https://redisdesktop.com/download\">下载</a></h5>"},{"title":"获取spring中的bean","date":"2016-10-01T01:00:00.000Z","_content":"\n##### 有时候在各种情况下，需要注入spring 管理的bean，可以通过 一下3种方式。\n\n###### 1.通过WebApplicationContextUtils得到得到 ApplicationContext ,需要传入ServletContext 上下文\n\n     ApplicationContext application=WebApplicationContextUtils.getWebApplicationContext(servletContext);  \n\n###### 2.以静态变量保存 ApplicationContext 不过该类需要在spring中实例化注入ApplicationContext, 静态变量不能注入 但是setXX 方式可以注入。\n\n    <bean class=\"SpringContextHolder\"/>\n     \n    import java.util.Map;\n    import org.springframework.context.ApplicationContext;\n    import org.springframework.context.ApplicationContextAware;\n    \n    public class SpringContextHolder implements ApplicationContextAware {\n    \n    \tprivate static ApplicationContext applicationContext;\n    \n    \t// 实现ApplicationContextAware接口的context注入函数, 将其存入静态变量.\n    \t@Override\n    \tpublic void setApplicationContext(ApplicationContext applicationContext) {\n    \t\tSpringContextHolder.applicationContext = applicationContext;\n    \t}\n    \n    \t// 取得存储在静态变量中的ApplicationContext.\n    \tpublic static ApplicationContext getApplicationContext() {\n    \t\tcheckApplicationContext();\n    \t\treturn applicationContext;\n    \t}\n    \n    \t// 从静态变量ApplicationContext中取得Bean, 自动转型为所赋值对象的类型.\n    \t@SuppressWarnings(\"unchecked\")\n    \tpublic static <T> T getBean(String name) {\n    \t\tcheckApplicationContext();\n    \t\treturn (T) applicationContext.getBean(name);\n    \t}\n    \n    \t// 从静态变量ApplicationContext中取得Bean, 自动转型为所赋值对象的类型.\n    \t// 从静态变量ApplicationContext中取得Bean, 自动转型为所赋值对象的类型.\n    \t// 如果有多个Bean符合Class, 取出第一个.\n    \t@SuppressWarnings(\"unchecked\")\n    \tpublic static <T> T getBean(Class<T> clazz) {\n    \t\tcheckApplicationContext();\n    \t\t@SuppressWarnings(\"rawtypes\")\n    \t\tMap beanMaps = applicationContext.getBeansOfType(clazz);\n    \t\tif (beanMaps != null && !beanMaps.isEmpty()) {\n    \t\t\treturn (T) beanMaps.values().iterator().next();\n    \t\t} else {\n    \t\t\treturn null;\n    \t\t}\n    \t}\n    \n    \tprivate static void checkApplicationContext() {\n    \t\tif (applicationContext == null) {\n    \t\t\tthrow new IllegalStateException(\"applicaitonContext未注入,请在applicationContext.xml中定义SpringContextHolder\");\n    \t\t}\n    \t}\n    \n    }\n\n###### 3.使用spring提供的工具方法，可以将不受spring 管理的bean 被纳入管理\n\n     SpringBeanAutowiringSupport.processInjectionBasedOnCurrentContext(x.class);","source":"_posts/获取spring中的bean.md","raw":"---\ntitle: \"获取spring中的bean\"\ndate: 2016-10-01 09:00:00\ncategories: Spring\ntags:\n  - bean\n---\n\n##### 有时候在各种情况下，需要注入spring 管理的bean，可以通过 一下3种方式。\n\n###### 1.通过WebApplicationContextUtils得到得到 ApplicationContext ,需要传入ServletContext 上下文\n\n     ApplicationContext application=WebApplicationContextUtils.getWebApplicationContext(servletContext);  \n\n###### 2.以静态变量保存 ApplicationContext 不过该类需要在spring中实例化注入ApplicationContext, 静态变量不能注入 但是setXX 方式可以注入。\n\n    <bean class=\"SpringContextHolder\"/>\n     \n    import java.util.Map;\n    import org.springframework.context.ApplicationContext;\n    import org.springframework.context.ApplicationContextAware;\n    \n    public class SpringContextHolder implements ApplicationContextAware {\n    \n    \tprivate static ApplicationContext applicationContext;\n    \n    \t// 实现ApplicationContextAware接口的context注入函数, 将其存入静态变量.\n    \t@Override\n    \tpublic void setApplicationContext(ApplicationContext applicationContext) {\n    \t\tSpringContextHolder.applicationContext = applicationContext;\n    \t}\n    \n    \t// 取得存储在静态变量中的ApplicationContext.\n    \tpublic static ApplicationContext getApplicationContext() {\n    \t\tcheckApplicationContext();\n    \t\treturn applicationContext;\n    \t}\n    \n    \t// 从静态变量ApplicationContext中取得Bean, 自动转型为所赋值对象的类型.\n    \t@SuppressWarnings(\"unchecked\")\n    \tpublic static <T> T getBean(String name) {\n    \t\tcheckApplicationContext();\n    \t\treturn (T) applicationContext.getBean(name);\n    \t}\n    \n    \t// 从静态变量ApplicationContext中取得Bean, 自动转型为所赋值对象的类型.\n    \t// 从静态变量ApplicationContext中取得Bean, 自动转型为所赋值对象的类型.\n    \t// 如果有多个Bean符合Class, 取出第一个.\n    \t@SuppressWarnings(\"unchecked\")\n    \tpublic static <T> T getBean(Class<T> clazz) {\n    \t\tcheckApplicationContext();\n    \t\t@SuppressWarnings(\"rawtypes\")\n    \t\tMap beanMaps = applicationContext.getBeansOfType(clazz);\n    \t\tif (beanMaps != null && !beanMaps.isEmpty()) {\n    \t\t\treturn (T) beanMaps.values().iterator().next();\n    \t\t} else {\n    \t\t\treturn null;\n    \t\t}\n    \t}\n    \n    \tprivate static void checkApplicationContext() {\n    \t\tif (applicationContext == null) {\n    \t\t\tthrow new IllegalStateException(\"applicaitonContext未注入,请在applicationContext.xml中定义SpringContextHolder\");\n    \t\t}\n    \t}\n    \n    }\n\n###### 3.使用spring提供的工具方法，可以将不受spring 管理的bean 被纳入管理\n\n     SpringBeanAutowiringSupport.processInjectionBasedOnCurrentContext(x.class);","slug":"获取spring中的bean","published":1,"updated":"2024-11-27T03:20:35.209Z","_id":"cm3zaz9cc001xtgu6ehl0bmz4","comments":1,"layout":"post","photos":[],"content":"<h5 id=\"有时候在各种情况下，需要注入spring-管理的bean，可以通过-一下3种方式。\"><a href=\"#有时候在各种情况下，需要注入spring-管理的bean，可以通过-一下3种方式。\" class=\"headerlink\" title=\"有时候在各种情况下，需要注入spring 管理的bean，可以通过 一下3种方式。\"></a>有时候在各种情况下，需要注入spring 管理的bean，可以通过 一下3种方式。</h5><h6 id=\"1-通过WebApplicationContextUtils得到得到-ApplicationContext-需要传入ServletContext-上下文\"><a href=\"#1-通过WebApplicationContextUtils得到得到-ApplicationContext-需要传入ServletContext-上下文\" class=\"headerlink\" title=\"1.通过WebApplicationContextUtils得到得到 ApplicationContext ,需要传入ServletContext 上下文\"></a>1.通过WebApplicationContextUtils得到得到 ApplicationContext ,需要传入ServletContext 上下文</h6><pre><code> ApplicationContext application=WebApplicationContextUtils.getWebApplicationContext(servletContext);  \n</code></pre>\n<h6 id=\"2-以静态变量保存-ApplicationContext-不过该类需要在spring中实例化注入ApplicationContext-静态变量不能注入-但是setXX-方式可以注入。\"><a href=\"#2-以静态变量保存-ApplicationContext-不过该类需要在spring中实例化注入ApplicationContext-静态变量不能注入-但是setXX-方式可以注入。\" class=\"headerlink\" title=\"2.以静态变量保存 ApplicationContext 不过该类需要在spring中实例化注入ApplicationContext, 静态变量不能注入 但是setXX 方式可以注入。\"></a>2.以静态变量保存 ApplicationContext 不过该类需要在spring中实例化注入ApplicationContext, 静态变量不能注入 但是setXX 方式可以注入。</h6><pre><code>&lt;bean class=&quot;SpringContextHolder&quot;/&gt;\n \nimport java.util.Map;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.ApplicationContextAware;\n\npublic class SpringContextHolder implements ApplicationContextAware &#123;\n\n    private static ApplicationContext applicationContext;\n\n    // 实现ApplicationContextAware接口的context注入函数, 将其存入静态变量.\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) &#123;\n        SpringContextHolder.applicationContext = applicationContext;\n    &#125;\n\n    // 取得存储在静态变量中的ApplicationContext.\n    public static ApplicationContext getApplicationContext() &#123;\n        checkApplicationContext();\n        return applicationContext;\n    &#125;\n\n    // 从静态变量ApplicationContext中取得Bean, 自动转型为所赋值对象的类型.\n    @SuppressWarnings(&quot;unchecked&quot;)\n    public static &lt;T&gt; T getBean(String name) &#123;\n        checkApplicationContext();\n        return (T) applicationContext.getBean(name);\n    &#125;\n\n    // 从静态变量ApplicationContext中取得Bean, 自动转型为所赋值对象的类型.\n    // 从静态变量ApplicationContext中取得Bean, 自动转型为所赋值对象的类型.\n    // 如果有多个Bean符合Class, 取出第一个.\n    @SuppressWarnings(&quot;unchecked&quot;)\n    public static &lt;T&gt; T getBean(Class&lt;T&gt; clazz) &#123;\n        checkApplicationContext();\n        @SuppressWarnings(&quot;rawtypes&quot;)\n        Map beanMaps = applicationContext.getBeansOfType(clazz);\n        if (beanMaps != null &amp;&amp; !beanMaps.isEmpty()) &#123;\n            return (T) beanMaps.values().iterator().next();\n        &#125; else &#123;\n            return null;\n        &#125;\n    &#125;\n\n    private static void checkApplicationContext() &#123;\n        if (applicationContext == null) &#123;\n            throw new IllegalStateException(&quot;applicaitonContext未注入,请在applicationContext.xml中定义SpringContextHolder&quot;);\n        &#125;\n    &#125;\n\n&#125;\n</code></pre>\n<h6 id=\"3-使用spring提供的工具方法，可以将不受spring-管理的bean-被纳入管理\"><a href=\"#3-使用spring提供的工具方法，可以将不受spring-管理的bean-被纳入管理\" class=\"headerlink\" title=\"3.使用spring提供的工具方法，可以将不受spring 管理的bean 被纳入管理\"></a>3.使用spring提供的工具方法，可以将不受spring 管理的bean 被纳入管理</h6><pre><code> SpringBeanAutowiringSupport.processInjectionBasedOnCurrentContext(x.class);\n</code></pre>\n","excerpt":"","more":"<h5 id=\"有时候在各种情况下，需要注入spring-管理的bean，可以通过-一下3种方式。\"><a href=\"#有时候在各种情况下，需要注入spring-管理的bean，可以通过-一下3种方式。\" class=\"headerlink\" title=\"有时候在各种情况下，需要注入spring 管理的bean，可以通过 一下3种方式。\"></a>有时候在各种情况下，需要注入spring 管理的bean，可以通过 一下3种方式。</h5><h6 id=\"1-通过WebApplicationContextUtils得到得到-ApplicationContext-需要传入ServletContext-上下文\"><a href=\"#1-通过WebApplicationContextUtils得到得到-ApplicationContext-需要传入ServletContext-上下文\" class=\"headerlink\" title=\"1.通过WebApplicationContextUtils得到得到 ApplicationContext ,需要传入ServletContext 上下文\"></a>1.通过WebApplicationContextUtils得到得到 ApplicationContext ,需要传入ServletContext 上下文</h6><pre><code> ApplicationContext application=WebApplicationContextUtils.getWebApplicationContext(servletContext);  \n</code></pre>\n<h6 id=\"2-以静态变量保存-ApplicationContext-不过该类需要在spring中实例化注入ApplicationContext-静态变量不能注入-但是setXX-方式可以注入。\"><a href=\"#2-以静态变量保存-ApplicationContext-不过该类需要在spring中实例化注入ApplicationContext-静态变量不能注入-但是setXX-方式可以注入。\" class=\"headerlink\" title=\"2.以静态变量保存 ApplicationContext 不过该类需要在spring中实例化注入ApplicationContext, 静态变量不能注入 但是setXX 方式可以注入。\"></a>2.以静态变量保存 ApplicationContext 不过该类需要在spring中实例化注入ApplicationContext, 静态变量不能注入 但是setXX 方式可以注入。</h6><pre><code>&lt;bean class=&quot;SpringContextHolder&quot;/&gt;\n \nimport java.util.Map;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.ApplicationContextAware;\n\npublic class SpringContextHolder implements ApplicationContextAware &#123;\n\n    private static ApplicationContext applicationContext;\n\n    // 实现ApplicationContextAware接口的context注入函数, 将其存入静态变量.\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) &#123;\n        SpringContextHolder.applicationContext = applicationContext;\n    &#125;\n\n    // 取得存储在静态变量中的ApplicationContext.\n    public static ApplicationContext getApplicationContext() &#123;\n        checkApplicationContext();\n        return applicationContext;\n    &#125;\n\n    // 从静态变量ApplicationContext中取得Bean, 自动转型为所赋值对象的类型.\n    @SuppressWarnings(&quot;unchecked&quot;)\n    public static &lt;T&gt; T getBean(String name) &#123;\n        checkApplicationContext();\n        return (T) applicationContext.getBean(name);\n    &#125;\n\n    // 从静态变量ApplicationContext中取得Bean, 自动转型为所赋值对象的类型.\n    // 从静态变量ApplicationContext中取得Bean, 自动转型为所赋值对象的类型.\n    // 如果有多个Bean符合Class, 取出第一个.\n    @SuppressWarnings(&quot;unchecked&quot;)\n    public static &lt;T&gt; T getBean(Class&lt;T&gt; clazz) &#123;\n        checkApplicationContext();\n        @SuppressWarnings(&quot;rawtypes&quot;)\n        Map beanMaps = applicationContext.getBeansOfType(clazz);\n        if (beanMaps != null &amp;&amp; !beanMaps.isEmpty()) &#123;\n            return (T) beanMaps.values().iterator().next();\n        &#125; else &#123;\n            return null;\n        &#125;\n    &#125;\n\n    private static void checkApplicationContext() &#123;\n        if (applicationContext == null) &#123;\n            throw new IllegalStateException(&quot;applicaitonContext未注入,请在applicationContext.xml中定义SpringContextHolder&quot;);\n        &#125;\n    &#125;\n\n&#125;\n</code></pre>\n<h6 id=\"3-使用spring提供的工具方法，可以将不受spring-管理的bean-被纳入管理\"><a href=\"#3-使用spring提供的工具方法，可以将不受spring-管理的bean-被纳入管理\" class=\"headerlink\" title=\"3.使用spring提供的工具方法，可以将不受spring 管理的bean 被纳入管理\"></a>3.使用spring提供的工具方法，可以将不受spring 管理的bean 被纳入管理</h6><pre><code> SpringBeanAutowiringSupport.processInjectionBasedOnCurrentContext(x.class);\n</code></pre>\n"},{"title":"解决分布式事务常用的3种实现方式","date":"2017-09-11T01:00:00.000Z","_content":"\n# 解决分布式事务常用的3种实现方式\n\n## 1、xa : XA两阶段提交的分布式事务管理器， 基于 ByteJTA实现的分布式解决方案。在此感谢作者的奉献 <a href=\"https://github.com/liuyangming/ByteJTA\" >坐标</a>\n\n## 2、tcc : TCC机制的分布式事务管理器, 基于 ByteTCC实现的分布式解决方案。在此感谢作者的奉献 <a href=\"https://github.com/liuyangming/ByteTCC\" >坐标</a>\n\n## 3、msg :  基于可靠消息实现最终一致性,由本人搭建。消息中间件使用 rocketmq。  <a href=\"https://git.oschina.net/wenjie001/distributed.git\">坐标</a>\n\n    1. order-facade 订单接口\n    2. order-service 订单服务\n    3. pay-facade 支付接口\n    4. pay-service支付服务\n    5. tx-msg消息表 操作公用组件，order-service、pay-service 依赖 tx-msg 保证这两个服务对消息的操作和业务的操作在一个事务里。（不可采用远程调用，否则有出现分布式事务）\n    6. 当发起支付流程后，调用pay-service操作业务（扣钱或其他），同时发送一个事务消息，且同时记录事务消息（该消息事务状态未确定）。\n    7. order-service 收到消息消费时操作业务（修改订单状态），同时记录消息 这两者在一个事务环境。\n    8. 定时比较 事务消息，和已消费的消息。将超时且没有消费的事务消息重发。\n    9. 实现最终数据一致。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/解决分布式事务常用的3种实现方式.md","raw":"---\ntitle: \"解决分布式事务常用的3种实现方式\"\ndate: 2017-09-11 09:00:00\ncategories: 分布式事务\ntags:\n  - 分布式事务\n---\n\n# 解决分布式事务常用的3种实现方式\n\n## 1、xa : XA两阶段提交的分布式事务管理器， 基于 ByteJTA实现的分布式解决方案。在此感谢作者的奉献 <a href=\"https://github.com/liuyangming/ByteJTA\" >坐标</a>\n\n## 2、tcc : TCC机制的分布式事务管理器, 基于 ByteTCC实现的分布式解决方案。在此感谢作者的奉献 <a href=\"https://github.com/liuyangming/ByteTCC\" >坐标</a>\n\n## 3、msg :  基于可靠消息实现最终一致性,由本人搭建。消息中间件使用 rocketmq。  <a href=\"https://git.oschina.net/wenjie001/distributed.git\">坐标</a>\n\n    1. order-facade 订单接口\n    2. order-service 订单服务\n    3. pay-facade 支付接口\n    4. pay-service支付服务\n    5. tx-msg消息表 操作公用组件，order-service、pay-service 依赖 tx-msg 保证这两个服务对消息的操作和业务的操作在一个事务里。（不可采用远程调用，否则有出现分布式事务）\n    6. 当发起支付流程后，调用pay-service操作业务（扣钱或其他），同时发送一个事务消息，且同时记录事务消息（该消息事务状态未确定）。\n    7. order-service 收到消息消费时操作业务（修改订单状态），同时记录消息 这两者在一个事务环境。\n    8. 定时比较 事务消息，和已消费的消息。将超时且没有消费的事务消息重发。\n    9. 实现最终数据一致。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"解决分布式事务常用的3种实现方式","published":1,"updated":"2024-11-27T03:20:35.227Z","_id":"cm3zaz9cc001ytgu68f0v4u40","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"解决分布式事务常用的3种实现方式\"><a href=\"#解决分布式事务常用的3种实现方式\" class=\"headerlink\" title=\"解决分布式事务常用的3种实现方式\"></a>解决分布式事务常用的3种实现方式</h1><h2 id=\"1、xa-XA两阶段提交的分布式事务管理器，-基于-ByteJTA实现的分布式解决方案。在此感谢作者的奉献-坐标\"><a href=\"#1、xa-XA两阶段提交的分布式事务管理器，-基于-ByteJTA实现的分布式解决方案。在此感谢作者的奉献-坐标\" class=\"headerlink\" title=\"1、xa : XA两阶段提交的分布式事务管理器， 基于 ByteJTA实现的分布式解决方案。在此感谢作者的奉献 坐标\"></a>1、xa : XA两阶段提交的分布式事务管理器， 基于 ByteJTA实现的分布式解决方案。在此感谢作者的奉献 <a href=\"https://github.com/liuyangming/ByteJTA\" >坐标</a></h2><h2 id=\"2、tcc-TCC机制的分布式事务管理器-基于-ByteTCC实现的分布式解决方案。在此感谢作者的奉献-坐标\"><a href=\"#2、tcc-TCC机制的分布式事务管理器-基于-ByteTCC实现的分布式解决方案。在此感谢作者的奉献-坐标\" class=\"headerlink\" title=\"2、tcc : TCC机制的分布式事务管理器, 基于 ByteTCC实现的分布式解决方案。在此感谢作者的奉献 坐标\"></a>2、tcc : TCC机制的分布式事务管理器, 基于 ByteTCC实现的分布式解决方案。在此感谢作者的奉献 <a href=\"https://github.com/liuyangming/ByteTCC\" >坐标</a></h2><h2 id=\"3、msg-基于可靠消息实现最终一致性-由本人搭建。消息中间件使用-rocketmq。-坐标\"><a href=\"#3、msg-基于可靠消息实现最终一致性-由本人搭建。消息中间件使用-rocketmq。-坐标\" class=\"headerlink\" title=\"3、msg :  基于可靠消息实现最终一致性,由本人搭建。消息中间件使用 rocketmq。  坐标\"></a>3、msg :  基于可靠消息实现最终一致性,由本人搭建。消息中间件使用 rocketmq。  <a href=\"https://git.oschina.net/wenjie001/distributed.git\">坐标</a></h2><pre><code>1. order-facade 订单接口\n2. order-service 订单服务\n3. pay-facade 支付接口\n4. pay-service支付服务\n5. tx-msg消息表 操作公用组件，order-service、pay-service 依赖 tx-msg 保证这两个服务对消息的操作和业务的操作在一个事务里。（不可采用远程调用，否则有出现分布式事务）\n6. 当发起支付流程后，调用pay-service操作业务（扣钱或其他），同时发送一个事务消息，且同时记录事务消息（该消息事务状态未确定）。\n7. order-service 收到消息消费时操作业务（修改订单状态），同时记录消息 这两者在一个事务环境。\n8. 定时比较 事务消息，和已消费的消息。将超时且没有消费的事务消息重发。\n9. 实现最终数据一致。\n</code></pre>\n","excerpt":"","more":"<h1 id=\"解决分布式事务常用的3种实现方式\"><a href=\"#解决分布式事务常用的3种实现方式\" class=\"headerlink\" title=\"解决分布式事务常用的3种实现方式\"></a>解决分布式事务常用的3种实现方式</h1><h2 id=\"1、xa-XA两阶段提交的分布式事务管理器，-基于-ByteJTA实现的分布式解决方案。在此感谢作者的奉献-坐标\"><a href=\"#1、xa-XA两阶段提交的分布式事务管理器，-基于-ByteJTA实现的分布式解决方案。在此感谢作者的奉献-坐标\" class=\"headerlink\" title=\"1、xa : XA两阶段提交的分布式事务管理器， 基于 ByteJTA实现的分布式解决方案。在此感谢作者的奉献 坐标\"></a>1、xa : XA两阶段提交的分布式事务管理器， 基于 ByteJTA实现的分布式解决方案。在此感谢作者的奉献 <a href=\"https://github.com/liuyangming/ByteJTA\" >坐标</a></h2><h2 id=\"2、tcc-TCC机制的分布式事务管理器-基于-ByteTCC实现的分布式解决方案。在此感谢作者的奉献-坐标\"><a href=\"#2、tcc-TCC机制的分布式事务管理器-基于-ByteTCC实现的分布式解决方案。在此感谢作者的奉献-坐标\" class=\"headerlink\" title=\"2、tcc : TCC机制的分布式事务管理器, 基于 ByteTCC实现的分布式解决方案。在此感谢作者的奉献 坐标\"></a>2、tcc : TCC机制的分布式事务管理器, 基于 ByteTCC实现的分布式解决方案。在此感谢作者的奉献 <a href=\"https://github.com/liuyangming/ByteTCC\" >坐标</a></h2><h2 id=\"3、msg-基于可靠消息实现最终一致性-由本人搭建。消息中间件使用-rocketmq。-坐标\"><a href=\"#3、msg-基于可靠消息实现最终一致性-由本人搭建。消息中间件使用-rocketmq。-坐标\" class=\"headerlink\" title=\"3、msg :  基于可靠消息实现最终一致性,由本人搭建。消息中间件使用 rocketmq。  坐标\"></a>3、msg :  基于可靠消息实现最终一致性,由本人搭建。消息中间件使用 rocketmq。  <a href=\"https://git.oschina.net/wenjie001/distributed.git\">坐标</a></h2><pre><code>1. order-facade 订单接口\n2. order-service 订单服务\n3. pay-facade 支付接口\n4. pay-service支付服务\n5. tx-msg消息表 操作公用组件，order-service、pay-service 依赖 tx-msg 保证这两个服务对消息的操作和业务的操作在一个事务里。（不可采用远程调用，否则有出现分布式事务）\n6. 当发起支付流程后，调用pay-service操作业务（扣钱或其他），同时发送一个事务消息，且同时记录事务消息（该消息事务状态未确定）。\n7. order-service 收到消息消费时操作业务（修改订单状态），同时记录消息 这两者在一个事务环境。\n8. 定时比较 事务消息，和已消费的消息。将超时且没有消费的事务消息重发。\n9. 实现最终数据一致。\n</code></pre>\n"},{"title":"那些年踩过的坑——持续更新中","date":"2016-02-21T16:00:00.000Z","_content":"\n在java web开发过程中，遇到的各类问题总结，包括java语言，spring，spring mvc，ibatis框架等使用过程中遇到的一些常见的，或者不常见的问题。分条列举，附有问题详情以及解决方案。\n\n### 1.java定义的boolen数据类型的get，set函数（定义为isEditable）：\n\n```java\nprivate boolean isEditable;//是否可以编辑\n\npublic boolean isEditable() {\n    return isEditable;\n}\n\npublic void setEditable(boolean isEditable) {\n    this.isEditable = isEditable;\n}\n```\n\n**现象**：IDEA自动生成的boolean类型与我们的预期有一定的差异，属性isEditable的getter访问器是isEditable(),\n而不是getIsEditable()；setter访问器是setEditable(),而不是setIsEditable()。\n\n**原因**：由于属性名isEditable的is没有去掉， 以致java bean类违背了java bean 的命名规范。\n`JavaBean 的属性名和getter/setter存取方法规则小结：`\n> * 对于常规属性propertyName ，\n    属性名称的第一个单词小写且字母个数大于1，第二个单词首字母大写。对应的getter/setter方法名为：get/set + PropertyName()，\n    即属性名称的第一个单词的首字母改成大写，前面再加上\"get\"或\"set\"前缀。\n> * 对于布尔类型propertyName,可以按常规属性的规则编写getter/setter方法外， getter方法可以使用 is + PropertyName()的形式来代替。\n> * 对于非常规属性pName，属性名称的第一个单词小写且字母个数等于1，第二个单词首字母大写,分一下三种情况：\n\n`1.`对应的getter/setter方法名可以为：get/set + PName()， 即第一个单词的首字母为改为大写，前面再加上\"get\"或\"set\"前缀。\n\n`2.`对应的getter/setter方法名也可以为：get/set + pName()， 即属性名称不变，第一个单词的首字母任然为小写，前面再加上\"get\"或\"\nset\"前缀。\n\n`3.`对于非常规属性PName， 属性名称的前两个字母都是大写 。即连续两个大写字母开头的属性名。对应的getter/setter方法名为：\nget/set+PName()\n\n`4.`对于非常规属性<Property>或<PropertyName>， 属性名称第一个字母大写 。网上有帖子说这是不符合JSR规范的，会报 \"属性找不到\"\n的错误。\n\n**总结**：\n**1. javabean属性命名尽量使用常规的驼峰式命名规则**\n**2. 属性名第一个单词尽量避免使用一个字母：如eBook， eMail**\n**3. boolean属性名避免使用 “is” 开头的名称**\n**4. 随着jdk， eclipse， spring 等软件版本的不断提高， 底版本的出现的问题可能在高版本中解决了， 低版本原来正常的代码可能在高版本环境下不再支持。\n**\n","source":"_posts/那些年踩过的坑——持续更新中.md","raw":"---\ntitle: 那些年踩过的坑——持续更新中\ndate: 2016-02-22 00:00:00\ncategory: 经验\ntags:\n  - java\n---\n\n在java web开发过程中，遇到的各类问题总结，包括java语言，spring，spring mvc，ibatis框架等使用过程中遇到的一些常见的，或者不常见的问题。分条列举，附有问题详情以及解决方案。\n\n### 1.java定义的boolen数据类型的get，set函数（定义为isEditable）：\n\n```java\nprivate boolean isEditable;//是否可以编辑\n\npublic boolean isEditable() {\n    return isEditable;\n}\n\npublic void setEditable(boolean isEditable) {\n    this.isEditable = isEditable;\n}\n```\n\n**现象**：IDEA自动生成的boolean类型与我们的预期有一定的差异，属性isEditable的getter访问器是isEditable(),\n而不是getIsEditable()；setter访问器是setEditable(),而不是setIsEditable()。\n\n**原因**：由于属性名isEditable的is没有去掉， 以致java bean类违背了java bean 的命名规范。\n`JavaBean 的属性名和getter/setter存取方法规则小结：`\n> * 对于常规属性propertyName ，\n    属性名称的第一个单词小写且字母个数大于1，第二个单词首字母大写。对应的getter/setter方法名为：get/set + PropertyName()，\n    即属性名称的第一个单词的首字母改成大写，前面再加上\"get\"或\"set\"前缀。\n> * 对于布尔类型propertyName,可以按常规属性的规则编写getter/setter方法外， getter方法可以使用 is + PropertyName()的形式来代替。\n> * 对于非常规属性pName，属性名称的第一个单词小写且字母个数等于1，第二个单词首字母大写,分一下三种情况：\n\n`1.`对应的getter/setter方法名可以为：get/set + PName()， 即第一个单词的首字母为改为大写，前面再加上\"get\"或\"set\"前缀。\n\n`2.`对应的getter/setter方法名也可以为：get/set + pName()， 即属性名称不变，第一个单词的首字母任然为小写，前面再加上\"get\"或\"\nset\"前缀。\n\n`3.`对于非常规属性PName， 属性名称的前两个字母都是大写 。即连续两个大写字母开头的属性名。对应的getter/setter方法名为：\nget/set+PName()\n\n`4.`对于非常规属性<Property>或<PropertyName>， 属性名称第一个字母大写 。网上有帖子说这是不符合JSR规范的，会报 \"属性找不到\"\n的错误。\n\n**总结**：\n**1. javabean属性命名尽量使用常规的驼峰式命名规则**\n**2. 属性名第一个单词尽量避免使用一个字母：如eBook， eMail**\n**3. boolean属性名避免使用 “is” 开头的名称**\n**4. 随着jdk， eclipse， spring 等软件版本的不断提高， 底版本的出现的问题可能在高版本中解决了， 低版本原来正常的代码可能在高版本环境下不再支持。\n**\n","slug":"那些年踩过的坑——持续更新中","published":1,"updated":"2024-11-27T03:23:45.191Z","_id":"cm3zaz9cd0020tgu6cvfw2rxs","comments":1,"layout":"post","photos":[],"content":"<p>在java web开发过程中，遇到的各类问题总结，包括java语言，spring，spring mvc，ibatis框架等使用过程中遇到的一些常见的，或者不常见的问题。分条列举，附有问题详情以及解决方案。</p>\n<h3 id=\"1-java定义的boolen数据类型的get，set函数（定义为isEditable）：\"><a href=\"#1-java定义的boolen数据类型的get，set函数（定义为isEditable）：\" class=\"headerlink\" title=\"1.java定义的boolen数据类型的get，set函数（定义为isEditable）：\"></a>1.java定义的boolen数据类型的get，set函数（定义为isEditable）：</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">boolean</span> isEditable;<span class=\"comment\">//是否可以编辑</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isEditable</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> isEditable;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setEditable</span><span class=\"params\">(<span class=\"type\">boolean</span> isEditable)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.isEditable = isEditable;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>现象</strong>：IDEA自动生成的boolean类型与我们的预期有一定的差异，属性isEditable的getter访问器是isEditable(),<br>而不是getIsEditable()；setter访问器是setEditable(),而不是setIsEditable()。</p>\n<p><strong>原因</strong>：由于属性名isEditable的is没有去掉， 以致java bean类违背了java bean 的命名规范。<br><code>JavaBean 的属性名和getter/setter存取方法规则小结：</code></p>\n<blockquote>\n<ul>\n<li>对于常规属性propertyName ，<br>  属性名称的第一个单词小写且字母个数大于1，第二个单词首字母大写。对应的getter&#x2F;setter方法名为：get&#x2F;set + PropertyName()，<br>  即属性名称的第一个单词的首字母改成大写，前面再加上”get”或”set”前缀。</li>\n<li>对于布尔类型propertyName,可以按常规属性的规则编写getter&#x2F;setter方法外， getter方法可以使用 is + PropertyName()的形式来代替。</li>\n<li>对于非常规属性pName，属性名称的第一个单词小写且字母个数等于1，第二个单词首字母大写,分一下三种情况：</li>\n</ul>\n</blockquote>\n<p><code>1.</code>对应的getter&#x2F;setter方法名可以为：get&#x2F;set + PName()， 即第一个单词的首字母为改为大写，前面再加上”get”或”set”前缀。</p>\n<p><code>2.</code>对应的getter&#x2F;setter方法名也可以为：get&#x2F;set + pName()， 即属性名称不变，第一个单词的首字母任然为小写，前面再加上”get”或”<br>set”前缀。</p>\n<p><code>3.</code>对于非常规属性PName， 属性名称的前两个字母都是大写 。即连续两个大写字母开头的属性名。对应的getter&#x2F;setter方法名为：<br>get&#x2F;set+PName()</p>\n<p><code>4.</code>对于非常规属性<Property>或<PropertyName>， 属性名称第一个字母大写 。网上有帖子说这是不符合JSR规范的，会报 “属性找不到”<br>的错误。</p>\n<p><strong>总结</strong>：<br><strong>1. javabean属性命名尽量使用常规的驼峰式命名规则</strong><br><strong>2. 属性名第一个单词尽量避免使用一个字母：如eBook， eMail</strong><br><strong>3. boolean属性名避免使用 “is” 开头的名称</strong><br>**4. 随着jdk， eclipse， spring 等软件版本的不断提高， 底版本的出现的问题可能在高版本中解决了， 低版本原来正常的代码可能在高版本环境下不再支持。<br>**</p>\n","excerpt":"","more":"<p>在java web开发过程中，遇到的各类问题总结，包括java语言，spring，spring mvc，ibatis框架等使用过程中遇到的一些常见的，或者不常见的问题。分条列举，附有问题详情以及解决方案。</p>\n<h3 id=\"1-java定义的boolen数据类型的get，set函数（定义为isEditable）：\"><a href=\"#1-java定义的boolen数据类型的get，set函数（定义为isEditable）：\" class=\"headerlink\" title=\"1.java定义的boolen数据类型的get，set函数（定义为isEditable）：\"></a>1.java定义的boolen数据类型的get，set函数（定义为isEditable）：</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">boolean</span> isEditable;<span class=\"comment\">//是否可以编辑</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isEditable</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> isEditable;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setEditable</span><span class=\"params\">(<span class=\"type\">boolean</span> isEditable)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.isEditable = isEditable;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>现象</strong>：IDEA自动生成的boolean类型与我们的预期有一定的差异，属性isEditable的getter访问器是isEditable(),<br>而不是getIsEditable()；setter访问器是setEditable(),而不是setIsEditable()。</p>\n<p><strong>原因</strong>：由于属性名isEditable的is没有去掉， 以致java bean类违背了java bean 的命名规范。<br><code>JavaBean 的属性名和getter/setter存取方法规则小结：</code></p>\n<blockquote>\n<ul>\n<li>对于常规属性propertyName ，<br>  属性名称的第一个单词小写且字母个数大于1，第二个单词首字母大写。对应的getter&#x2F;setter方法名为：get&#x2F;set + PropertyName()，<br>  即属性名称的第一个单词的首字母改成大写，前面再加上”get”或”set”前缀。</li>\n<li>对于布尔类型propertyName,可以按常规属性的规则编写getter&#x2F;setter方法外， getter方法可以使用 is + PropertyName()的形式来代替。</li>\n<li>对于非常规属性pName，属性名称的第一个单词小写且字母个数等于1，第二个单词首字母大写,分一下三种情况：</li>\n</ul>\n</blockquote>\n<p><code>1.</code>对应的getter&#x2F;setter方法名可以为：get&#x2F;set + PName()， 即第一个单词的首字母为改为大写，前面再加上”get”或”set”前缀。</p>\n<p><code>2.</code>对应的getter&#x2F;setter方法名也可以为：get&#x2F;set + pName()， 即属性名称不变，第一个单词的首字母任然为小写，前面再加上”get”或”<br>set”前缀。</p>\n<p><code>3.</code>对于非常规属性PName， 属性名称的前两个字母都是大写 。即连续两个大写字母开头的属性名。对应的getter&#x2F;setter方法名为：<br>get&#x2F;set+PName()</p>\n<p><code>4.</code>对于非常规属性<Property>或<PropertyName>， 属性名称第一个字母大写 。网上有帖子说这是不符合JSR规范的，会报 “属性找不到”<br>的错误。</p>\n<p><strong>总结</strong>：<br><strong>1. javabean属性命名尽量使用常规的驼峰式命名规则</strong><br><strong>2. 属性名第一个单词尽量避免使用一个字母：如eBook， eMail</strong><br><strong>3. boolean属性名避免使用 “is” 开头的名称</strong><br>**4. 随着jdk， eclipse， spring 等软件版本的不断提高， 底版本的出现的问题可能在高版本中解决了， 低版本原来正常的代码可能在高版本环境下不再支持。<br>**</p>\n"},{"title":"mybatis初步使用","date":"2017-09-15T01:00:00.000Z","_content":"\n## mybatis映射\n\n**`1.resultMap的形式`**\n\n\t<resultMap id=\"userVo\" type=\"com.base.system.entity.UserVo\">\n\t\t<id column=\"uId\" jdbcType=\"BIGINT\" property=\"uId\" />\n\t\t<result column=\"uName\" jdbcType=\"VARCHAR\" property=\"uName\" />\n\t\t<association property=\"addr\" column=\"aId\" javaType=\"com.base.system.entity.Addr\">  \n\t\t\t<id property=\"aId\" column=\"aId\"/>  \n\t\t\t<result property=\"addr\" column=\"addr\"/>  \n\t\t</association>  \n\t\t<collection property=\"roleList\" ofType=\"com.base.system.entity.RoleVo\" column=\"rId\">\n\t\t\t<id column=\"rId\" property=\"rId\" jdbcType=\"BIGINT\" />\n\t\t    <result column=\"rName\" property=\"rName\" jdbcType=\"VARCHAR\" />\n\t\t    <collection property=\"menuList\" ofType=\"com.base.system.entity.MenuVo\" column=\"mId\">\n\t\t    \t<id column=\"mId\" property=\"mId\" jdbcType=\"BIGINT\" />\n\t\t\t    <result column=\"mName\" property=\"mName\" jdbcType=\"VARCHAR\" />\n\t\t \t</collection>\n\t\t</collection>\n\t</resultMap>\n\n\t注意： column=\"aId\"  column=\"rId\"  column=\"mId\" 不写也可以。\n\t\t  association、collection 都有select属性可以此时设置懒加载才有意义。\n\n**`2.foreach常用的形式`**\n\n\t<insert id=\"insertbatch\" >\n\t    insert into t_role_menu (role_id, menu_id) VALUES\n\t \t<foreach collection=\"menuIds\" item=\"menuId\" open=\"\" close=\"\" separator=\",\">  \n\t    \t(#{roleId,jdbcType=BIGINT}, #{menuId,jdbcType=BIGINT})\n\t\t</foreach>\n\t</insert>\n\t\n\t<delete id=\"deleteRole\">\n\t    DELETE FROM t_role_menu WHERE role_id IN \n\t    <foreach collection=\"roleIds\" item=\"roleId\" open=\"(\" close=\")\" separator=\",\">  \n\t    \t#{roleId,jdbcType=BIGINT}\n\t\t</foreach>\n\t</delete>\n\n**`3.调用存储过程`**\n\n\t<select id=\"ckm\" resultMap=\"BaseResultMap\" statementType=\"CALLABLE\">\n\t\t{CALL ckm(#{time,mode=IN,jdbcType=INTEGER}) }\n\t</select>\n\n**`4.使用注意事项`**\n\n1. 若单个参数不为 map 需要在标签 parameterType 声明参数类型。\n2. 多个参数必须使用 map 或 参数注解。\n\n#### mybatis常用标签\n\n###### 1、trim 去掉 指定位置的字符\n\n    <delete>\n        DELETE FROM xx WHERE\n        <trim prefixOverrides=\"AND | OR\">\n            <if test=\"id != null\" > AND xx.id = #{id} </if>\n            <if test=\"name != null\" > AND xx.name = #{name} </if>\n        </trim>\n    </delete>\n\n###### 2、set 会去掉最后一个,\n\n    <update>\n          UPDATE xxx A\n          <set>\n              <if test=\"nums != null\"> A.NUMS = #{nums}, </if>\n              <if test=\"state != null\"> A.STATE = #{state}, </if>\n          </set>\n          WHERE A.id = #{id}\n          <if test=\"sid != null\"> AND A.SID = #{sid}</if>\n    </update>\n\n###### 3、where 会去掉第一个and或or组成正确的where语句\n\n    <select>\n        SELECT * FROM xx A\n        <where>\n            <if test=\"sid != null\"> AND A.ID = #{sid}</if>\n            <if test=\"bid != null\"> AND A.BID = #{bid}</if>\n            <if test=\"state != null\"> AND A.STATE = #{state}</if>\n        </where>\n        ORDER BY A.SORT ASC, A.AA02 DESC\n    </select>\n\n###### 4、foreach  循环遍历集合数组通常用于in ids集合、item迭代项\n\n      <update >\n        update xx set STATE = #{state} where ID in \n        <foreach item=\"item\" index=\"index\" collection=\"ids\" open=\"(\" separator=\",\" close=\")\">  \n    \t    #{item}  \n    \t</foreach> \n      </update>\n\n###### 5、choose when otherwise 相当于if.. else..\n\n    <select>\n        <choose>\n            <when test=\"state != 1\">\n                SELECT * from t\n            </when>\n            <otherwise>\n                SELECT * from t2\n            </otherwise>\n        </choose>\n    </select>\n\n###### 6、if  判断，true则进入\n\n    <if test=\"aId != null and aId != ''\">\n        AND a.ID = #{aId}\n    </if>\n    <if test=\"aId=='2'.toString()\">..</if> 或 <if test='aId==\"2\"'>..</if>\n    总之 test里面的判断字符串相等时需要使用双引号\"\",如果使用单引号就加.toString()\n\n###### 7、CDATA  转义块里的特殊字符\n\n      <![CDATA[ code ]]>\n\n###### 8、resultMap中collection连接查询结果集处理.不需要可以处理关系只要column不重复。collection中包含所有‘多’关系即可\n\n\t<resultMap type=\"XXX\" id=\"parentMap\">\n\t\t  <result column=\"NAME\" property=\"name\" />\n\t\t  <result column=\"TYPE\" property=\"type\" />\n\t\t  <result column=\"LOGINNAME\" property=\"loginname\" />\n\t\t  <collection property=\"xxxList\" ofType=\"xx\" >\n\t\t\t  <result column=\"TYPENAME1\" property=\"typename1\" />\n\t\t\t  <result column=\"TYPENAME2\" property=\"typename2\" />\n\t\t\t  <result column=\"TYPENAME3\" property=\"typename3\" />\n\t\t  </collection>\n\t</resultMap>\n\t]()","source":"_posts/mybatis初步使用.md","raw":"---\ntitle: mybatis初步使用\ndate: 2017-09-15 09:00:00\ncategories: Mybatis\ntags:\n  - mybatis \n---\n\n## mybatis映射\n\n**`1.resultMap的形式`**\n\n\t<resultMap id=\"userVo\" type=\"com.base.system.entity.UserVo\">\n\t\t<id column=\"uId\" jdbcType=\"BIGINT\" property=\"uId\" />\n\t\t<result column=\"uName\" jdbcType=\"VARCHAR\" property=\"uName\" />\n\t\t<association property=\"addr\" column=\"aId\" javaType=\"com.base.system.entity.Addr\">  \n\t\t\t<id property=\"aId\" column=\"aId\"/>  \n\t\t\t<result property=\"addr\" column=\"addr\"/>  \n\t\t</association>  \n\t\t<collection property=\"roleList\" ofType=\"com.base.system.entity.RoleVo\" column=\"rId\">\n\t\t\t<id column=\"rId\" property=\"rId\" jdbcType=\"BIGINT\" />\n\t\t    <result column=\"rName\" property=\"rName\" jdbcType=\"VARCHAR\" />\n\t\t    <collection property=\"menuList\" ofType=\"com.base.system.entity.MenuVo\" column=\"mId\">\n\t\t    \t<id column=\"mId\" property=\"mId\" jdbcType=\"BIGINT\" />\n\t\t\t    <result column=\"mName\" property=\"mName\" jdbcType=\"VARCHAR\" />\n\t\t \t</collection>\n\t\t</collection>\n\t</resultMap>\n\n\t注意： column=\"aId\"  column=\"rId\"  column=\"mId\" 不写也可以。\n\t\t  association、collection 都有select属性可以此时设置懒加载才有意义。\n\n**`2.foreach常用的形式`**\n\n\t<insert id=\"insertbatch\" >\n\t    insert into t_role_menu (role_id, menu_id) VALUES\n\t \t<foreach collection=\"menuIds\" item=\"menuId\" open=\"\" close=\"\" separator=\",\">  \n\t    \t(#{roleId,jdbcType=BIGINT}, #{menuId,jdbcType=BIGINT})\n\t\t</foreach>\n\t</insert>\n\t\n\t<delete id=\"deleteRole\">\n\t    DELETE FROM t_role_menu WHERE role_id IN \n\t    <foreach collection=\"roleIds\" item=\"roleId\" open=\"(\" close=\")\" separator=\",\">  \n\t    \t#{roleId,jdbcType=BIGINT}\n\t\t</foreach>\n\t</delete>\n\n**`3.调用存储过程`**\n\n\t<select id=\"ckm\" resultMap=\"BaseResultMap\" statementType=\"CALLABLE\">\n\t\t{CALL ckm(#{time,mode=IN,jdbcType=INTEGER}) }\n\t</select>\n\n**`4.使用注意事项`**\n\n1. 若单个参数不为 map 需要在标签 parameterType 声明参数类型。\n2. 多个参数必须使用 map 或 参数注解。\n\n#### mybatis常用标签\n\n###### 1、trim 去掉 指定位置的字符\n\n    <delete>\n        DELETE FROM xx WHERE\n        <trim prefixOverrides=\"AND | OR\">\n            <if test=\"id != null\" > AND xx.id = #{id} </if>\n            <if test=\"name != null\" > AND xx.name = #{name} </if>\n        </trim>\n    </delete>\n\n###### 2、set 会去掉最后一个,\n\n    <update>\n          UPDATE xxx A\n          <set>\n              <if test=\"nums != null\"> A.NUMS = #{nums}, </if>\n              <if test=\"state != null\"> A.STATE = #{state}, </if>\n          </set>\n          WHERE A.id = #{id}\n          <if test=\"sid != null\"> AND A.SID = #{sid}</if>\n    </update>\n\n###### 3、where 会去掉第一个and或or组成正确的where语句\n\n    <select>\n        SELECT * FROM xx A\n        <where>\n            <if test=\"sid != null\"> AND A.ID = #{sid}</if>\n            <if test=\"bid != null\"> AND A.BID = #{bid}</if>\n            <if test=\"state != null\"> AND A.STATE = #{state}</if>\n        </where>\n        ORDER BY A.SORT ASC, A.AA02 DESC\n    </select>\n\n###### 4、foreach  循环遍历集合数组通常用于in ids集合、item迭代项\n\n      <update >\n        update xx set STATE = #{state} where ID in \n        <foreach item=\"item\" index=\"index\" collection=\"ids\" open=\"(\" separator=\",\" close=\")\">  \n    \t    #{item}  \n    \t</foreach> \n      </update>\n\n###### 5、choose when otherwise 相当于if.. else..\n\n    <select>\n        <choose>\n            <when test=\"state != 1\">\n                SELECT * from t\n            </when>\n            <otherwise>\n                SELECT * from t2\n            </otherwise>\n        </choose>\n    </select>\n\n###### 6、if  判断，true则进入\n\n    <if test=\"aId != null and aId != ''\">\n        AND a.ID = #{aId}\n    </if>\n    <if test=\"aId=='2'.toString()\">..</if> 或 <if test='aId==\"2\"'>..</if>\n    总之 test里面的判断字符串相等时需要使用双引号\"\",如果使用单引号就加.toString()\n\n###### 7、CDATA  转义块里的特殊字符\n\n      <![CDATA[ code ]]>\n\n###### 8、resultMap中collection连接查询结果集处理.不需要可以处理关系只要column不重复。collection中包含所有‘多’关系即可\n\n\t<resultMap type=\"XXX\" id=\"parentMap\">\n\t\t  <result column=\"NAME\" property=\"name\" />\n\t\t  <result column=\"TYPE\" property=\"type\" />\n\t\t  <result column=\"LOGINNAME\" property=\"loginname\" />\n\t\t  <collection property=\"xxxList\" ofType=\"xx\" >\n\t\t\t  <result column=\"TYPENAME1\" property=\"typename1\" />\n\t\t\t  <result column=\"TYPENAME2\" property=\"typename2\" />\n\t\t\t  <result column=\"TYPENAME3\" property=\"typename3\" />\n\t\t  </collection>\n\t</resultMap>\n\t]()","slug":"mybatis初步使用","published":1,"updated":"2024-11-27T03:20:35.272Z","_id":"cm3zb0p5u0000kku675p1155d","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"mybatis映射\"><a href=\"#mybatis映射\" class=\"headerlink\" title=\"mybatis映射\"></a>mybatis映射</h2><p><strong><code>1.resultMap的形式</code></strong></p>\n<pre><code>&lt;resultMap id=&quot;userVo&quot; type=&quot;com.base.system.entity.UserVo&quot;&gt;\n    &lt;id column=&quot;uId&quot; jdbcType=&quot;BIGINT&quot; property=&quot;uId&quot; /&gt;\n    &lt;result column=&quot;uName&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;uName&quot; /&gt;\n    &lt;association property=&quot;addr&quot; column=&quot;aId&quot; javaType=&quot;com.base.system.entity.Addr&quot;&gt;  \n        &lt;id property=&quot;aId&quot; column=&quot;aId&quot;/&gt;  \n        &lt;result property=&quot;addr&quot; column=&quot;addr&quot;/&gt;  \n    &lt;/association&gt;  \n    &lt;collection property=&quot;roleList&quot; ofType=&quot;com.base.system.entity.RoleVo&quot; column=&quot;rId&quot;&gt;\n        &lt;id column=&quot;rId&quot; property=&quot;rId&quot; jdbcType=&quot;BIGINT&quot; /&gt;\n        &lt;result column=&quot;rName&quot; property=&quot;rName&quot; jdbcType=&quot;VARCHAR&quot; /&gt;\n        &lt;collection property=&quot;menuList&quot; ofType=&quot;com.base.system.entity.MenuVo&quot; column=&quot;mId&quot;&gt;\n        \t&lt;id column=&quot;mId&quot; property=&quot;mId&quot; jdbcType=&quot;BIGINT&quot; /&gt;\n            &lt;result column=&quot;mName&quot; property=&quot;mName&quot; jdbcType=&quot;VARCHAR&quot; /&gt;\n     \t&lt;/collection&gt;\n    &lt;/collection&gt;\n&lt;/resultMap&gt;\n\n注意： column=&quot;aId&quot;  column=&quot;rId&quot;  column=&quot;mId&quot; 不写也可以。\n      association、collection 都有select属性可以此时设置懒加载才有意义。\n</code></pre>\n<p><strong><code>2.foreach常用的形式</code></strong></p>\n<pre><code>&lt;insert id=&quot;insertbatch&quot; &gt;\n    insert into t_role_menu (role_id, menu_id) VALUES\n \t&lt;foreach collection=&quot;menuIds&quot; item=&quot;menuId&quot; open=&quot;&quot; close=&quot;&quot; separator=&quot;,&quot;&gt;  \n    \t(#&#123;roleId,jdbcType=BIGINT&#125;, #&#123;menuId,jdbcType=BIGINT&#125;)\n    &lt;/foreach&gt;\n&lt;/insert&gt;\n\n&lt;delete id=&quot;deleteRole&quot;&gt;\n    DELETE FROM t_role_menu WHERE role_id IN \n    &lt;foreach collection=&quot;roleIds&quot; item=&quot;roleId&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt;  \n    \t#&#123;roleId,jdbcType=BIGINT&#125;\n    &lt;/foreach&gt;\n&lt;/delete&gt;\n</code></pre>\n<p><strong><code>3.调用存储过程</code></strong></p>\n<pre><code>&lt;select id=&quot;ckm&quot; resultMap=&quot;BaseResultMap&quot; statementType=&quot;CALLABLE&quot;&gt;\n    &#123;CALL ckm(#&#123;time,mode=IN,jdbcType=INTEGER&#125;) &#125;\n&lt;/select&gt;\n</code></pre>\n<p><strong><code>4.使用注意事项</code></strong></p>\n<ol>\n<li>若单个参数不为 map 需要在标签 parameterType 声明参数类型。</li>\n<li>多个参数必须使用 map 或 参数注解。</li>\n</ol>\n<h4 id=\"mybatis常用标签\"><a href=\"#mybatis常用标签\" class=\"headerlink\" title=\"mybatis常用标签\"></a>mybatis常用标签</h4><h6 id=\"1、trim-去掉-指定位置的字符\"><a href=\"#1、trim-去掉-指定位置的字符\" class=\"headerlink\" title=\"1、trim 去掉 指定位置的字符\"></a>1、trim 去掉 指定位置的字符</h6><pre><code>&lt;delete&gt;\n    DELETE FROM xx WHERE\n    &lt;trim prefixOverrides=&quot;AND | OR&quot;&gt;\n        &lt;if test=&quot;id != null&quot; &gt; AND xx.id = #&#123;id&#125; &lt;/if&gt;\n        &lt;if test=&quot;name != null&quot; &gt; AND xx.name = #&#123;name&#125; &lt;/if&gt;\n    &lt;/trim&gt;\n&lt;/delete&gt;\n</code></pre>\n<h6 id=\"2、set-会去掉最后一个\"><a href=\"#2、set-会去掉最后一个\" class=\"headerlink\" title=\"2、set 会去掉最后一个,\"></a>2、set 会去掉最后一个,</h6><pre><code>&lt;update&gt;\n      UPDATE xxx A\n      &lt;set&gt;\n          &lt;if test=&quot;nums != null&quot;&gt; A.NUMS = #&#123;nums&#125;, &lt;/if&gt;\n          &lt;if test=&quot;state != null&quot;&gt; A.STATE = #&#123;state&#125;, &lt;/if&gt;\n      &lt;/set&gt;\n      WHERE A.id = #&#123;id&#125;\n      &lt;if test=&quot;sid != null&quot;&gt; AND A.SID = #&#123;sid&#125;&lt;/if&gt;\n&lt;/update&gt;\n</code></pre>\n<h6 id=\"3、where-会去掉第一个and或or组成正确的where语句\"><a href=\"#3、where-会去掉第一个and或or组成正确的where语句\" class=\"headerlink\" title=\"3、where 会去掉第一个and或or组成正确的where语句\"></a>3、where 会去掉第一个and或or组成正确的where语句</h6><pre><code>&lt;select&gt;\n    SELECT * FROM xx A\n    &lt;where&gt;\n        &lt;if test=&quot;sid != null&quot;&gt; AND A.ID = #&#123;sid&#125;&lt;/if&gt;\n        &lt;if test=&quot;bid != null&quot;&gt; AND A.BID = #&#123;bid&#125;&lt;/if&gt;\n        &lt;if test=&quot;state != null&quot;&gt; AND A.STATE = #&#123;state&#125;&lt;/if&gt;\n    &lt;/where&gt;\n    ORDER BY A.SORT ASC, A.AA02 DESC\n&lt;/select&gt;\n</code></pre>\n<h6 id=\"4、foreach-循环遍历集合数组通常用于in-ids集合、item迭代项\"><a href=\"#4、foreach-循环遍历集合数组通常用于in-ids集合、item迭代项\" class=\"headerlink\" title=\"4、foreach  循环遍历集合数组通常用于in ids集合、item迭代项\"></a>4、foreach  循环遍历集合数组通常用于in ids集合、item迭代项</h6><pre><code>  &lt;update &gt;\n    update xx set STATE = #&#123;state&#125; where ID in \n    &lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;ids&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;  \n        #&#123;item&#125;  \n    &lt;/foreach&gt; \n  &lt;/update&gt;\n</code></pre>\n<h6 id=\"5、choose-when-otherwise-相当于if-else\"><a href=\"#5、choose-when-otherwise-相当于if-else\" class=\"headerlink\" title=\"5、choose when otherwise 相当于if.. else..\"></a>5、choose when otherwise 相当于if.. else..</h6><pre><code>&lt;select&gt;\n    &lt;choose&gt;\n        &lt;when test=&quot;state != 1&quot;&gt;\n            SELECT * from t\n        &lt;/when&gt;\n        &lt;otherwise&gt;\n            SELECT * from t2\n        &lt;/otherwise&gt;\n    &lt;/choose&gt;\n&lt;/select&gt;\n</code></pre>\n<h6 id=\"6、if-判断，true则进入\"><a href=\"#6、if-判断，true则进入\" class=\"headerlink\" title=\"6、if  判断，true则进入\"></a>6、if  判断，true则进入</h6><pre><code>&lt;if test=&quot;aId != null and aId != &#39;&#39;&quot;&gt;\n    AND a.ID = #&#123;aId&#125;\n&lt;/if&gt;\n&lt;if test=&quot;aId==&#39;2&#39;.toString()&quot;&gt;..&lt;/if&gt; 或 &lt;if test=&#39;aId==&quot;2&quot;&#39;&gt;..&lt;/if&gt;\n总之 test里面的判断字符串相等时需要使用双引号&quot;&quot;,如果使用单引号就加.toString()\n</code></pre>\n<h6 id=\"7、CDATA-转义块里的特殊字符\"><a href=\"#7、CDATA-转义块里的特殊字符\" class=\"headerlink\" title=\"7、CDATA  转义块里的特殊字符\"></a>7、CDATA  转义块里的特殊字符</h6><pre><code>  &lt;![CDATA[ code ]]&gt;\n</code></pre>\n<h6 id=\"8、resultMap中collection连接查询结果集处理-不需要可以处理关系只要column不重复。collection中包含所有‘多’关系即可\"><a href=\"#8、resultMap中collection连接查询结果集处理-不需要可以处理关系只要column不重复。collection中包含所有‘多’关系即可\" class=\"headerlink\" title=\"8、resultMap中collection连接查询结果集处理.不需要可以处理关系只要column不重复。collection中包含所有‘多’关系即可\"></a>8、resultMap中collection连接查询结果集处理.不需要可以处理关系只要column不重复。collection中包含所有‘多’关系即可</h6><pre><code>&lt;resultMap type=&quot;XXX&quot; id=&quot;parentMap&quot;&gt;\n      &lt;result column=&quot;NAME&quot; property=&quot;name&quot; /&gt;\n      &lt;result column=&quot;TYPE&quot; property=&quot;type&quot; /&gt;\n      &lt;result column=&quot;LOGINNAME&quot; property=&quot;loginname&quot; /&gt;\n      &lt;collection property=&quot;xxxList&quot; ofType=&quot;xx&quot; &gt;\n          &lt;result column=&quot;TYPENAME1&quot; property=&quot;typename1&quot; /&gt;\n          &lt;result column=&quot;TYPENAME2&quot; property=&quot;typename2&quot; /&gt;\n          &lt;result column=&quot;TYPENAME3&quot; property=&quot;typename3&quot; /&gt;\n      &lt;/collection&gt;\n&lt;/resultMap&gt;\n]()\n</code></pre>\n","excerpt":"","more":"<h2 id=\"mybatis映射\"><a href=\"#mybatis映射\" class=\"headerlink\" title=\"mybatis映射\"></a>mybatis映射</h2><p><strong><code>1.resultMap的形式</code></strong></p>\n<pre><code>&lt;resultMap id=&quot;userVo&quot; type=&quot;com.base.system.entity.UserVo&quot;&gt;\n    &lt;id column=&quot;uId&quot; jdbcType=&quot;BIGINT&quot; property=&quot;uId&quot; /&gt;\n    &lt;result column=&quot;uName&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;uName&quot; /&gt;\n    &lt;association property=&quot;addr&quot; column=&quot;aId&quot; javaType=&quot;com.base.system.entity.Addr&quot;&gt;  \n        &lt;id property=&quot;aId&quot; column=&quot;aId&quot;/&gt;  \n        &lt;result property=&quot;addr&quot; column=&quot;addr&quot;/&gt;  \n    &lt;/association&gt;  \n    &lt;collection property=&quot;roleList&quot; ofType=&quot;com.base.system.entity.RoleVo&quot; column=&quot;rId&quot;&gt;\n        &lt;id column=&quot;rId&quot; property=&quot;rId&quot; jdbcType=&quot;BIGINT&quot; /&gt;\n        &lt;result column=&quot;rName&quot; property=&quot;rName&quot; jdbcType=&quot;VARCHAR&quot; /&gt;\n        &lt;collection property=&quot;menuList&quot; ofType=&quot;com.base.system.entity.MenuVo&quot; column=&quot;mId&quot;&gt;\n        \t&lt;id column=&quot;mId&quot; property=&quot;mId&quot; jdbcType=&quot;BIGINT&quot; /&gt;\n            &lt;result column=&quot;mName&quot; property=&quot;mName&quot; jdbcType=&quot;VARCHAR&quot; /&gt;\n     \t&lt;/collection&gt;\n    &lt;/collection&gt;\n&lt;/resultMap&gt;\n\n注意： column=&quot;aId&quot;  column=&quot;rId&quot;  column=&quot;mId&quot; 不写也可以。\n      association、collection 都有select属性可以此时设置懒加载才有意义。\n</code></pre>\n<p><strong><code>2.foreach常用的形式</code></strong></p>\n<pre><code>&lt;insert id=&quot;insertbatch&quot; &gt;\n    insert into t_role_menu (role_id, menu_id) VALUES\n \t&lt;foreach collection=&quot;menuIds&quot; item=&quot;menuId&quot; open=&quot;&quot; close=&quot;&quot; separator=&quot;,&quot;&gt;  \n    \t(#&#123;roleId,jdbcType=BIGINT&#125;, #&#123;menuId,jdbcType=BIGINT&#125;)\n    &lt;/foreach&gt;\n&lt;/insert&gt;\n\n&lt;delete id=&quot;deleteRole&quot;&gt;\n    DELETE FROM t_role_menu WHERE role_id IN \n    &lt;foreach collection=&quot;roleIds&quot; item=&quot;roleId&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt;  \n    \t#&#123;roleId,jdbcType=BIGINT&#125;\n    &lt;/foreach&gt;\n&lt;/delete&gt;\n</code></pre>\n<p><strong><code>3.调用存储过程</code></strong></p>\n<pre><code>&lt;select id=&quot;ckm&quot; resultMap=&quot;BaseResultMap&quot; statementType=&quot;CALLABLE&quot;&gt;\n    &#123;CALL ckm(#&#123;time,mode=IN,jdbcType=INTEGER&#125;) &#125;\n&lt;/select&gt;\n</code></pre>\n<p><strong><code>4.使用注意事项</code></strong></p>\n<ol>\n<li>若单个参数不为 map 需要在标签 parameterType 声明参数类型。</li>\n<li>多个参数必须使用 map 或 参数注解。</li>\n</ol>\n<h4 id=\"mybatis常用标签\"><a href=\"#mybatis常用标签\" class=\"headerlink\" title=\"mybatis常用标签\"></a>mybatis常用标签</h4><h6 id=\"1、trim-去掉-指定位置的字符\"><a href=\"#1、trim-去掉-指定位置的字符\" class=\"headerlink\" title=\"1、trim 去掉 指定位置的字符\"></a>1、trim 去掉 指定位置的字符</h6><pre><code>&lt;delete&gt;\n    DELETE FROM xx WHERE\n    &lt;trim prefixOverrides=&quot;AND | OR&quot;&gt;\n        &lt;if test=&quot;id != null&quot; &gt; AND xx.id = #&#123;id&#125; &lt;/if&gt;\n        &lt;if test=&quot;name != null&quot; &gt; AND xx.name = #&#123;name&#125; &lt;/if&gt;\n    &lt;/trim&gt;\n&lt;/delete&gt;\n</code></pre>\n<h6 id=\"2、set-会去掉最后一个\"><a href=\"#2、set-会去掉最后一个\" class=\"headerlink\" title=\"2、set 会去掉最后一个,\"></a>2、set 会去掉最后一个,</h6><pre><code>&lt;update&gt;\n      UPDATE xxx A\n      &lt;set&gt;\n          &lt;if test=&quot;nums != null&quot;&gt; A.NUMS = #&#123;nums&#125;, &lt;/if&gt;\n          &lt;if test=&quot;state != null&quot;&gt; A.STATE = #&#123;state&#125;, &lt;/if&gt;\n      &lt;/set&gt;\n      WHERE A.id = #&#123;id&#125;\n      &lt;if test=&quot;sid != null&quot;&gt; AND A.SID = #&#123;sid&#125;&lt;/if&gt;\n&lt;/update&gt;\n</code></pre>\n<h6 id=\"3、where-会去掉第一个and或or组成正确的where语句\"><a href=\"#3、where-会去掉第一个and或or组成正确的where语句\" class=\"headerlink\" title=\"3、where 会去掉第一个and或or组成正确的where语句\"></a>3、where 会去掉第一个and或or组成正确的where语句</h6><pre><code>&lt;select&gt;\n    SELECT * FROM xx A\n    &lt;where&gt;\n        &lt;if test=&quot;sid != null&quot;&gt; AND A.ID = #&#123;sid&#125;&lt;/if&gt;\n        &lt;if test=&quot;bid != null&quot;&gt; AND A.BID = #&#123;bid&#125;&lt;/if&gt;\n        &lt;if test=&quot;state != null&quot;&gt; AND A.STATE = #&#123;state&#125;&lt;/if&gt;\n    &lt;/where&gt;\n    ORDER BY A.SORT ASC, A.AA02 DESC\n&lt;/select&gt;\n</code></pre>\n<h6 id=\"4、foreach-循环遍历集合数组通常用于in-ids集合、item迭代项\"><a href=\"#4、foreach-循环遍历集合数组通常用于in-ids集合、item迭代项\" class=\"headerlink\" title=\"4、foreach  循环遍历集合数组通常用于in ids集合、item迭代项\"></a>4、foreach  循环遍历集合数组通常用于in ids集合、item迭代项</h6><pre><code>  &lt;update &gt;\n    update xx set STATE = #&#123;state&#125; where ID in \n    &lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;ids&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;  \n        #&#123;item&#125;  \n    &lt;/foreach&gt; \n  &lt;/update&gt;\n</code></pre>\n<h6 id=\"5、choose-when-otherwise-相当于if-else\"><a href=\"#5、choose-when-otherwise-相当于if-else\" class=\"headerlink\" title=\"5、choose when otherwise 相当于if.. else..\"></a>5、choose when otherwise 相当于if.. else..</h6><pre><code>&lt;select&gt;\n    &lt;choose&gt;\n        &lt;when test=&quot;state != 1&quot;&gt;\n            SELECT * from t\n        &lt;/when&gt;\n        &lt;otherwise&gt;\n            SELECT * from t2\n        &lt;/otherwise&gt;\n    &lt;/choose&gt;\n&lt;/select&gt;\n</code></pre>\n<h6 id=\"6、if-判断，true则进入\"><a href=\"#6、if-判断，true则进入\" class=\"headerlink\" title=\"6、if  判断，true则进入\"></a>6、if  判断，true则进入</h6><pre><code>&lt;if test=&quot;aId != null and aId != &#39;&#39;&quot;&gt;\n    AND a.ID = #&#123;aId&#125;\n&lt;/if&gt;\n&lt;if test=&quot;aId==&#39;2&#39;.toString()&quot;&gt;..&lt;/if&gt; 或 &lt;if test=&#39;aId==&quot;2&quot;&#39;&gt;..&lt;/if&gt;\n总之 test里面的判断字符串相等时需要使用双引号&quot;&quot;,如果使用单引号就加.toString()\n</code></pre>\n<h6 id=\"7、CDATA-转义块里的特殊字符\"><a href=\"#7、CDATA-转义块里的特殊字符\" class=\"headerlink\" title=\"7、CDATA  转义块里的特殊字符\"></a>7、CDATA  转义块里的特殊字符</h6><pre><code>  &lt;![CDATA[ code ]]&gt;\n</code></pre>\n<h6 id=\"8、resultMap中collection连接查询结果集处理-不需要可以处理关系只要column不重复。collection中包含所有‘多’关系即可\"><a href=\"#8、resultMap中collection连接查询结果集处理-不需要可以处理关系只要column不重复。collection中包含所有‘多’关系即可\" class=\"headerlink\" title=\"8、resultMap中collection连接查询结果集处理.不需要可以处理关系只要column不重复。collection中包含所有‘多’关系即可\"></a>8、resultMap中collection连接查询结果集处理.不需要可以处理关系只要column不重复。collection中包含所有‘多’关系即可</h6><pre><code>&lt;resultMap type=&quot;XXX&quot; id=&quot;parentMap&quot;&gt;\n      &lt;result column=&quot;NAME&quot; property=&quot;name&quot; /&gt;\n      &lt;result column=&quot;TYPE&quot; property=&quot;type&quot; /&gt;\n      &lt;result column=&quot;LOGINNAME&quot; property=&quot;loginname&quot; /&gt;\n      &lt;collection property=&quot;xxxList&quot; ofType=&quot;xx&quot; &gt;\n          &lt;result column=&quot;TYPENAME1&quot; property=&quot;typename1&quot; /&gt;\n          &lt;result column=&quot;TYPENAME2&quot; property=&quot;typename2&quot; /&gt;\n          &lt;result column=&quot;TYPENAME3&quot; property=&quot;typename3&quot; /&gt;\n      &lt;/collection&gt;\n&lt;/resultMap&gt;\n]()\n</code></pre>\n"},{"title":"AOP初步学习","excerpt":"AOP是一种编程范式，不是编程语言，解决特定的问题。（解决代码重复问题 、关注点分离）。","date":"2017-09-13T01:00:00.000Z","_content":"\n## AOP\n\n**`1.什么是AOP`**\n\n1. AOP是一种编程范式，不是编程语言，解决特定的问题。（解决代码重复问题 、关注点分离）\n2. 面向切面编程（AOP是Aspect Oriented Program的首字母缩写）将应用程序切分成一个个关注点，让每一个关注点成为\n   独立的，也只做一件事情，尽量不让关注点之间产生耦合。\n   AOP其实只是OOP的补充而已。OOP从横向上区分出一个个的类来，而AOP则从纵向上向对象中加入特定的代码。有了AOP，OOP变得立体了。如果加上时间维度，AOP使OOP由原来的二维变为三维了，由平面变成立体了。从技术上来说，AOP基本上是通过代理机制实现的。\n   这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。\n3. AOP技术它利用一种称为\"横切\"\n   的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为\"Aspect\"，即切面。所谓\"切面\"\n   ，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。使用\"\n   横切\"\n   技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。\n\n**`2.基本概念`**\n\n1. 切面（Aspect）：对横切性关注点的模块化，其实就是共有功能的实现。如日志切面、权限切面等。\n2. 连接点（JoinPoint）：就是程序在运行过程中能够插入切面的地点。例如，方法调用、异常抛出或字段修改等，但Spring只支持方法级的连接点。\n3. 通知（Advice）：在切面的某个特定的连接点（Joinpoint）上执行的动作。通知有各种类型。\n4. 切入点（Pointcut）：用于定义通知（Advice）应该切入到哪些连接点(JoinPoint)上。不同的通知通常需要切入到不同的连接点上，这种精准的匹配是由切入点的正则表达式来定义的。\n5. 目标对象（Target）：就是那些即将切入切面的对象，也就是那些被通知的对象。\n6. 代理对象（Proxy）：将通知应用到目标对象之后被动态创建的对象\n7. 织入（Weaving）：将切面应用到目标对象从而创建一个新的代理对象的过程。\n\n## spring AOP的使用\n\n**`xml配置`**\n\n    <bean id=\"advice\" class=\"test.Advice\" />  \n    <aop:config>  \n        <aop:aspect id=\"aspect\" ref=\"advice\">  \n            <aop:pointcut id=\"service\" expression=\"execution(* com.demo.aop.*.find*(..))\"/>  \n            <aop:before method=\"doBefore\"  pointcut-ref=\"service\"/>  \n            <aop:after method=\"doAfter\"  pointcut-ref=\"service\"/>  \n            <aop:around method=\"doAround\"  pointcut-ref=\"service\"/>  \n            <aop:after-returning method=\"doReturn\"  pointcut-ref=\"service\"/>  \n            <aop:after-throwing method=\"doThrowing\" throwing=\"ex\" pointcut-ref=\"service\"/>  \n              \n        </aop:aspect>  \n    </aop:config>\n\n\tpackage test;   \n\timport org.aspectj.lang.JoinPoint;  \n\timport org.aspectj.lang.ProceedingJoinPoint;  \n\tpublic class Advice {  \n\t    private void doBefore(JoinPoint joinPoint) {  \n\t       \n\t    }  \n\t    private Object doAround(ProceedingJoinPoint pjp) throws Throwable {  \n\t        Object retVal = pjp.proceed();  \n\t        return retVal;  \n\t    }  \n\t    private void doAfter(JoinPoint joinPoint) {  \n\t       \n\t    }  \n\t    private void doReturn(JoinPoint joinPoint) {  \n\t       \n\t    }  \n\t    private void doThrowing(JoinPoint joinPoint,Throwable ex) {  \n\t        \n\t    }  \n\t} \n\n\n\t<bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n\t\t<property name=\"dataSource\" ref=\"dataSource\" />\n\t</bean>\n\t<tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\">\n\t\t<tx:attributes>\n\t\t\t<tx:method name=\"save*\" propagation=\"REQUIRED\" />\n\t\t\t<tx:method name=\"insert*\" propagation=\"REQUIRED\" />\n\t\t\t<tx:method name=\"add*\" propagation=\"REQUIRED\" />\n\t\t\t<tx:method name=\"create*\" propagation=\"REQUIRED\" />\n\t\t\t<tx:method name=\"delete*\" propagation=\"REQUIRED\" />\n\t\t\t<tx:method name=\"update*\" propagation=\"REQUIRED\" />\n\t\t\t<tx:method name=\"find*\" propagation=\"SUPPORTS\" read-only=\"true\" />\n\t\t\t<tx:method name=\"select*\" propagation=\"SUPPORTS\" read-only=\"true\" />\n\t\t\t<tx:method name=\"get*\" propagation=\"SUPPORTS\" read-only=\"true\" />\n\t\t</tx:attributes>\n\t</tx:advice>\n \n\t<aop:config>\n\t\t<aop:advisor advice-ref=\"txAdvice\" pointcut=\"execution(* com.*.*.service.*.*(..))\" />\n\t</aop:config>\n\n**`注解配置`**\n\n\t<aop:aspectj-autoproxy/>\n\t\n\t@Aspect\n\t@Component\n\tpublic class MyAspect{\n\t\t\n\t\t@Pointcut(\"execution(* com.*.*.service.*.*(..))\")  \n\t\tprivate void piont(){ }\n\t\t \n\t\t@Before(\"piont()\")\n\t\tpublic void beforeTest(){\n\t\t\tSystem.out.println(\"beforeTest.................\");\n\t\t}\n\t\n\t}\n\n\texecution：用于匹配方法执行的连接点；\n\twithin：用于匹配指定类型内的方法执行；\n\tthis：用于匹配当前AOP代理对象类型的执行方法；注意是AOP代理对象的类型匹配，这样就可能包括引入接口也类型匹配；\n\ttarget：用于匹配当前目标对象类型的执行方法；注意是目标对象的类型匹配，这样就不包括引入接口也类型匹配；\n\targs：用于匹配当前执行的方法传入的参数为指定类型的执行方法；\n\t@within：用于匹配所以持有指定注解类型内的方法；\n\t@target：用于匹配当前目标对象类型的执行方法，其中目标对象持有指定的注解；\n\t@args：用于匹配当前执行的方法传入的参数持有指定注解的执行；\n\t@annotation：用于匹配当前执行方法持有指定注解的方法；\n\tbean：Spring AOP扩展的，AspectJ没有对于指示符，用于匹配特定名称的Bean对象的执行方法；\n\treference pointcut：表示引用其他命名切入点，只有@ApectJ风格支持，Schema风格不支持。","source":"_posts/AOP初步学习.md","raw":"---\ntitle: AOP初步学习\nexcerpt: AOP是一种编程范式，不是编程语言，解决特定的问题。（解决代码重复问题 、关注点分离）。\ndate: 2017-09-13 09:00:00\ncategories: Spring\ntags:\n  - aop\n---\n\n## AOP\n\n**`1.什么是AOP`**\n\n1. AOP是一种编程范式，不是编程语言，解决特定的问题。（解决代码重复问题 、关注点分离）\n2. 面向切面编程（AOP是Aspect Oriented Program的首字母缩写）将应用程序切分成一个个关注点，让每一个关注点成为\n   独立的，也只做一件事情，尽量不让关注点之间产生耦合。\n   AOP其实只是OOP的补充而已。OOP从横向上区分出一个个的类来，而AOP则从纵向上向对象中加入特定的代码。有了AOP，OOP变得立体了。如果加上时间维度，AOP使OOP由原来的二维变为三维了，由平面变成立体了。从技术上来说，AOP基本上是通过代理机制实现的。\n   这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。\n3. AOP技术它利用一种称为\"横切\"\n   的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为\"Aspect\"，即切面。所谓\"切面\"\n   ，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。使用\"\n   横切\"\n   技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。\n\n**`2.基本概念`**\n\n1. 切面（Aspect）：对横切性关注点的模块化，其实就是共有功能的实现。如日志切面、权限切面等。\n2. 连接点（JoinPoint）：就是程序在运行过程中能够插入切面的地点。例如，方法调用、异常抛出或字段修改等，但Spring只支持方法级的连接点。\n3. 通知（Advice）：在切面的某个特定的连接点（Joinpoint）上执行的动作。通知有各种类型。\n4. 切入点（Pointcut）：用于定义通知（Advice）应该切入到哪些连接点(JoinPoint)上。不同的通知通常需要切入到不同的连接点上，这种精准的匹配是由切入点的正则表达式来定义的。\n5. 目标对象（Target）：就是那些即将切入切面的对象，也就是那些被通知的对象。\n6. 代理对象（Proxy）：将通知应用到目标对象之后被动态创建的对象\n7. 织入（Weaving）：将切面应用到目标对象从而创建一个新的代理对象的过程。\n\n## spring AOP的使用\n\n**`xml配置`**\n\n    <bean id=\"advice\" class=\"test.Advice\" />  \n    <aop:config>  \n        <aop:aspect id=\"aspect\" ref=\"advice\">  \n            <aop:pointcut id=\"service\" expression=\"execution(* com.demo.aop.*.find*(..))\"/>  \n            <aop:before method=\"doBefore\"  pointcut-ref=\"service\"/>  \n            <aop:after method=\"doAfter\"  pointcut-ref=\"service\"/>  \n            <aop:around method=\"doAround\"  pointcut-ref=\"service\"/>  \n            <aop:after-returning method=\"doReturn\"  pointcut-ref=\"service\"/>  \n            <aop:after-throwing method=\"doThrowing\" throwing=\"ex\" pointcut-ref=\"service\"/>  \n              \n        </aop:aspect>  \n    </aop:config>\n\n\tpackage test;   \n\timport org.aspectj.lang.JoinPoint;  \n\timport org.aspectj.lang.ProceedingJoinPoint;  \n\tpublic class Advice {  \n\t    private void doBefore(JoinPoint joinPoint) {  \n\t       \n\t    }  \n\t    private Object doAround(ProceedingJoinPoint pjp) throws Throwable {  \n\t        Object retVal = pjp.proceed();  \n\t        return retVal;  \n\t    }  \n\t    private void doAfter(JoinPoint joinPoint) {  \n\t       \n\t    }  \n\t    private void doReturn(JoinPoint joinPoint) {  \n\t       \n\t    }  \n\t    private void doThrowing(JoinPoint joinPoint,Throwable ex) {  \n\t        \n\t    }  \n\t} \n\n\n\t<bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n\t\t<property name=\"dataSource\" ref=\"dataSource\" />\n\t</bean>\n\t<tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\">\n\t\t<tx:attributes>\n\t\t\t<tx:method name=\"save*\" propagation=\"REQUIRED\" />\n\t\t\t<tx:method name=\"insert*\" propagation=\"REQUIRED\" />\n\t\t\t<tx:method name=\"add*\" propagation=\"REQUIRED\" />\n\t\t\t<tx:method name=\"create*\" propagation=\"REQUIRED\" />\n\t\t\t<tx:method name=\"delete*\" propagation=\"REQUIRED\" />\n\t\t\t<tx:method name=\"update*\" propagation=\"REQUIRED\" />\n\t\t\t<tx:method name=\"find*\" propagation=\"SUPPORTS\" read-only=\"true\" />\n\t\t\t<tx:method name=\"select*\" propagation=\"SUPPORTS\" read-only=\"true\" />\n\t\t\t<tx:method name=\"get*\" propagation=\"SUPPORTS\" read-only=\"true\" />\n\t\t</tx:attributes>\n\t</tx:advice>\n \n\t<aop:config>\n\t\t<aop:advisor advice-ref=\"txAdvice\" pointcut=\"execution(* com.*.*.service.*.*(..))\" />\n\t</aop:config>\n\n**`注解配置`**\n\n\t<aop:aspectj-autoproxy/>\n\t\n\t@Aspect\n\t@Component\n\tpublic class MyAspect{\n\t\t\n\t\t@Pointcut(\"execution(* com.*.*.service.*.*(..))\")  \n\t\tprivate void piont(){ }\n\t\t \n\t\t@Before(\"piont()\")\n\t\tpublic void beforeTest(){\n\t\t\tSystem.out.println(\"beforeTest.................\");\n\t\t}\n\t\n\t}\n\n\texecution：用于匹配方法执行的连接点；\n\twithin：用于匹配指定类型内的方法执行；\n\tthis：用于匹配当前AOP代理对象类型的执行方法；注意是AOP代理对象的类型匹配，这样就可能包括引入接口也类型匹配；\n\ttarget：用于匹配当前目标对象类型的执行方法；注意是目标对象的类型匹配，这样就不包括引入接口也类型匹配；\n\targs：用于匹配当前执行的方法传入的参数为指定类型的执行方法；\n\t@within：用于匹配所以持有指定注解类型内的方法；\n\t@target：用于匹配当前目标对象类型的执行方法，其中目标对象持有指定的注解；\n\t@args：用于匹配当前执行的方法传入的参数持有指定注解的执行；\n\t@annotation：用于匹配当前执行方法持有指定注解的方法；\n\tbean：Spring AOP扩展的，AspectJ没有对于指示符，用于匹配特定名称的Bean对象的执行方法；\n\treference pointcut：表示引用其他命名切入点，只有@ApectJ风格支持，Schema风格不支持。","slug":"AOP初步学习","published":1,"updated":"2024-11-27T03:42:52.239Z","_id":"cm3zc6m570000l8u68t5g4kz2","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"AOP\"><a href=\"#AOP\" class=\"headerlink\" title=\"AOP\"></a>AOP</h2><p><strong><code>1.什么是AOP</code></strong></p>\n<ol>\n<li>AOP是一种编程范式，不是编程语言，解决特定的问题。（解决代码重复问题 、关注点分离）</li>\n<li>面向切面编程（AOP是Aspect Oriented Program的首字母缩写）将应用程序切分成一个个关注点，让每一个关注点成为<br>独立的，也只做一件事情，尽量不让关注点之间产生耦合。<br>AOP其实只是OOP的补充而已。OOP从横向上区分出一个个的类来，而AOP则从纵向上向对象中加入特定的代码。有了AOP，OOP变得立体了。如果加上时间维度，AOP使OOP由原来的二维变为三维了，由平面变成立体了。从技术上来说，AOP基本上是通过代理机制实现的。<br>这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。</li>\n<li>AOP技术它利用一种称为”横切”<br>的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”<br>，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。使用”<br>横切”<br>技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</li>\n</ol>\n<p><strong><code>2.基本概念</code></strong></p>\n<ol>\n<li>切面（Aspect）：对横切性关注点的模块化，其实就是共有功能的实现。如日志切面、权限切面等。</li>\n<li>连接点（JoinPoint）：就是程序在运行过程中能够插入切面的地点。例如，方法调用、异常抛出或字段修改等，但Spring只支持方法级的连接点。</li>\n<li>通知（Advice）：在切面的某个特定的连接点（Joinpoint）上执行的动作。通知有各种类型。</li>\n<li>切入点（Pointcut）：用于定义通知（Advice）应该切入到哪些连接点(JoinPoint)上。不同的通知通常需要切入到不同的连接点上，这种精准的匹配是由切入点的正则表达式来定义的。</li>\n<li>目标对象（Target）：就是那些即将切入切面的对象，也就是那些被通知的对象。</li>\n<li>代理对象（Proxy）：将通知应用到目标对象之后被动态创建的对象</li>\n<li>织入（Weaving）：将切面应用到目标对象从而创建一个新的代理对象的过程。</li>\n</ol>\n<h2 id=\"spring-AOP的使用\"><a href=\"#spring-AOP的使用\" class=\"headerlink\" title=\"spring AOP的使用\"></a>spring AOP的使用</h2><p><strong><code>xml配置</code></strong></p>\n<pre><code>&lt;bean id=&quot;advice&quot; class=&quot;test.Advice&quot; /&gt;  \n&lt;aop:config&gt;  \n    &lt;aop:aspect id=&quot;aspect&quot; ref=&quot;advice&quot;&gt;  \n        &lt;aop:pointcut id=&quot;service&quot; expression=&quot;execution(* com.demo.aop.*.find*(..))&quot;/&gt;  \n        &lt;aop:before method=&quot;doBefore&quot;  pointcut-ref=&quot;service&quot;/&gt;  \n        &lt;aop:after method=&quot;doAfter&quot;  pointcut-ref=&quot;service&quot;/&gt;  \n        &lt;aop:around method=&quot;doAround&quot;  pointcut-ref=&quot;service&quot;/&gt;  \n        &lt;aop:after-returning method=&quot;doReturn&quot;  pointcut-ref=&quot;service&quot;/&gt;  \n        &lt;aop:after-throwing method=&quot;doThrowing&quot; throwing=&quot;ex&quot; pointcut-ref=&quot;service&quot;/&gt;  \n          \n    &lt;/aop:aspect&gt;  \n&lt;/aop:config&gt;\n\npackage test;   \nimport org.aspectj.lang.JoinPoint;  \nimport org.aspectj.lang.ProceedingJoinPoint;  \npublic class Advice &#123;  \n    private void doBefore(JoinPoint joinPoint) &#123;  \n       \n    &#125;  \n    private Object doAround(ProceedingJoinPoint pjp) throws Throwable &#123;  \n        Object retVal = pjp.proceed();  \n        return retVal;  \n    &#125;  \n    private void doAfter(JoinPoint joinPoint) &#123;  \n       \n    &#125;  \n    private void doReturn(JoinPoint joinPoint) &#123;  \n       \n    &#125;  \n    private void doThrowing(JoinPoint joinPoint,Throwable ex) &#123;  \n        \n    &#125;  \n&#125; \n\n\n&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;\n    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;\n&lt;/bean&gt;\n&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;\n    &lt;tx:attributes&gt;\n        &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot; /&gt;\n        &lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot; /&gt;\n        &lt;tx:method name=&quot;add*&quot; propagation=&quot;REQUIRED&quot; /&gt;\n        &lt;tx:method name=&quot;create*&quot; propagation=&quot;REQUIRED&quot; /&gt;\n        &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot; /&gt;\n        &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; /&gt;\n        &lt;tx:method name=&quot;find*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt;\n        &lt;tx:method name=&quot;select*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt;\n        &lt;tx:method name=&quot;get*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt;\n    &lt;/tx:attributes&gt;\n&lt;/tx:advice&gt;\n\n&lt;aop:config&gt;\n    &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* com.*.*.service.*.*(..))&quot; /&gt;\n&lt;/aop:config&gt;\n</code></pre>\n<p><strong><code>注解配置</code></strong></p>\n<pre><code>&lt;aop:aspectj-autoproxy/&gt;\n\n@Aspect\n@Component\npublic class MyAspect&#123;\n    \n    @Pointcut(&quot;execution(* com.*.*.service.*.*(..))&quot;)  \n    private void piont()&#123; &#125;\n     \n    @Before(&quot;piont()&quot;)\n    public void beforeTest()&#123;\n        System.out.println(&quot;beforeTest.................&quot;);\n    &#125;\n\n&#125;\n\nexecution：用于匹配方法执行的连接点；\nwithin：用于匹配指定类型内的方法执行；\nthis：用于匹配当前AOP代理对象类型的执行方法；注意是AOP代理对象的类型匹配，这样就可能包括引入接口也类型匹配；\ntarget：用于匹配当前目标对象类型的执行方法；注意是目标对象的类型匹配，这样就不包括引入接口也类型匹配；\nargs：用于匹配当前执行的方法传入的参数为指定类型的执行方法；\n@within：用于匹配所以持有指定注解类型内的方法；\n@target：用于匹配当前目标对象类型的执行方法，其中目标对象持有指定的注解；\n@args：用于匹配当前执行的方法传入的参数持有指定注解的执行；\n@annotation：用于匹配当前执行方法持有指定注解的方法；\nbean：Spring AOP扩展的，AspectJ没有对于指示符，用于匹配特定名称的Bean对象的执行方法；\nreference pointcut：表示引用其他命名切入点，只有@ApectJ风格支持，Schema风格不支持。\n</code></pre>\n","more":"<h2 id=\"AOP\"><a href=\"#AOP\" class=\"headerlink\" title=\"AOP\"></a>AOP</h2><p><strong><code>1.什么是AOP</code></strong></p>\n<ol>\n<li>AOP是一种编程范式，不是编程语言，解决特定的问题。（解决代码重复问题 、关注点分离）</li>\n<li>面向切面编程（AOP是Aspect Oriented Program的首字母缩写）将应用程序切分成一个个关注点，让每一个关注点成为<br>独立的，也只做一件事情，尽量不让关注点之间产生耦合。<br>AOP其实只是OOP的补充而已。OOP从横向上区分出一个个的类来，而AOP则从纵向上向对象中加入特定的代码。有了AOP，OOP变得立体了。如果加上时间维度，AOP使OOP由原来的二维变为三维了，由平面变成立体了。从技术上来说，AOP基本上是通过代理机制实现的。<br>这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。</li>\n<li>AOP技术它利用一种称为”横切”<br>的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”<br>，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。使用”<br>横切”<br>技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</li>\n</ol>\n<p><strong><code>2.基本概念</code></strong></p>\n<ol>\n<li>切面（Aspect）：对横切性关注点的模块化，其实就是共有功能的实现。如日志切面、权限切面等。</li>\n<li>连接点（JoinPoint）：就是程序在运行过程中能够插入切面的地点。例如，方法调用、异常抛出或字段修改等，但Spring只支持方法级的连接点。</li>\n<li>通知（Advice）：在切面的某个特定的连接点（Joinpoint）上执行的动作。通知有各种类型。</li>\n<li>切入点（Pointcut）：用于定义通知（Advice）应该切入到哪些连接点(JoinPoint)上。不同的通知通常需要切入到不同的连接点上，这种精准的匹配是由切入点的正则表达式来定义的。</li>\n<li>目标对象（Target）：就是那些即将切入切面的对象，也就是那些被通知的对象。</li>\n<li>代理对象（Proxy）：将通知应用到目标对象之后被动态创建的对象</li>\n<li>织入（Weaving）：将切面应用到目标对象从而创建一个新的代理对象的过程。</li>\n</ol>\n<h2 id=\"spring-AOP的使用\"><a href=\"#spring-AOP的使用\" class=\"headerlink\" title=\"spring AOP的使用\"></a>spring AOP的使用</h2><p><strong><code>xml配置</code></strong></p>\n<pre><code>&lt;bean id=&quot;advice&quot; class=&quot;test.Advice&quot; /&gt;  \n&lt;aop:config&gt;  \n    &lt;aop:aspect id=&quot;aspect&quot; ref=&quot;advice&quot;&gt;  \n        &lt;aop:pointcut id=&quot;service&quot; expression=&quot;execution(* com.demo.aop.*.find*(..))&quot;/&gt;  \n        &lt;aop:before method=&quot;doBefore&quot;  pointcut-ref=&quot;service&quot;/&gt;  \n        &lt;aop:after method=&quot;doAfter&quot;  pointcut-ref=&quot;service&quot;/&gt;  \n        &lt;aop:around method=&quot;doAround&quot;  pointcut-ref=&quot;service&quot;/&gt;  \n        &lt;aop:after-returning method=&quot;doReturn&quot;  pointcut-ref=&quot;service&quot;/&gt;  \n        &lt;aop:after-throwing method=&quot;doThrowing&quot; throwing=&quot;ex&quot; pointcut-ref=&quot;service&quot;/&gt;  \n          \n    &lt;/aop:aspect&gt;  \n&lt;/aop:config&gt;\n\npackage test;   \nimport org.aspectj.lang.JoinPoint;  \nimport org.aspectj.lang.ProceedingJoinPoint;  \npublic class Advice &#123;  \n    private void doBefore(JoinPoint joinPoint) &#123;  \n       \n    &#125;  \n    private Object doAround(ProceedingJoinPoint pjp) throws Throwable &#123;  \n        Object retVal = pjp.proceed();  \n        return retVal;  \n    &#125;  \n    private void doAfter(JoinPoint joinPoint) &#123;  \n       \n    &#125;  \n    private void doReturn(JoinPoint joinPoint) &#123;  \n       \n    &#125;  \n    private void doThrowing(JoinPoint joinPoint,Throwable ex) &#123;  \n        \n    &#125;  \n&#125; \n\n\n&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;\n    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;\n&lt;/bean&gt;\n&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;\n    &lt;tx:attributes&gt;\n        &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot; /&gt;\n        &lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot; /&gt;\n        &lt;tx:method name=&quot;add*&quot; propagation=&quot;REQUIRED&quot; /&gt;\n        &lt;tx:method name=&quot;create*&quot; propagation=&quot;REQUIRED&quot; /&gt;\n        &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot; /&gt;\n        &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; /&gt;\n        &lt;tx:method name=&quot;find*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt;\n        &lt;tx:method name=&quot;select*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt;\n        &lt;tx:method name=&quot;get*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt;\n    &lt;/tx:attributes&gt;\n&lt;/tx:advice&gt;\n\n&lt;aop:config&gt;\n    &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* com.*.*.service.*.*(..))&quot; /&gt;\n&lt;/aop:config&gt;\n</code></pre>\n<p><strong><code>注解配置</code></strong></p>\n<pre><code>&lt;aop:aspectj-autoproxy/&gt;\n\n@Aspect\n@Component\npublic class MyAspect&#123;\n    \n    @Pointcut(&quot;execution(* com.*.*.service.*.*(..))&quot;)  \n    private void piont()&#123; &#125;\n     \n    @Before(&quot;piont()&quot;)\n    public void beforeTest()&#123;\n        System.out.println(&quot;beforeTest.................&quot;);\n    &#125;\n\n&#125;\n\nexecution：用于匹配方法执行的连接点；\nwithin：用于匹配指定类型内的方法执行；\nthis：用于匹配当前AOP代理对象类型的执行方法；注意是AOP代理对象的类型匹配，这样就可能包括引入接口也类型匹配；\ntarget：用于匹配当前目标对象类型的执行方法；注意是目标对象的类型匹配，这样就不包括引入接口也类型匹配；\nargs：用于匹配当前执行的方法传入的参数为指定类型的执行方法；\n@within：用于匹配所以持有指定注解类型内的方法；\n@target：用于匹配当前目标对象类型的执行方法，其中目标对象持有指定的注解；\n@args：用于匹配当前执行的方法传入的参数持有指定注解的执行；\n@annotation：用于匹配当前执行方法持有指定注解的方法；\nbean：Spring AOP扩展的，AspectJ没有对于指示符，用于匹配特定名称的Bean对象的执行方法；\nreference pointcut：表示引用其他命名切入点，只有@ApectJ风格支持，Schema风格不支持。\n</code></pre>\n"},{"title":"rocketmq初步学习","excerpt":"Apache RocketMQ 是一款低延迟、高并发、高可用、高可靠的分布式消息中间件。消息队列 RocketMQ 可为分布式应用系统提供异步解耦和削峰填谷的能力，同时也具备互联网应用所需的海量消息堆积、高吞吐、可靠重试等特性。","date":"2017-09-08T01:00:00.000Z","_content":"\n# RocketMq\n----------------\n\n### RocketMq 特色\n\n1. 强大的消息重试机制\n2. 支持 mqadmin 命令管理\n3. 模式 多Master no slave、多Master 多 slave\n4. 主从策略：同步双写，异步复制\n5. 刷盘策略：同步刷盘，异步刷盘（是本节点内 index、 store,commitLong的数据同步）\n\n### RocketMq 与业术语\n\n1. Producer: 消息生产者，负责产生消息，一般由业务系统负责产生消息。\n2. Consumer: 消息消费者，负责消费消息，一般是后台系统负责异步消费。\n3. Push Consumer: Consumer 的一种，应用通常吐 Consumer 对象注册一个 Listener 接口，一旦收到消息，Consumer 对象立\n4. Push Consumer: Consumer 的一种，应用通常吐 Consumer 对象注册一个 Listener 接口，一旦收到消息，Consumer 对象立刻回调\n   Listener 接口方法。\n5. Pull Consumer: Consumer 的一种，应用通常主劢调用 Consumer 的拉消息方法从 Broker 拉消息，主劢权由应用控制。\n6. Producer Group: 一类 Producer 的集合名称，返类 Producer 通常収送一类消息，丏収送逡辑一致。\n7. Consumer Group 一类 Consumer 的集合名称，返类 Consumer 通常消费一类消息，丏消费逡辑一致。\n8. Broker: 消息中转角色，负责存储消息，转収消息，一般也称为 Server。在 JMS 规范中称为 Provider。\n9. 广播消费: 一条消息被多个 Consumer 消费， 即使返些 Consumer 属亍同一个 Consumer Group， 消息也会被 Consumer Group 中的每个\n   Consumer 都消费一次， 广播消费中的 Consumer Group 概念可以讣为在消息划分方面无意义。在 CORBA Notification\n   规范中，消费方式都属亍广播消费。 项目开源主页：https://github.com/alibaba/RocketMQ\n10. 集群消费 一个 Consumer Group 中的 Consumer 实例平均分摊消费消息。例如某个 Topic 有 9 条消息，其中一个Consumer Group 有\n    3 个实例（可能是 3 个迕程，戒者 3 台机器） ，那举每个实例只消费其中的 3 条消息。在 CORBA Notification 规范中，无此消费方式。在\n    JMS 规范中，JMS point-to-point model 不乀类似，但是 RocketMQ 的集群消费功能大等亍 PTP 模型。\n    因为RocketMQ单个Consumer Group内的消费者类似亍PTP， 但是一个Topic/Queue可以被多个Consumer\n    Group 消费。\n11. 一个主题下默认有4个Quene 可以修改：p.createTopic\n12. 主从实时：保证主节点挂了，也能及时消费该节点的数据，而不用等主节点恢复。\n\n### RocketMq发送消息例子\n\n**`普通消息`**\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tDefaultMQProducer producer = new DefaultMQProducer(\"producer\");\n\t\tproducer.setNamesrvAddr(\"127.0.0.1:9876\");\n\t\tproducer.setRetryTimesWhenSendAsyncFailed(5);//失败重试次数\n\t\tproducer.start();\n\t\tMessage msg = new Message(\"topic1\", \"tag1\", \"key1\", (\"mess body\").getBytes());\n\t\tSendResult sendResult = producer.send(msg);//发送失败 内部自动，重试没有抛异常即为成功。\n\t\tSystem.out.println(sendResult);\n\t\tproducer.shutdown();\n\t}\n\n\n\tpublic static void main(String[] args) throws MQClientException {\n\t\tDefaultMQPushConsumer consumer=new DefaultMQPushConsumer(\"consumer\");\n\t\tconsumer.setNamesrvAddr(\"127.0.0.1:9876\");\n\t\tconsumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n\t\tconsumer.subscribe(\"topic1\", \"tag1|tag2|tag1\");\n\t\tconsumer.registerMessageListener(new MessageListenerConcurrently() {\n\t\t\tpublic ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n\t\t\t\tfor (MessageExt mes : msgs) {\n\t\t\t\t\tSystem.out.println(new String(mes.getBody()));\n\t\t\t\t}\n\t\t\t\treturn ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n\t\t\t}\n\t\t});\n\t\tconsumer.start();\n\t}\n\n**`顺序消息`**\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tDefaultMQProducer producer = new DefaultMQProducer(\"producer\");\n\t\tproducer.setNamesrvAddr(\"127.0.0.1:9876\");\n\t\tproducer.start();\n\t\tMessage msg = new Message(\"topic1\", \"tag1\", \"key1\", (\"消息内容：aaaa\").getBytes());\n\t\t//必须自己实现MessageQueueSelector 保证消息进入同一个队列 arg 队列下标\t\n\t\tSendResult sendResult = producer.send(msg,new MessageQueueSelector(){\n\t\t\tpublic MessageQueue select(List<MessageQueue> mqs, Message msg, Object arg) {\n\t\t\t\treturn mqs.get((Integer)arg);\n\t\t\t}\n\t\t\t\n\t\t},0);\n\t\tSystem.out.println(sendResult);\n\t\tproducer.shutdown();\n\t}\n\n\n\tpublic static void main(String[] args) throws MQClientException {\n\t\tDefaultMQPushConsumer consumer=new DefaultMQPushConsumer(\"consumer\");\n\t\tconsumer.setNamesrvAddr(\"127.0.0.1:9876\");\n\t\tconsumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n\t\tconsumer.subscribe(\"topic1\", \"*\");\n\t\tconsumer.setConsumeThreadMin(10);\n\t\tconsumer.registerMessageListener(new MessageListenerOrderly() {\n\t\t\tpublic ConsumeOrderlyStatus consumeMessage(List<MessageExt> msgs, ConsumeOrderlyContext context) {\n\t\t\t\tfor (MessageExt mes : msgs) {\n\t\t\t\t\tSystem.out.println(new String(mes.getBody()));\n\t\t\t\t}\n\t\t\t\treturn ConsumeOrderlyStatus.SUCCESS;\n\t\t\t}\n\t\t});\n\t\tconsumer.start();\n\t}\n\n\t顺序消息的实现：1.一组有顺序的消息必须放进同一个队列。\n\t\t\t \t  2.一个消费者的一个线程只能接收一个队列的消息 消费者必须是实现，MessageListenerOrderly的监听。\n\n**`事务消息`**\n\n\tpublic static void main(String[] args) throws MQClientException {\n\t\tTransactionMQProducer producer = new TransactionMQProducer(\"producer\");\n\t\tproducer.setNamesrvAddr(\"127.0.0.1:9876\");\n\t\tproducer.setTransactionCheckListener(new TransactionCheckListener() {\n\t\t\tpublic LocalTransactionState checkLocalTransactionState(MessageExt msg) {\n\t\t\t\treturn LocalTransactionState.COMMIT_MESSAGE;\n\t\t\t}\n\t\t});\n\t\tproducer.start();\n\t\tMessage msg = new Message(\"TransactionTopic\", \"tag1\", \"key1\", (\"消息: aaa a\").getBytes());\n\t\tSendResult sendResult = producer.sendMessageInTransaction(msg, new LocalTransactionExecuter() {\n\t\t\tpublic LocalTransactionState executeLocalTransactionBranch(Message msg, Object arg) {\n\t\t\t\tSystem.out.println(msg);\n\t\t\t\treturn LocalTransactionState.COMMIT_MESSAGE;\n\t\t\t}\n\t\t}, \"回调里的Object arg\");\n\t\tSystem.out.println(sendResult);\n\t\tproducer.shutdown();\n\t}\n\n\tpublic static void main(String[] args) throws MQClientException {\n\t\tMQConsumer consumer=new MQConsumer(\"consumer\");\n\t\tconsumer.setNamesrvAddr(\"127.0.0.1:9876\");\n\t\tconsumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n\t\tconsumer.subscribe(\"TransactionTopic\", \"*\");\n\t\tconsumer.setMessageListener(new MessageListenerConcurrently() {\n\t\t\tpublic ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n\t\t\t\tfor (MessageExt mes : msgs) {\n\t\t\t\t\tSystem.out.println(new String(mes.getBody()));\n\t\t\t\t}\n\t\t\t\treturn ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n\t\t\t}\n\t\t});\n\t\tconsumer.start();\n\t}\n\n**`MessageFilter过滤消息`**\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tDefaultMQProducer producer = new DefaultMQProducer(\"producer\");\n\t\tproducer.setNamesrvAddr(\"127.0.0.1:9876\");\n\t\tproducer.start();\n\t\tMessage msg = new Message(\"topic1\", \"tag1\", \"key1\", (\"mess body\").getBytes());\n\t\tSendResult sendResult = producer.send(msg);\n\t\tSystem.out.println(sendResult);\n\t\tproducer.shutdown();\n\t}\n\n\tpublic static void main(String[] args) throws MQClientException {\n\t\tDefaultMQPushConsumer consumer=new DefaultMQPushConsumer(\"consumer\");\n\t\tconsumer.setNamesrvAddr(\"127.0.0.1:9876\");\n\t\tconsumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n\t\tString code = MixAll.file2String(\"H:/code/mq/src/main/java/rocketmq/apt/MesFilter.java\");\n\t\tconsumer.subscribe(\"topic1\",\"rocketmq.apt.MesFilter\",code);\n\t\tconsumer.setConsumeThreadMin(10);\n\t\tconsumer.registerMessageListener(new MessageListenerConcurrently() {\n\t\t\tpublic ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n\t\t\t\tfor (MessageExt mes : msgs) {\n\t\t\t\t\tSystem.out.println(new String(mes.getBody()));\n\t\t\t\t}\n\t\t\t\treturn ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n\t\t\t}\n\t\t});\n\t\tconsumer.start();\n\t}\n\n\tpublic class MesFilter implements MessageFilter{\n\t\tpublic boolean match(MessageExt msg) {\n\t\t\treturn false;//Determines whether this message is entered fileter\n\t\t}\n\t\n\t}\n\n\t注意： MesFilter中不能有汉字\n\n### 注意事项\n\n1. 可能出现重复消息，消费先做判断。\n2. pull类消费,无重试机制（PullMessageService、DefaultMQPullConsumer）\n3. 先启动提供者 消费者可能会一次拿多条消息。\n4. 一定要先启动消费者，再启动生产者 可以避免很多问题。\n5. 消费消息时：\n   1、若mq里有一堆消息那么消费者可能会批量消费 ，可以设置最大消费量为1限制。 （这样好返回消息失败状态，而不是批量状态。避免重复消费）\n   2、消费消息后 可以返回消息状态\n   3、没有返回消息状态的消息会不断重发 无次数限制。\n   4、若返回消息状态是稍后再试，会根据默认 1s、2s、5s...2h发送。\n   消息里有重试次数 （若不想一直重试，可以在重试 多少次后记录日志，返回成功标志。）\n   5、可以设置负载均很、\n6. 先启动提供者 在启动 消费者1 在启动消费者2 可能重复消费（1在处理 没有返回，mq会再把消息发给 2）\n\n]()","source":"_posts/rocketmq初步学习.md","raw":"---\ntitle: \"rocketmq初步学习\"\nexcerpt: Apache RocketMQ 是一款低延迟、高并发、高可用、高可靠的分布式消息中间件。消息队列 RocketMQ 可为分布式应用系统提供异步解耦和削峰填谷的能力，同时也具备互联网应用所需的海量消息堆积、高吞吐、可靠重试等特性。\ndate: 2017-09-08 09:00:00\ncategories: MQ\ntags:\n  - rocketmq\n---\n\n# RocketMq\n----------------\n\n### RocketMq 特色\n\n1. 强大的消息重试机制\n2. 支持 mqadmin 命令管理\n3. 模式 多Master no slave、多Master 多 slave\n4. 主从策略：同步双写，异步复制\n5. 刷盘策略：同步刷盘，异步刷盘（是本节点内 index、 store,commitLong的数据同步）\n\n### RocketMq 与业术语\n\n1. Producer: 消息生产者，负责产生消息，一般由业务系统负责产生消息。\n2. Consumer: 消息消费者，负责消费消息，一般是后台系统负责异步消费。\n3. Push Consumer: Consumer 的一种，应用通常吐 Consumer 对象注册一个 Listener 接口，一旦收到消息，Consumer 对象立\n4. Push Consumer: Consumer 的一种，应用通常吐 Consumer 对象注册一个 Listener 接口，一旦收到消息，Consumer 对象立刻回调\n   Listener 接口方法。\n5. Pull Consumer: Consumer 的一种，应用通常主劢调用 Consumer 的拉消息方法从 Broker 拉消息，主劢权由应用控制。\n6. Producer Group: 一类 Producer 的集合名称，返类 Producer 通常収送一类消息，丏収送逡辑一致。\n7. Consumer Group 一类 Consumer 的集合名称，返类 Consumer 通常消费一类消息，丏消费逡辑一致。\n8. Broker: 消息中转角色，负责存储消息，转収消息，一般也称为 Server。在 JMS 规范中称为 Provider。\n9. 广播消费: 一条消息被多个 Consumer 消费， 即使返些 Consumer 属亍同一个 Consumer Group， 消息也会被 Consumer Group 中的每个\n   Consumer 都消费一次， 广播消费中的 Consumer Group 概念可以讣为在消息划分方面无意义。在 CORBA Notification\n   规范中，消费方式都属亍广播消费。 项目开源主页：https://github.com/alibaba/RocketMQ\n10. 集群消费 一个 Consumer Group 中的 Consumer 实例平均分摊消费消息。例如某个 Topic 有 9 条消息，其中一个Consumer Group 有\n    3 个实例（可能是 3 个迕程，戒者 3 台机器） ，那举每个实例只消费其中的 3 条消息。在 CORBA Notification 规范中，无此消费方式。在\n    JMS 规范中，JMS point-to-point model 不乀类似，但是 RocketMQ 的集群消费功能大等亍 PTP 模型。\n    因为RocketMQ单个Consumer Group内的消费者类似亍PTP， 但是一个Topic/Queue可以被多个Consumer\n    Group 消费。\n11. 一个主题下默认有4个Quene 可以修改：p.createTopic\n12. 主从实时：保证主节点挂了，也能及时消费该节点的数据，而不用等主节点恢复。\n\n### RocketMq发送消息例子\n\n**`普通消息`**\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tDefaultMQProducer producer = new DefaultMQProducer(\"producer\");\n\t\tproducer.setNamesrvAddr(\"127.0.0.1:9876\");\n\t\tproducer.setRetryTimesWhenSendAsyncFailed(5);//失败重试次数\n\t\tproducer.start();\n\t\tMessage msg = new Message(\"topic1\", \"tag1\", \"key1\", (\"mess body\").getBytes());\n\t\tSendResult sendResult = producer.send(msg);//发送失败 内部自动，重试没有抛异常即为成功。\n\t\tSystem.out.println(sendResult);\n\t\tproducer.shutdown();\n\t}\n\n\n\tpublic static void main(String[] args) throws MQClientException {\n\t\tDefaultMQPushConsumer consumer=new DefaultMQPushConsumer(\"consumer\");\n\t\tconsumer.setNamesrvAddr(\"127.0.0.1:9876\");\n\t\tconsumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n\t\tconsumer.subscribe(\"topic1\", \"tag1|tag2|tag1\");\n\t\tconsumer.registerMessageListener(new MessageListenerConcurrently() {\n\t\t\tpublic ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n\t\t\t\tfor (MessageExt mes : msgs) {\n\t\t\t\t\tSystem.out.println(new String(mes.getBody()));\n\t\t\t\t}\n\t\t\t\treturn ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n\t\t\t}\n\t\t});\n\t\tconsumer.start();\n\t}\n\n**`顺序消息`**\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tDefaultMQProducer producer = new DefaultMQProducer(\"producer\");\n\t\tproducer.setNamesrvAddr(\"127.0.0.1:9876\");\n\t\tproducer.start();\n\t\tMessage msg = new Message(\"topic1\", \"tag1\", \"key1\", (\"消息内容：aaaa\").getBytes());\n\t\t//必须自己实现MessageQueueSelector 保证消息进入同一个队列 arg 队列下标\t\n\t\tSendResult sendResult = producer.send(msg,new MessageQueueSelector(){\n\t\t\tpublic MessageQueue select(List<MessageQueue> mqs, Message msg, Object arg) {\n\t\t\t\treturn mqs.get((Integer)arg);\n\t\t\t}\n\t\t\t\n\t\t},0);\n\t\tSystem.out.println(sendResult);\n\t\tproducer.shutdown();\n\t}\n\n\n\tpublic static void main(String[] args) throws MQClientException {\n\t\tDefaultMQPushConsumer consumer=new DefaultMQPushConsumer(\"consumer\");\n\t\tconsumer.setNamesrvAddr(\"127.0.0.1:9876\");\n\t\tconsumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n\t\tconsumer.subscribe(\"topic1\", \"*\");\n\t\tconsumer.setConsumeThreadMin(10);\n\t\tconsumer.registerMessageListener(new MessageListenerOrderly() {\n\t\t\tpublic ConsumeOrderlyStatus consumeMessage(List<MessageExt> msgs, ConsumeOrderlyContext context) {\n\t\t\t\tfor (MessageExt mes : msgs) {\n\t\t\t\t\tSystem.out.println(new String(mes.getBody()));\n\t\t\t\t}\n\t\t\t\treturn ConsumeOrderlyStatus.SUCCESS;\n\t\t\t}\n\t\t});\n\t\tconsumer.start();\n\t}\n\n\t顺序消息的实现：1.一组有顺序的消息必须放进同一个队列。\n\t\t\t \t  2.一个消费者的一个线程只能接收一个队列的消息 消费者必须是实现，MessageListenerOrderly的监听。\n\n**`事务消息`**\n\n\tpublic static void main(String[] args) throws MQClientException {\n\t\tTransactionMQProducer producer = new TransactionMQProducer(\"producer\");\n\t\tproducer.setNamesrvAddr(\"127.0.0.1:9876\");\n\t\tproducer.setTransactionCheckListener(new TransactionCheckListener() {\n\t\t\tpublic LocalTransactionState checkLocalTransactionState(MessageExt msg) {\n\t\t\t\treturn LocalTransactionState.COMMIT_MESSAGE;\n\t\t\t}\n\t\t});\n\t\tproducer.start();\n\t\tMessage msg = new Message(\"TransactionTopic\", \"tag1\", \"key1\", (\"消息: aaa a\").getBytes());\n\t\tSendResult sendResult = producer.sendMessageInTransaction(msg, new LocalTransactionExecuter() {\n\t\t\tpublic LocalTransactionState executeLocalTransactionBranch(Message msg, Object arg) {\n\t\t\t\tSystem.out.println(msg);\n\t\t\t\treturn LocalTransactionState.COMMIT_MESSAGE;\n\t\t\t}\n\t\t}, \"回调里的Object arg\");\n\t\tSystem.out.println(sendResult);\n\t\tproducer.shutdown();\n\t}\n\n\tpublic static void main(String[] args) throws MQClientException {\n\t\tMQConsumer consumer=new MQConsumer(\"consumer\");\n\t\tconsumer.setNamesrvAddr(\"127.0.0.1:9876\");\n\t\tconsumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n\t\tconsumer.subscribe(\"TransactionTopic\", \"*\");\n\t\tconsumer.setMessageListener(new MessageListenerConcurrently() {\n\t\t\tpublic ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n\t\t\t\tfor (MessageExt mes : msgs) {\n\t\t\t\t\tSystem.out.println(new String(mes.getBody()));\n\t\t\t\t}\n\t\t\t\treturn ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n\t\t\t}\n\t\t});\n\t\tconsumer.start();\n\t}\n\n**`MessageFilter过滤消息`**\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tDefaultMQProducer producer = new DefaultMQProducer(\"producer\");\n\t\tproducer.setNamesrvAddr(\"127.0.0.1:9876\");\n\t\tproducer.start();\n\t\tMessage msg = new Message(\"topic1\", \"tag1\", \"key1\", (\"mess body\").getBytes());\n\t\tSendResult sendResult = producer.send(msg);\n\t\tSystem.out.println(sendResult);\n\t\tproducer.shutdown();\n\t}\n\n\tpublic static void main(String[] args) throws MQClientException {\n\t\tDefaultMQPushConsumer consumer=new DefaultMQPushConsumer(\"consumer\");\n\t\tconsumer.setNamesrvAddr(\"127.0.0.1:9876\");\n\t\tconsumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n\t\tString code = MixAll.file2String(\"H:/code/mq/src/main/java/rocketmq/apt/MesFilter.java\");\n\t\tconsumer.subscribe(\"topic1\",\"rocketmq.apt.MesFilter\",code);\n\t\tconsumer.setConsumeThreadMin(10);\n\t\tconsumer.registerMessageListener(new MessageListenerConcurrently() {\n\t\t\tpublic ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n\t\t\t\tfor (MessageExt mes : msgs) {\n\t\t\t\t\tSystem.out.println(new String(mes.getBody()));\n\t\t\t\t}\n\t\t\t\treturn ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n\t\t\t}\n\t\t});\n\t\tconsumer.start();\n\t}\n\n\tpublic class MesFilter implements MessageFilter{\n\t\tpublic boolean match(MessageExt msg) {\n\t\t\treturn false;//Determines whether this message is entered fileter\n\t\t}\n\t\n\t}\n\n\t注意： MesFilter中不能有汉字\n\n### 注意事项\n\n1. 可能出现重复消息，消费先做判断。\n2. pull类消费,无重试机制（PullMessageService、DefaultMQPullConsumer）\n3. 先启动提供者 消费者可能会一次拿多条消息。\n4. 一定要先启动消费者，再启动生产者 可以避免很多问题。\n5. 消费消息时：\n   1、若mq里有一堆消息那么消费者可能会批量消费 ，可以设置最大消费量为1限制。 （这样好返回消息失败状态，而不是批量状态。避免重复消费）\n   2、消费消息后 可以返回消息状态\n   3、没有返回消息状态的消息会不断重发 无次数限制。\n   4、若返回消息状态是稍后再试，会根据默认 1s、2s、5s...2h发送。\n   消息里有重试次数 （若不想一直重试，可以在重试 多少次后记录日志，返回成功标志。）\n   5、可以设置负载均很、\n6. 先启动提供者 在启动 消费者1 在启动消费者2 可能重复消费（1在处理 没有返回，mq会再把消息发给 2）\n\n]()","slug":"rocketmq初步学习","published":1,"updated":"2024-11-27T03:42:22.231Z","_id":"cm3zc73hv0003l8u6gjje2qnt","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"RocketMq\"><a href=\"#RocketMq\" class=\"headerlink\" title=\"RocketMq\"></a>RocketMq</h1><hr>\n<h3 id=\"RocketMq-特色\"><a href=\"#RocketMq-特色\" class=\"headerlink\" title=\"RocketMq 特色\"></a>RocketMq 特色</h3><ol>\n<li>强大的消息重试机制</li>\n<li>支持 mqadmin 命令管理</li>\n<li>模式 多Master no slave、多Master 多 slave</li>\n<li>主从策略：同步双写，异步复制</li>\n<li>刷盘策略：同步刷盘，异步刷盘（是本节点内 index、 store,commitLong的数据同步）</li>\n</ol>\n<h3 id=\"RocketMq-与业术语\"><a href=\"#RocketMq-与业术语\" class=\"headerlink\" title=\"RocketMq 与业术语\"></a>RocketMq 与业术语</h3><ol>\n<li>Producer: 消息生产者，负责产生消息，一般由业务系统负责产生消息。</li>\n<li>Consumer: 消息消费者，负责消费消息，一般是后台系统负责异步消费。</li>\n<li>Push Consumer: Consumer 的一种，应用通常吐 Consumer 对象注册一个 Listener 接口，一旦收到消息，Consumer 对象立</li>\n<li>Push Consumer: Consumer 的一种，应用通常吐 Consumer 对象注册一个 Listener 接口，一旦收到消息，Consumer 对象立刻回调<br>Listener 接口方法。</li>\n<li>Pull Consumer: Consumer 的一种，应用通常主劢调用 Consumer 的拉消息方法从 Broker 拉消息，主劢权由应用控制。</li>\n<li>Producer Group: 一类 Producer 的集合名称，返类 Producer 通常収送一类消息，丏収送逡辑一致。</li>\n<li>Consumer Group 一类 Consumer 的集合名称，返类 Consumer 通常消费一类消息，丏消费逡辑一致。</li>\n<li>Broker: 消息中转角色，负责存储消息，转収消息，一般也称为 Server。在 JMS 规范中称为 Provider。</li>\n<li>广播消费: 一条消息被多个 Consumer 消费， 即使返些 Consumer 属亍同一个 Consumer Group， 消息也会被 Consumer Group 中的每个<br>Consumer 都消费一次， 广播消费中的 Consumer Group 概念可以讣为在消息划分方面无意义。在 CORBA Notification<br>规范中，消费方式都属亍广播消费。 项目开源主页：<a href=\"https://github.com/alibaba/RocketMQ\">https://github.com/alibaba/RocketMQ</a></li>\n<li>集群消费 一个 Consumer Group 中的 Consumer 实例平均分摊消费消息。例如某个 Topic 有 9 条消息，其中一个Consumer Group 有<br>3 个实例（可能是 3 个迕程，戒者 3 台机器） ，那举每个实例只消费其中的 3 条消息。在 CORBA Notification 规范中，无此消费方式。在<br>JMS 规范中，JMS point-to-point model 不乀类似，但是 RocketMQ 的集群消费功能大等亍 PTP 模型。<br>因为RocketMQ单个Consumer Group内的消费者类似亍PTP， 但是一个Topic&#x2F;Queue可以被多个Consumer<br>Group 消费。</li>\n<li>一个主题下默认有4个Quene 可以修改：p.createTopic</li>\n<li>主从实时：保证主节点挂了，也能及时消费该节点的数据，而不用等主节点恢复。</li>\n</ol>\n<h3 id=\"RocketMq发送消息例子\"><a href=\"#RocketMq发送消息例子\" class=\"headerlink\" title=\"RocketMq发送消息例子\"></a>RocketMq发送消息例子</h3><p><strong><code>普通消息</code></strong></p>\n<pre><code>public static void main(String[] args) throws Exception &#123;\n    DefaultMQProducer producer = new DefaultMQProducer(&quot;producer&quot;);\n    producer.setNamesrvAddr(&quot;127.0.0.1:9876&quot;);\n    producer.setRetryTimesWhenSendAsyncFailed(5);//失败重试次数\n    producer.start();\n    Message msg = new Message(&quot;topic1&quot;, &quot;tag1&quot;, &quot;key1&quot;, (&quot;mess body&quot;).getBytes());\n    SendResult sendResult = producer.send(msg);//发送失败 内部自动，重试没有抛异常即为成功。\n    System.out.println(sendResult);\n    producer.shutdown();\n&#125;\n\n\npublic static void main(String[] args) throws MQClientException &#123;\n    DefaultMQPushConsumer consumer=new DefaultMQPushConsumer(&quot;consumer&quot;);\n    consumer.setNamesrvAddr(&quot;127.0.0.1:9876&quot;);\n    consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n    consumer.subscribe(&quot;topic1&quot;, &quot;tag1|tag2|tag1&quot;);\n    consumer.registerMessageListener(new MessageListenerConcurrently() &#123;\n        public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context) &#123;\n            for (MessageExt mes : msgs) &#123;\n                System.out.println(new String(mes.getBody()));\n            &#125;\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        &#125;\n    &#125;);\n    consumer.start();\n&#125;\n</code></pre>\n<p><strong><code>顺序消息</code></strong></p>\n<pre><code>public static void main(String[] args) throws Exception &#123;\n    DefaultMQProducer producer = new DefaultMQProducer(&quot;producer&quot;);\n    producer.setNamesrvAddr(&quot;127.0.0.1:9876&quot;);\n    producer.start();\n    Message msg = new Message(&quot;topic1&quot;, &quot;tag1&quot;, &quot;key1&quot;, (&quot;消息内容：aaaa&quot;).getBytes());\n    //必须自己实现MessageQueueSelector 保证消息进入同一个队列 arg 队列下标\t\n    SendResult sendResult = producer.send(msg,new MessageQueueSelector()&#123;\n        public MessageQueue select(List&lt;MessageQueue&gt; mqs, Message msg, Object arg) &#123;\n            return mqs.get((Integer)arg);\n        &#125;\n        \n    &#125;,0);\n    System.out.println(sendResult);\n    producer.shutdown();\n&#125;\n\n\npublic static void main(String[] args) throws MQClientException &#123;\n    DefaultMQPushConsumer consumer=new DefaultMQPushConsumer(&quot;consumer&quot;);\n    consumer.setNamesrvAddr(&quot;127.0.0.1:9876&quot;);\n    consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n    consumer.subscribe(&quot;topic1&quot;, &quot;*&quot;);\n    consumer.setConsumeThreadMin(10);\n    consumer.registerMessageListener(new MessageListenerOrderly() &#123;\n        public ConsumeOrderlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context) &#123;\n            for (MessageExt mes : msgs) &#123;\n                System.out.println(new String(mes.getBody()));\n            &#125;\n            return ConsumeOrderlyStatus.SUCCESS;\n        &#125;\n    &#125;);\n    consumer.start();\n&#125;\n\n顺序消息的实现：1.一组有顺序的消息必须放进同一个队列。\n         \t  2.一个消费者的一个线程只能接收一个队列的消息 消费者必须是实现，MessageListenerOrderly的监听。\n</code></pre>\n<p><strong><code>事务消息</code></strong></p>\n<pre><code>public static void main(String[] args) throws MQClientException &#123;\n    TransactionMQProducer producer = new TransactionMQProducer(&quot;producer&quot;);\n    producer.setNamesrvAddr(&quot;127.0.0.1:9876&quot;);\n    producer.setTransactionCheckListener(new TransactionCheckListener() &#123;\n        public LocalTransactionState checkLocalTransactionState(MessageExt msg) &#123;\n            return LocalTransactionState.COMMIT_MESSAGE;\n        &#125;\n    &#125;);\n    producer.start();\n    Message msg = new Message(&quot;TransactionTopic&quot;, &quot;tag1&quot;, &quot;key1&quot;, (&quot;消息: aaa a&quot;).getBytes());\n    SendResult sendResult = producer.sendMessageInTransaction(msg, new LocalTransactionExecuter() &#123;\n        public LocalTransactionState executeLocalTransactionBranch(Message msg, Object arg) &#123;\n            System.out.println(msg);\n            return LocalTransactionState.COMMIT_MESSAGE;\n        &#125;\n    &#125;, &quot;回调里的Object arg&quot;);\n    System.out.println(sendResult);\n    producer.shutdown();\n&#125;\n\npublic static void main(String[] args) throws MQClientException &#123;\n    MQConsumer consumer=new MQConsumer(&quot;consumer&quot;);\n    consumer.setNamesrvAddr(&quot;127.0.0.1:9876&quot;);\n    consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n    consumer.subscribe(&quot;TransactionTopic&quot;, &quot;*&quot;);\n    consumer.setMessageListener(new MessageListenerConcurrently() &#123;\n        public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context) &#123;\n            for (MessageExt mes : msgs) &#123;\n                System.out.println(new String(mes.getBody()));\n            &#125;\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        &#125;\n    &#125;);\n    consumer.start();\n&#125;\n</code></pre>\n<p><strong><code>MessageFilter过滤消息</code></strong></p>\n<pre><code>public static void main(String[] args) throws Exception &#123;\n    DefaultMQProducer producer = new DefaultMQProducer(&quot;producer&quot;);\n    producer.setNamesrvAddr(&quot;127.0.0.1:9876&quot;);\n    producer.start();\n    Message msg = new Message(&quot;topic1&quot;, &quot;tag1&quot;, &quot;key1&quot;, (&quot;mess body&quot;).getBytes());\n    SendResult sendResult = producer.send(msg);\n    System.out.println(sendResult);\n    producer.shutdown();\n&#125;\n\npublic static void main(String[] args) throws MQClientException &#123;\n    DefaultMQPushConsumer consumer=new DefaultMQPushConsumer(&quot;consumer&quot;);\n    consumer.setNamesrvAddr(&quot;127.0.0.1:9876&quot;);\n    consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n    String code = MixAll.file2String(&quot;H:/code/mq/src/main/java/rocketmq/apt/MesFilter.java&quot;);\n    consumer.subscribe(&quot;topic1&quot;,&quot;rocketmq.apt.MesFilter&quot;,code);\n    consumer.setConsumeThreadMin(10);\n    consumer.registerMessageListener(new MessageListenerConcurrently() &#123;\n        public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context) &#123;\n            for (MessageExt mes : msgs) &#123;\n                System.out.println(new String(mes.getBody()));\n            &#125;\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        &#125;\n    &#125;);\n    consumer.start();\n&#125;\n\npublic class MesFilter implements MessageFilter&#123;\n    public boolean match(MessageExt msg) &#123;\n        return false;//Determines whether this message is entered fileter\n    &#125;\n\n&#125;\n\n注意： MesFilter中不能有汉字\n</code></pre>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ol>\n<li>可能出现重复消息，消费先做判断。</li>\n<li>pull类消费,无重试机制（PullMessageService、DefaultMQPullConsumer）</li>\n<li>先启动提供者 消费者可能会一次拿多条消息。</li>\n<li>一定要先启动消费者，再启动生产者 可以避免很多问题。</li>\n<li>消费消息时：<br>1、若mq里有一堆消息那么消费者可能会批量消费 ，可以设置最大消费量为1限制。 （这样好返回消息失败状态，而不是批量状态。避免重复消费）<br>2、消费消息后 可以返回消息状态<br>3、没有返回消息状态的消息会不断重发 无次数限制。<br>4、若返回消息状态是稍后再试，会根据默认 1s、2s、5s…2h发送。<br>消息里有重试次数 （若不想一直重试，可以在重试 多少次后记录日志，返回成功标志。）<br>5、可以设置负载均很、</li>\n<li>先启动提供者 在启动 消费者1 在启动消费者2 可能重复消费（1在处理 没有返回，mq会再把消息发给 2）</li>\n</ol>\n<p>]()</p>\n","more":"<h1 id=\"RocketMq\"><a href=\"#RocketMq\" class=\"headerlink\" title=\"RocketMq\"></a>RocketMq</h1><hr>\n<h3 id=\"RocketMq-特色\"><a href=\"#RocketMq-特色\" class=\"headerlink\" title=\"RocketMq 特色\"></a>RocketMq 特色</h3><ol>\n<li>强大的消息重试机制</li>\n<li>支持 mqadmin 命令管理</li>\n<li>模式 多Master no slave、多Master 多 slave</li>\n<li>主从策略：同步双写，异步复制</li>\n<li>刷盘策略：同步刷盘，异步刷盘（是本节点内 index、 store,commitLong的数据同步）</li>\n</ol>\n<h3 id=\"RocketMq-与业术语\"><a href=\"#RocketMq-与业术语\" class=\"headerlink\" title=\"RocketMq 与业术语\"></a>RocketMq 与业术语</h3><ol>\n<li>Producer: 消息生产者，负责产生消息，一般由业务系统负责产生消息。</li>\n<li>Consumer: 消息消费者，负责消费消息，一般是后台系统负责异步消费。</li>\n<li>Push Consumer: Consumer 的一种，应用通常吐 Consumer 对象注册一个 Listener 接口，一旦收到消息，Consumer 对象立</li>\n<li>Push Consumer: Consumer 的一种，应用通常吐 Consumer 对象注册一个 Listener 接口，一旦收到消息，Consumer 对象立刻回调<br>Listener 接口方法。</li>\n<li>Pull Consumer: Consumer 的一种，应用通常主劢调用 Consumer 的拉消息方法从 Broker 拉消息，主劢权由应用控制。</li>\n<li>Producer Group: 一类 Producer 的集合名称，返类 Producer 通常収送一类消息，丏収送逡辑一致。</li>\n<li>Consumer Group 一类 Consumer 的集合名称，返类 Consumer 通常消费一类消息，丏消费逡辑一致。</li>\n<li>Broker: 消息中转角色，负责存储消息，转収消息，一般也称为 Server。在 JMS 规范中称为 Provider。</li>\n<li>广播消费: 一条消息被多个 Consumer 消费， 即使返些 Consumer 属亍同一个 Consumer Group， 消息也会被 Consumer Group 中的每个<br>Consumer 都消费一次， 广播消费中的 Consumer Group 概念可以讣为在消息划分方面无意义。在 CORBA Notification<br>规范中，消费方式都属亍广播消费。 项目开源主页：<a href=\"https://github.com/alibaba/RocketMQ\">https://github.com/alibaba/RocketMQ</a></li>\n<li>集群消费 一个 Consumer Group 中的 Consumer 实例平均分摊消费消息。例如某个 Topic 有 9 条消息，其中一个Consumer Group 有<br>3 个实例（可能是 3 个迕程，戒者 3 台机器） ，那举每个实例只消费其中的 3 条消息。在 CORBA Notification 规范中，无此消费方式。在<br>JMS 规范中，JMS point-to-point model 不乀类似，但是 RocketMQ 的集群消费功能大等亍 PTP 模型。<br>因为RocketMQ单个Consumer Group内的消费者类似亍PTP， 但是一个Topic&#x2F;Queue可以被多个Consumer<br>Group 消费。</li>\n<li>一个主题下默认有4个Quene 可以修改：p.createTopic</li>\n<li>主从实时：保证主节点挂了，也能及时消费该节点的数据，而不用等主节点恢复。</li>\n</ol>\n<h3 id=\"RocketMq发送消息例子\"><a href=\"#RocketMq发送消息例子\" class=\"headerlink\" title=\"RocketMq发送消息例子\"></a>RocketMq发送消息例子</h3><p><strong><code>普通消息</code></strong></p>\n<pre><code>public static void main(String[] args) throws Exception &#123;\n    DefaultMQProducer producer = new DefaultMQProducer(&quot;producer&quot;);\n    producer.setNamesrvAddr(&quot;127.0.0.1:9876&quot;);\n    producer.setRetryTimesWhenSendAsyncFailed(5);//失败重试次数\n    producer.start();\n    Message msg = new Message(&quot;topic1&quot;, &quot;tag1&quot;, &quot;key1&quot;, (&quot;mess body&quot;).getBytes());\n    SendResult sendResult = producer.send(msg);//发送失败 内部自动，重试没有抛异常即为成功。\n    System.out.println(sendResult);\n    producer.shutdown();\n&#125;\n\n\npublic static void main(String[] args) throws MQClientException &#123;\n    DefaultMQPushConsumer consumer=new DefaultMQPushConsumer(&quot;consumer&quot;);\n    consumer.setNamesrvAddr(&quot;127.0.0.1:9876&quot;);\n    consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n    consumer.subscribe(&quot;topic1&quot;, &quot;tag1|tag2|tag1&quot;);\n    consumer.registerMessageListener(new MessageListenerConcurrently() &#123;\n        public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context) &#123;\n            for (MessageExt mes : msgs) &#123;\n                System.out.println(new String(mes.getBody()));\n            &#125;\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        &#125;\n    &#125;);\n    consumer.start();\n&#125;\n</code></pre>\n<p><strong><code>顺序消息</code></strong></p>\n<pre><code>public static void main(String[] args) throws Exception &#123;\n    DefaultMQProducer producer = new DefaultMQProducer(&quot;producer&quot;);\n    producer.setNamesrvAddr(&quot;127.0.0.1:9876&quot;);\n    producer.start();\n    Message msg = new Message(&quot;topic1&quot;, &quot;tag1&quot;, &quot;key1&quot;, (&quot;消息内容：aaaa&quot;).getBytes());\n    //必须自己实现MessageQueueSelector 保证消息进入同一个队列 arg 队列下标\t\n    SendResult sendResult = producer.send(msg,new MessageQueueSelector()&#123;\n        public MessageQueue select(List&lt;MessageQueue&gt; mqs, Message msg, Object arg) &#123;\n            return mqs.get((Integer)arg);\n        &#125;\n        \n    &#125;,0);\n    System.out.println(sendResult);\n    producer.shutdown();\n&#125;\n\n\npublic static void main(String[] args) throws MQClientException &#123;\n    DefaultMQPushConsumer consumer=new DefaultMQPushConsumer(&quot;consumer&quot;);\n    consumer.setNamesrvAddr(&quot;127.0.0.1:9876&quot;);\n    consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n    consumer.subscribe(&quot;topic1&quot;, &quot;*&quot;);\n    consumer.setConsumeThreadMin(10);\n    consumer.registerMessageListener(new MessageListenerOrderly() &#123;\n        public ConsumeOrderlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context) &#123;\n            for (MessageExt mes : msgs) &#123;\n                System.out.println(new String(mes.getBody()));\n            &#125;\n            return ConsumeOrderlyStatus.SUCCESS;\n        &#125;\n    &#125;);\n    consumer.start();\n&#125;\n\n顺序消息的实现：1.一组有顺序的消息必须放进同一个队列。\n         \t  2.一个消费者的一个线程只能接收一个队列的消息 消费者必须是实现，MessageListenerOrderly的监听。\n</code></pre>\n<p><strong><code>事务消息</code></strong></p>\n<pre><code>public static void main(String[] args) throws MQClientException &#123;\n    TransactionMQProducer producer = new TransactionMQProducer(&quot;producer&quot;);\n    producer.setNamesrvAddr(&quot;127.0.0.1:9876&quot;);\n    producer.setTransactionCheckListener(new TransactionCheckListener() &#123;\n        public LocalTransactionState checkLocalTransactionState(MessageExt msg) &#123;\n            return LocalTransactionState.COMMIT_MESSAGE;\n        &#125;\n    &#125;);\n    producer.start();\n    Message msg = new Message(&quot;TransactionTopic&quot;, &quot;tag1&quot;, &quot;key1&quot;, (&quot;消息: aaa a&quot;).getBytes());\n    SendResult sendResult = producer.sendMessageInTransaction(msg, new LocalTransactionExecuter() &#123;\n        public LocalTransactionState executeLocalTransactionBranch(Message msg, Object arg) &#123;\n            System.out.println(msg);\n            return LocalTransactionState.COMMIT_MESSAGE;\n        &#125;\n    &#125;, &quot;回调里的Object arg&quot;);\n    System.out.println(sendResult);\n    producer.shutdown();\n&#125;\n\npublic static void main(String[] args) throws MQClientException &#123;\n    MQConsumer consumer=new MQConsumer(&quot;consumer&quot;);\n    consumer.setNamesrvAddr(&quot;127.0.0.1:9876&quot;);\n    consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n    consumer.subscribe(&quot;TransactionTopic&quot;, &quot;*&quot;);\n    consumer.setMessageListener(new MessageListenerConcurrently() &#123;\n        public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context) &#123;\n            for (MessageExt mes : msgs) &#123;\n                System.out.println(new String(mes.getBody()));\n            &#125;\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        &#125;\n    &#125;);\n    consumer.start();\n&#125;\n</code></pre>\n<p><strong><code>MessageFilter过滤消息</code></strong></p>\n<pre><code>public static void main(String[] args) throws Exception &#123;\n    DefaultMQProducer producer = new DefaultMQProducer(&quot;producer&quot;);\n    producer.setNamesrvAddr(&quot;127.0.0.1:9876&quot;);\n    producer.start();\n    Message msg = new Message(&quot;topic1&quot;, &quot;tag1&quot;, &quot;key1&quot;, (&quot;mess body&quot;).getBytes());\n    SendResult sendResult = producer.send(msg);\n    System.out.println(sendResult);\n    producer.shutdown();\n&#125;\n\npublic static void main(String[] args) throws MQClientException &#123;\n    DefaultMQPushConsumer consumer=new DefaultMQPushConsumer(&quot;consumer&quot;);\n    consumer.setNamesrvAddr(&quot;127.0.0.1:9876&quot;);\n    consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n    String code = MixAll.file2String(&quot;H:/code/mq/src/main/java/rocketmq/apt/MesFilter.java&quot;);\n    consumer.subscribe(&quot;topic1&quot;,&quot;rocketmq.apt.MesFilter&quot;,code);\n    consumer.setConsumeThreadMin(10);\n    consumer.registerMessageListener(new MessageListenerConcurrently() &#123;\n        public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context) &#123;\n            for (MessageExt mes : msgs) &#123;\n                System.out.println(new String(mes.getBody()));\n            &#125;\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        &#125;\n    &#125;);\n    consumer.start();\n&#125;\n\npublic class MesFilter implements MessageFilter&#123;\n    public boolean match(MessageExt msg) &#123;\n        return false;//Determines whether this message is entered fileter\n    &#125;\n\n&#125;\n\n注意： MesFilter中不能有汉字\n</code></pre>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ol>\n<li>可能出现重复消息，消费先做判断。</li>\n<li>pull类消费,无重试机制（PullMessageService、DefaultMQPullConsumer）</li>\n<li>先启动提供者 消费者可能会一次拿多条消息。</li>\n<li>一定要先启动消费者，再启动生产者 可以避免很多问题。</li>\n<li>消费消息时：<br>1、若mq里有一堆消息那么消费者可能会批量消费 ，可以设置最大消费量为1限制。 （这样好返回消息失败状态，而不是批量状态。避免重复消费）<br>2、消费消息后 可以返回消息状态<br>3、没有返回消息状态的消息会不断重发 无次数限制。<br>4、若返回消息状态是稍后再试，会根据默认 1s、2s、5s…2h发送。<br>消息里有重试次数 （若不想一直重试，可以在重试 多少次后记录日志，返回成功标志。）<br>5、可以设置负载均很、</li>\n<li>先启动提供者 在启动 消费者1 在启动消费者2 可能重复消费（1在处理 没有返回，mq会再把消息发给 2）</li>\n</ol>\n<p>]()</p>\n"},{"title":"zookeeper初步学习","excerpt":"ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等。Zookeeper是hadoop的一个子项目，其发展历程无需赘述。在分布式应用中，由于工程师不能很好地使用锁机制，以及基于消息的协调机制不适合在某些应用中使用，因此需要有一种可靠的、可扩展的、分布式的、可配置的协调机制来统一系统的状态。","date":"2017-09-12T01:00:00.000Z","_content":"\n## Zookeeper简介\n\n\tZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等。Zookeeper是hadoop的一个子项目，其发展历程无需赘述。在分布式应用中，由于工程师不能很好地使用锁机制，以及基于消息的协调机制不适合在某些应用中使用，因此需要有一种可靠的、可扩展的、分布式的、可配置的协调机制来统一系统的状态。\n\n----------\n\n## Zookeeper的基本概念\n\n**`1.角色`**\nZookeeper中的角色主要有以下三类，如下表所示：\n\n![](../images/zk/zk_1.jpg)\n\n**`2.特色`**\n\n1. 最终一致性：client不论连接到哪个Server，展示给它都是同一个视图，这是zookeeper最重要的性能。\n2. 可靠性：具有简单、健壮、良好的性能，如果消息m被到一台服务器接受，那么它将被所有的服务器接受。\n3.\n\n实时性：Zookeeper保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。但由于网络延时等原因，Zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()\n接口。\n\n4. 等待无关（wait-free）：慢的或者失效的client不得干预快速的client的请求，使得每个client都能有效的等待。\n5. 原子性：更新只能成功或者失败，没有中间状态。\n6. 顺序性：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。\n\n**`3.工作原理`**\n\nZookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。\n\n**`3.数据模型`**\n\n1. 层次化的目录结构，命名符合常规文件系统规范\n2. 每个节点在zookeeper中叫做znode,并且其有一个唯一的路径标识\n3. 节点Znode可以包含数据和子节点，但是EPHEMERAL类型的节点不能有子节点\n4. Znode中的数据可以有多个版本，比如某一个路径下存有多个数据版本，那么查询这个路径下的数据就需要带上版本\n5. Znode有两种类型，短暂的（ephemeral）和持久的（persistent）\n6. Znode的类型在创建时确定并且之后不能再修改\n7. 短暂znode的客户端会话结束时，zookeeper会将该短暂znode删除，短暂znode不可以有子节点\n8. 持久znode不依赖于客户端会话，只有当客户端明确要删除该持久znode时才会被删除\n9. Znode有四种形式的目录节点，PERSISTENT、PERSISTENT_SEQUENTIAL、EPHEMERAL、EPHEMERAL_SEQUENTIAL\n10. 数据只能存字节数组\n\n    每个znode由3部分组成:\n    1. stat. 此为状态信息, 描述该znode的版本, 权限等信息.\n    2. data. 与该znode关联的数据.\n    3. secondNode. 该znode下的子节点.\n\n## Zookeeper原生api列子\n\n\tpublic static void main(String[] args) throws Exception{\n\t\t/** zookeeper地址 */\n\t\tfinal String CONNECT_ADDR = \"192.168.80.88:2181,192.168.80.87:2181,192.168.80.86:2181\";\n\t\t/** session超时时间 */\n\t\tfinal int SESSION_OUTTIME = 2000;//ms \n\t\t/** 信号量，阻塞程序执行，用于等待zookeeper连接成功，发送成功信号 */\n\t\tfinal CountDownLatch connectedSemaphore = new CountDownLatch(1);\n\t\tZooKeeper zk = new ZooKeeper(CONNECT_ADDR, SESSION_OUTTIME, new Watcher(){\n\t\t\t@Override\n\t\t\tpublic void process(WatchedEvent event) {\n\t\t\t\t//获取事件的状态\n\t\t\t\tKeeperState keeperState = event.getState();\n\t\t\t\tEventType eventType = event.getType();\n\t\t\t\t//如果是建立连接\n\t\t\t\tif(KeeperState.SyncConnected == keeperState){\n\t\t\t\t\tif(EventType.None == eventType){\n\t\t\t\t\t\t//如果建立连接成功，则发送信号量，让后续阻塞程序向下执行\n\t\t\t\t\t\tconnectedSemaphore.countDown();\n\t\t\t\t\t\tSystem.out.println(\"zk 建立连接\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t//进行阻塞\n\t\tconnectedSemaphore.await();\n\t\t\n\t\t//创建父节点\n\t\tzk.create(\"/firstNode\", \"firstNode\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n\t\t\n\t\t//创建子节点\n\t\tzk.create(\"/firstNode/secondNode\", \"secondNode data\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n\t\t\n\t\t//获取节点洗信息\n\t\tbyte[] data = zk.getData(\"/firstNode\", true, null);\n\t\tSystem.out.println(new String(data));\n\t\tSystem.out.println(zk.getsecondNode(\"/firstNode\", true));\n\t\t\n\t\t//修改节点的值\n\t\tzk.setData(\"/firstNode\", \"modify data root\".getBytes(), -1);\n\t\tbyte[] data2 = zk.getData(\"/firstNode\", true, null);\n\t\tSystem.out.println(new String(data2));\t\t\n\t\t\n\t\t//判断节点是否存在\n\t\tSystem.out.println(zk.exists(\"/firstNode/secondNode\", true));\n\t\t//删除节点\n\t\tzk.delete(\"/firstNode/secondNode\", -1);\n\t\tSystem.out.println(zk.exists(\"/firstNode/secondNode\", true));\n\t\t\n\t\tzk.close();\n\t}\n\n\tstate=-112 会话超时状态\n\tstate= -113　认证失败状态\n\tstate=  1 连接建立中\n\tstate= 2 (暂时不清楚如何理解这个状态,ZOO_ASSOCIATING_STATE)\n\tstate=3 连接已建立状态\n\tstate= 999 无连接状态\n\t\n\t\n\ttype=1 创建节点事件\n\ttype=2 删除节点事件\n\ttype=3 更改节点事件\n\ttype=4 子节点列表变化事件\n\ttype= -1 会话session事件\n\ttype=-2 监控被移除事件\n\n对父节点的变更以及孙节点的变更都不会触发watcher，而对watcher本身节点以及子节点的变更会触发watcher，watcher是一次行需要重复注册，具体参照下表。\n![](../images/zk/zk_wa.png)\n\n## zkclient列子\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tfinal String CONNECT_ADDR = \"127.0.0.1:2181\";\n\t\tZkClient zkc = new ZkClient(new ZkConnection(CONNECT_ADDR), 5000);\n\n\t\t// 对父节点添加监听子节点变化。\n\t\tzkc.subscribeChildChanges(\"/node\", new IZkChildListener() {\n\t\t\t@Override\n\t\t\tpublic void handleChildChange(String parentPath, List<String> currentChilds) throws Exception {\n\t\t\t\tSystem.out.println(\"parentPath: \" + parentPath);\n\t\t\t\tSystem.out.println(\"currentChilds: \" + currentChilds);\n\t\t\t}\n\t\t});\n\t\tzkc.deleteRecursive(\"/node\");\n\t\tThread.sleep(3000);\n\n\t\tzkc.createPersistent(\"/node\");\n\t\tThread.sleep(1000);\n\n\t\tzkc.createPersistent(\"/node\" + \"/\" + \"node1\", \"node1内容\");\n\t\tThread.sleep(1000);\n\n\t\tzkc.createPersistent(\"/node\" + \"/\" + \"node2\", \"node2内容\");\n\t\tThread.sleep(1000);\n\n\t\tzkc.delete(\"/node/node2\");\n\t\tThread.sleep(1000);\n\n\t\tzkc.delete(\"/node/node2/node3\");\n\t\tThread.sleep(1000);\n\n\t\tzkc.deleteRecursive(\"/node\");\n\n\t}\n\n相比原生Api\n\n1. zkclient是在官方API上进行封装使用更简洁。\n2. zkclient可以递归的创建节点、递归的删除节点 没办法创建数据\n3. watcher 的改进避免重复注册监听\n\n    1. subscribeChildChanges只监听本节点或直接子节点创建、删除。\n    2. subscribeDataChanges 只监听本节点或直接子节点创建、删除、数据的改变。\n\n## curator列子\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tfinal String CONNECT_ADDR = \"127.0.0.1:2181\";\n\t\tfinal int SESSION_OUTTIME = 5000;\n\t\t//1 重试策略：初试时间为1s 重试10次\n\t\tRetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 10);\n\t\t//2 通过工厂创建连接\n\t\tCuratorFramework cf = CuratorFrameworkFactory.builder()\n\t\t\t\t\t.connectString(CONNECT_ADDR)\n\t\t\t\t\t.sessionTimeoutMs(SESSION_OUTTIME)\n\t\t\t\t\t.retryPolicy(retryPolicy)\n\t\t\t\t\t.build();\n\t\t\n\t\t//3 建立连接\n\t\tcf.start();\n\t\t//4 建立一个cache缓存\n\t\tfinal NodeCache cache = new NodeCache(cf, \"/firstNode\", false);\n\t\tcache.start(true);\n\t\t//触发事件为创建节点和更新节点，在删除节点的时候并不触发此操作。\n\t\tcache.getListenable().addListener(new NodeCacheListener() { \n\t\t\t@Override\n\t\t\tpublic void nodeChanged() throws Exception {\n\t\t\t\tSystem.out.println(\"路径为：\" + cache.getCurrentData().getPath());\n\t\t\t\tSystem.out.println(\"数据为：\" + new String(cache.getCurrentData().getData()));\n\t\t\t\tSystem.out.println(\"状态为：\" + cache.getCurrentData().getStat());\n\t\t\t}\n\t\t});\n\t\t\n\t\tThread.sleep(1000);\n\t\tcf.create().forPath(\"/firstNode\", \"123\".getBytes());\n\t\t\n\t\tThread.sleep(1000);\n\t\tcf.setData().forPath(\"/firstNode\", \"456\".getBytes());\n\t\t\n\t\tThread.sleep(1000);\n\t\tcf.delete().forPath(\"/firstNode\");\n\t\t\n\t\tThread.sleep(Integer.MAX_VALUE);\n\t\tcache.close();\n\t\tcf.close();\n\t}\n\n\n\n\tpublic static void main(String[] args) throws Exception {\n\t\t final String CONNECT_ADDR = \"127.0.0.1:2181\";\n\t\t final int SESSION_OUTTIME = 5000;\n\t\t//1 重试策略：初试时间为1s 重试10次\n\t\tRetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 10);\n\t\t//2 通过工厂创建连接\n\t\tCuratorFramework cf = CuratorFrameworkFactory.builder()\n\t\t\t\t\t.connectString(CONNECT_ADDR)\n\t\t\t\t\t.sessionTimeoutMs(SESSION_OUTTIME)\n\t\t\t\t\t.retryPolicy(retryPolicy)\n\t\t\t\t\t.build();\n\t\t//3 建立连接\n\t\tcf.start();\n\t\t//4 建立一个PathsecondNodeCache缓存,第三个参数为是否接受节点数据内容 如果为false则不接受\n\t\tPathsecondNodeCache cache = new PathsecondNodeCache(cf, \"/firstNode\", true);\n\t\t//5 在初始化的时候就进行缓存监听\n\t\tcache.start(StartMode.POST_INITIALIZED_EVENT);\n\t\t//监听子节点 新建、修改、删除\n\t\tcache.getListenable().addListener(new PathsecondNodeCacheListener() {\n\t\t\t@Override\n\t\t\tpublic void childEvent(CuratorFramework cf, PathsecondNodeCacheEvent event) throws Exception {\n\t\t\t\tswitch (event.getType()) {\n\t\t\t\tcase CHILD_ADDED:\n\t\t\t\t\tSystem.out.println(\"CHILD_ADDED :\" + event.getData().getPath());\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHILD_UPDATED:\n\t\t\t\t\tSystem.out.println(\"CHILD_UPDATED :\" + event.getData().getPath());\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHILD_REMOVED:\n\t\t\t\t\tSystem.out.println(\"CHILD_REMOVED :\" + event.getData().getPath());\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t//创建本身节点不发生变化\n\t\tcf.create().forPath(\"/firstNode\", \"init\".getBytes());\n\t\t\n\t\t//添加子节点\n\t\tThread.sleep(1000);\n\t\tcf.create().forPath(\"/firstNode/secondNode\", \"secondNode内容\".getBytes());\n\t\tThread.sleep(1000);\n\t\tcf.create().forPath(\"/firstNode/thirdNode\", \"thirdNode内容\".getBytes());\n\t\t\n\t\t//修改子节点\n\t\tThread.sleep(1000);\n\t\tcf.setData().forPath(\"/firstNode/secondNode\", \"secondNode更新内容\".getBytes());\n\t\t\n\t\t//删除子节点\n\t\tThread.sleep(1000);\n\t\tcf.delete().forPath(\"/firstNode/thirdNode\");\t\t\n\t\t\n\t\t//删除本身节点\n\t\tThread.sleep(1000);\n\t\tcf.delete().deletingsecondNodeIfNeeded().forPath(\"/firstNode\");\n\t\t\n\t\tThread.sleep(Integer.MAX_VALUE);\n\t\tcache.close();\n\t\tcf.close();\n\t}\n\n## curator在分布式方面的应用\n\n1. 分布式锁 InterProcessMutex\n\n   \t\tpublic static void main(String[] args) throws Exception {\n   \t\t\t//1 重试策略：初试时间为1s 重试10次\n   \t\t\tRetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 10);\n   \t\t\t//2 通过工厂创建连接\n   \t\t\tCuratorFramework cf = CuratorFrameworkFactory.builder()\n   \t\t\t\t\t\t.connectString(\"127.0.0.1:2181\")\n   \t\t\t\t\t\t.sessionTimeoutMs(5000)\n   \t\t\t\t\t\t.retryPolicy(retryPolicy)\n   \t\t\t\t\t\t.build();\n   \t\t\t//3 开启连接\n   \t\t\tcf.start();\n   \t\t\t//4 分布式锁\n   \t\t\tfinal InterProcessMutex lock = new InterProcessMutex(cf, \"/firstNode\");\n   \t\t\tfor(int i = 0; i < 10; i++){\n   \t\t\t\tnew Thread(new Runnable() {\n   \t\t\t\t\t@Override\n   \t\t\t\t\tpublic void run() {\n   \t\t\t\t\t\ttry {\n   \t\t\t\t\t\t\t//加锁\n   \t\t\t\t\t\t\tlock.acquire();\n   \t\t\t\t\t\t\tSimpleDateFormat sdf = new SimpleDateFormat(\"HH:mm:ss|SSS\");\n   \t\t\t\t\t\t\tSystem.err.println(sdf);\n   \t\t\t\t\t\t} catch (Exception e) {\n   \t\t\t\t\t\t\te.printStackTrace();\n   \t\t\t\t\t\t} finally {\n   \t\t\t\t\t\t\ttry {\n   \t\t\t\t\t\t\t\tlock.release();\n   \t\t\t\t\t\t\t} catch (Exception e) {\n   \t\t\t\t\t\t\t\te.printStackTrace();\n   \t\t\t\t\t\t\t}\n   \t\t\t\t\t\t}\n   \t\t\t\t\t}\n   \t\t\t\t},\"t\" + i).start();\n   \t\t\t}\n   \t\t\tThread.sleep(100000);\n   \t\t\tcf.close();\n   \t\t}\n\n`InterProcessMutex 与 Semaphore semaphore=new Semaphore(1);功能相似`\n\n1. DistributedDoubleBarrier\n\n   \tpublic static void main(String[] args) throws Exception {\n   \t\tfor(int i = 0; i < 5; i++){\n   \t\t\tnew Thread(new Runnable() {\n   \t\t\t\t@Override\n   \t\t\t\tpublic void run() {\n   \t\t\t\t\ttry {\n   \t\t\t\t\t\tRetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 10);\n   \t\t\t\t\t\tCuratorFramework cf = CuratorFrameworkFactory.builder()\n   \t\t\t\t\t\t\t\t\t.connectString(\"127.0.0.1:2181\")\n   \t\t\t\t\t\t\t\t\t.retryPolicy(retryPolicy)\n   \t\t\t\t\t\t\t\t\t.build();\n   \t\t\t\t\t\tcf.start();\n   \t\t\t\t\t\tDistributedDoubleBarrier barrier = new DistributedDoubleBarrier(cf, \"/firstNode\", 5);\n   \t\t\t\t\t\tThread.sleep(1000 * (new Random()).nextInt(3)); \n   \t\t\t\t\t\tSystem.out.println(Thread.currentThread().getName() + \"已经准备\");\n   \t\t\t\t\t\tbarrier.enter();\n   \t\t\t\t\t\tSystem.out.println(\"同时开始运行...\");\n   \t\t\t\t\t\tThread.sleep(1000 * (new Random()).nextInt(3));\n   \t\t\t\t\t\tSystem.out.println(Thread.currentThread().getName() + \"运行完毕\");\n   \t\t\t\t\t\tbarrier.leave();\n   \t\t\t\t\t\tSystem.out.println(\"同时退出运行...\");\n   \t\t\t\t\t} catch (Exception e) {\n   \t\t\t\t\t\te.printStackTrace();\n   \t\t\t\t\t}\n   \t\t\t\t}\n   \t\t\t},\"t\" + i).start();\n   \t\t}\n   \t}\n\n`DistributedDoubleBarrier 与 CyclicBarrier cyclicBarrier=new CyclicBarrier(n);功能相似`\n\n1. DistributedBarrier\n\n   \tpublic static void main(String[] args) throws Exception {\n   \t\tfor(int i = 0; i < 5; i++){\n   \t\t\tnew Thread(new Runnable() {\n   \t\t\t\t@Override\n   \t\t\t\tpublic void run() {\n   \t\t\t\t\ttry {\n   \t\t\t\t\t\tRetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 10);\n   \t\t\t\t\t\tCuratorFramework cf = CuratorFrameworkFactory.builder()\n   \t\t\t\t\t\t\t\t\t.connectString(\"127.0.0.1:2181\")\n   \t\t\t\t\t\t\t\t\t.sessionTimeoutMs(5000)\n   \t\t\t\t\t\t\t\t\t.retryPolicy(retryPolicy)\n   \t\t\t\t\t\t\t\t\t.build();\n   \t\t\t\t\t\tcf.start();\n   \t\t\t\t\t\tDistributedBarrier barrier = new DistributedBarrier(cf, \"/firstNode\");\n   \t\t\t\t\t\tSystem.out.println(Thread.currentThread().getName() + \"设置barrier!\");\n   \t\t\t\t\t\tbarrier.setBarrier();\t\t//设置\n   \t\t\t\t\t\tbarrier.waitOnBarrier();\t//等待\n   \t\t\t\t\t\tSystem.out.println(\"---------开始执行程序----------\");\n   \t\t\t\t\t} catch (Exception e) {\n   \t\t\t\t\t\te.printStackTrace();\n   \t\t\t\t\t}\n   \t\t\t\t}\n   \t\t\t},\"t\" + i).start();\n   \t\t}\n\n   \t\tThread.sleep(5000);\n   \t\t\n   \t\tRetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 10);\n   \t\tCuratorFramework cf = CuratorFrameworkFactory.builder()\n   \t\t\t\t\t.connectString(CONNECT_ADDR)\n   \t\t\t\t\t.sessionTimeoutMs(SESSION_OUTTIME)\n   \t\t\t\t\t.retryPolicy(retryPolicy)\n   \t\t\t\t\t.build();\n   \t\tcf.start();\n   \t\tDistributedBarrier barrier = new DistributedBarrier(cf, \"/firstNode\");\n   \t\tbarrier.removeBarrier();\t//释放\n   \t}\n\n`DistributedBarrier 与 CountDownLatch countDownLatch=new CountDownLatch(1);功能相似`\n\n1. DistributedAtomicInteger 分布式原子性\n\n   \tpublic static void main(String[] args) throws Exception {\n   \t\t//1 重试策略：初试时间为1s 重试10次\n   \t\tRetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 10);\n   \t\t//2 通过工厂创建连接\n   \t\tCuratorFramework cf = CuratorFrameworkFactory.builder()\n   \t\t\t\t\t.connectString(\"127.0.0.1:2181\")\n   \t\t\t\t\t.sessionTimeoutMs(5000)\n   \t\t\t\t\t.retryPolicy(retryPolicy)\n   \t\t\t\t\t.build();\n   \t\t//3 开启连接\n   \t\tcf.start();\n   \t\tcf.delete().forPath(\"/firstNode\");\n   \t\t\n\n   \t\t//4 使用DistributedAtomicInteger\n   \t\tDistributedAtomicInteger atomicIntger = \n   \t\t\t\tnew DistributedAtomicInteger(cf, \"/firstNode\", new RetryNTimes(3, 1000));\n   \t\t\n   \t\tAtomicValue<Integer> value = atomicIntger.add(1);\n   \t\tSystem.out.println(value.succeeded());\n   \t\tSystem.out.println(value.postValue());\t//最新值\n   \t\tSystem.out.println(value.preValue());\t//原始值\n   \t\t\n   \t}\n\n\n1. 可以实现类“发布、订阅”功能\n\n   PathsecondNodeCache cache = new PathsecondNodeCache(cf, \"topic\", true);\n   cache.start(StartMode.POST_INITIALIZED_EVENT);\n   cache.getListenable().addListener(new PathsecondNodeCacheListener() ｛｝\n   //离线在上线，也可以收到 期间的事件。\n\n**`curator 也是基于官方API封装，其语法支持链式编程，API更贴合开发人员思维，特别在分布式并发方面相当给力，建议使用curator。`**\n\n## maven坐标\n\n\t\t<dependency>\n\t\t    <groupId>org.apache.zookeeper</groupId>\n\t\t    <artifactId>zookeeper</artifactId>\n\t\t    <version>3.5.3-beta</version>\n\t\t    <type>pom</type>\n\t\t</dependency>\n\t\t\n\t\t\n\t\t<dependency>\n\t\t    <groupId>com.101tec</groupId>\n\t\t    <artifactId>zkclient</artifactId>\n\t\t    <version>0.9</version>\n\t\t</dependency>\n\n\n\t\t<dependency>\n\t\t    <groupId>org.apache.curator</groupId>\n\t\t    <artifactId>curator-framework</artifactId>\n\t\t    <version>4.0.0</version>\n\t\t</dependency>\n\t\t<dependency>\n\t\t    <groupId>org.apache.curator</groupId>\n\t\t    <artifactId>curator-recipes</artifactId>\n\t\t    <version>4.0.0</version>\n\t\t</dependency>\n\t\t]()","source":"_posts/zookeeper初步学习.md","raw":"---\ntitle: \"zookeeper初步学习\"\nexcerpt: ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等。Zookeeper是hadoop的一个子项目，其发展历程无需赘述。在分布式应用中，由于工程师不能很好地使用锁机制，以及基于消息的协调机制不适合在某些应用中使用，因此需要有一种可靠的、可扩展的、分布式的、可配置的协调机制来统一系统的状态。\ndate: 2017-09-12 09:00:00\ncategories: zookeeper\ntags:\n  - zookeeper\n---\n\n## Zookeeper简介\n\n\tZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等。Zookeeper是hadoop的一个子项目，其发展历程无需赘述。在分布式应用中，由于工程师不能很好地使用锁机制，以及基于消息的协调机制不适合在某些应用中使用，因此需要有一种可靠的、可扩展的、分布式的、可配置的协调机制来统一系统的状态。\n\n----------\n\n## Zookeeper的基本概念\n\n**`1.角色`**\nZookeeper中的角色主要有以下三类，如下表所示：\n\n![](../images/zk/zk_1.jpg)\n\n**`2.特色`**\n\n1. 最终一致性：client不论连接到哪个Server，展示给它都是同一个视图，这是zookeeper最重要的性能。\n2. 可靠性：具有简单、健壮、良好的性能，如果消息m被到一台服务器接受，那么它将被所有的服务器接受。\n3.\n\n实时性：Zookeeper保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。但由于网络延时等原因，Zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()\n接口。\n\n4. 等待无关（wait-free）：慢的或者失效的client不得干预快速的client的请求，使得每个client都能有效的等待。\n5. 原子性：更新只能成功或者失败，没有中间状态。\n6. 顺序性：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。\n\n**`3.工作原理`**\n\nZookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。\n\n**`3.数据模型`**\n\n1. 层次化的目录结构，命名符合常规文件系统规范\n2. 每个节点在zookeeper中叫做znode,并且其有一个唯一的路径标识\n3. 节点Znode可以包含数据和子节点，但是EPHEMERAL类型的节点不能有子节点\n4. Znode中的数据可以有多个版本，比如某一个路径下存有多个数据版本，那么查询这个路径下的数据就需要带上版本\n5. Znode有两种类型，短暂的（ephemeral）和持久的（persistent）\n6. Znode的类型在创建时确定并且之后不能再修改\n7. 短暂znode的客户端会话结束时，zookeeper会将该短暂znode删除，短暂znode不可以有子节点\n8. 持久znode不依赖于客户端会话，只有当客户端明确要删除该持久znode时才会被删除\n9. Znode有四种形式的目录节点，PERSISTENT、PERSISTENT_SEQUENTIAL、EPHEMERAL、EPHEMERAL_SEQUENTIAL\n10. 数据只能存字节数组\n\n    每个znode由3部分组成:\n    1. stat. 此为状态信息, 描述该znode的版本, 权限等信息.\n    2. data. 与该znode关联的数据.\n    3. secondNode. 该znode下的子节点.\n\n## Zookeeper原生api列子\n\n\tpublic static void main(String[] args) throws Exception{\n\t\t/** zookeeper地址 */\n\t\tfinal String CONNECT_ADDR = \"192.168.80.88:2181,192.168.80.87:2181,192.168.80.86:2181\";\n\t\t/** session超时时间 */\n\t\tfinal int SESSION_OUTTIME = 2000;//ms \n\t\t/** 信号量，阻塞程序执行，用于等待zookeeper连接成功，发送成功信号 */\n\t\tfinal CountDownLatch connectedSemaphore = new CountDownLatch(1);\n\t\tZooKeeper zk = new ZooKeeper(CONNECT_ADDR, SESSION_OUTTIME, new Watcher(){\n\t\t\t@Override\n\t\t\tpublic void process(WatchedEvent event) {\n\t\t\t\t//获取事件的状态\n\t\t\t\tKeeperState keeperState = event.getState();\n\t\t\t\tEventType eventType = event.getType();\n\t\t\t\t//如果是建立连接\n\t\t\t\tif(KeeperState.SyncConnected == keeperState){\n\t\t\t\t\tif(EventType.None == eventType){\n\t\t\t\t\t\t//如果建立连接成功，则发送信号量，让后续阻塞程序向下执行\n\t\t\t\t\t\tconnectedSemaphore.countDown();\n\t\t\t\t\t\tSystem.out.println(\"zk 建立连接\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t//进行阻塞\n\t\tconnectedSemaphore.await();\n\t\t\n\t\t//创建父节点\n\t\tzk.create(\"/firstNode\", \"firstNode\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n\t\t\n\t\t//创建子节点\n\t\tzk.create(\"/firstNode/secondNode\", \"secondNode data\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n\t\t\n\t\t//获取节点洗信息\n\t\tbyte[] data = zk.getData(\"/firstNode\", true, null);\n\t\tSystem.out.println(new String(data));\n\t\tSystem.out.println(zk.getsecondNode(\"/firstNode\", true));\n\t\t\n\t\t//修改节点的值\n\t\tzk.setData(\"/firstNode\", \"modify data root\".getBytes(), -1);\n\t\tbyte[] data2 = zk.getData(\"/firstNode\", true, null);\n\t\tSystem.out.println(new String(data2));\t\t\n\t\t\n\t\t//判断节点是否存在\n\t\tSystem.out.println(zk.exists(\"/firstNode/secondNode\", true));\n\t\t//删除节点\n\t\tzk.delete(\"/firstNode/secondNode\", -1);\n\t\tSystem.out.println(zk.exists(\"/firstNode/secondNode\", true));\n\t\t\n\t\tzk.close();\n\t}\n\n\tstate=-112 会话超时状态\n\tstate= -113　认证失败状态\n\tstate=  1 连接建立中\n\tstate= 2 (暂时不清楚如何理解这个状态,ZOO_ASSOCIATING_STATE)\n\tstate=3 连接已建立状态\n\tstate= 999 无连接状态\n\t\n\t\n\ttype=1 创建节点事件\n\ttype=2 删除节点事件\n\ttype=3 更改节点事件\n\ttype=4 子节点列表变化事件\n\ttype= -1 会话session事件\n\ttype=-2 监控被移除事件\n\n对父节点的变更以及孙节点的变更都不会触发watcher，而对watcher本身节点以及子节点的变更会触发watcher，watcher是一次行需要重复注册，具体参照下表。\n![](../images/zk/zk_wa.png)\n\n## zkclient列子\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tfinal String CONNECT_ADDR = \"127.0.0.1:2181\";\n\t\tZkClient zkc = new ZkClient(new ZkConnection(CONNECT_ADDR), 5000);\n\n\t\t// 对父节点添加监听子节点变化。\n\t\tzkc.subscribeChildChanges(\"/node\", new IZkChildListener() {\n\t\t\t@Override\n\t\t\tpublic void handleChildChange(String parentPath, List<String> currentChilds) throws Exception {\n\t\t\t\tSystem.out.println(\"parentPath: \" + parentPath);\n\t\t\t\tSystem.out.println(\"currentChilds: \" + currentChilds);\n\t\t\t}\n\t\t});\n\t\tzkc.deleteRecursive(\"/node\");\n\t\tThread.sleep(3000);\n\n\t\tzkc.createPersistent(\"/node\");\n\t\tThread.sleep(1000);\n\n\t\tzkc.createPersistent(\"/node\" + \"/\" + \"node1\", \"node1内容\");\n\t\tThread.sleep(1000);\n\n\t\tzkc.createPersistent(\"/node\" + \"/\" + \"node2\", \"node2内容\");\n\t\tThread.sleep(1000);\n\n\t\tzkc.delete(\"/node/node2\");\n\t\tThread.sleep(1000);\n\n\t\tzkc.delete(\"/node/node2/node3\");\n\t\tThread.sleep(1000);\n\n\t\tzkc.deleteRecursive(\"/node\");\n\n\t}\n\n相比原生Api\n\n1. zkclient是在官方API上进行封装使用更简洁。\n2. zkclient可以递归的创建节点、递归的删除节点 没办法创建数据\n3. watcher 的改进避免重复注册监听\n\n    1. subscribeChildChanges只监听本节点或直接子节点创建、删除。\n    2. subscribeDataChanges 只监听本节点或直接子节点创建、删除、数据的改变。\n\n## curator列子\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tfinal String CONNECT_ADDR = \"127.0.0.1:2181\";\n\t\tfinal int SESSION_OUTTIME = 5000;\n\t\t//1 重试策略：初试时间为1s 重试10次\n\t\tRetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 10);\n\t\t//2 通过工厂创建连接\n\t\tCuratorFramework cf = CuratorFrameworkFactory.builder()\n\t\t\t\t\t.connectString(CONNECT_ADDR)\n\t\t\t\t\t.sessionTimeoutMs(SESSION_OUTTIME)\n\t\t\t\t\t.retryPolicy(retryPolicy)\n\t\t\t\t\t.build();\n\t\t\n\t\t//3 建立连接\n\t\tcf.start();\n\t\t//4 建立一个cache缓存\n\t\tfinal NodeCache cache = new NodeCache(cf, \"/firstNode\", false);\n\t\tcache.start(true);\n\t\t//触发事件为创建节点和更新节点，在删除节点的时候并不触发此操作。\n\t\tcache.getListenable().addListener(new NodeCacheListener() { \n\t\t\t@Override\n\t\t\tpublic void nodeChanged() throws Exception {\n\t\t\t\tSystem.out.println(\"路径为：\" + cache.getCurrentData().getPath());\n\t\t\t\tSystem.out.println(\"数据为：\" + new String(cache.getCurrentData().getData()));\n\t\t\t\tSystem.out.println(\"状态为：\" + cache.getCurrentData().getStat());\n\t\t\t}\n\t\t});\n\t\t\n\t\tThread.sleep(1000);\n\t\tcf.create().forPath(\"/firstNode\", \"123\".getBytes());\n\t\t\n\t\tThread.sleep(1000);\n\t\tcf.setData().forPath(\"/firstNode\", \"456\".getBytes());\n\t\t\n\t\tThread.sleep(1000);\n\t\tcf.delete().forPath(\"/firstNode\");\n\t\t\n\t\tThread.sleep(Integer.MAX_VALUE);\n\t\tcache.close();\n\t\tcf.close();\n\t}\n\n\n\n\tpublic static void main(String[] args) throws Exception {\n\t\t final String CONNECT_ADDR = \"127.0.0.1:2181\";\n\t\t final int SESSION_OUTTIME = 5000;\n\t\t//1 重试策略：初试时间为1s 重试10次\n\t\tRetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 10);\n\t\t//2 通过工厂创建连接\n\t\tCuratorFramework cf = CuratorFrameworkFactory.builder()\n\t\t\t\t\t.connectString(CONNECT_ADDR)\n\t\t\t\t\t.sessionTimeoutMs(SESSION_OUTTIME)\n\t\t\t\t\t.retryPolicy(retryPolicy)\n\t\t\t\t\t.build();\n\t\t//3 建立连接\n\t\tcf.start();\n\t\t//4 建立一个PathsecondNodeCache缓存,第三个参数为是否接受节点数据内容 如果为false则不接受\n\t\tPathsecondNodeCache cache = new PathsecondNodeCache(cf, \"/firstNode\", true);\n\t\t//5 在初始化的时候就进行缓存监听\n\t\tcache.start(StartMode.POST_INITIALIZED_EVENT);\n\t\t//监听子节点 新建、修改、删除\n\t\tcache.getListenable().addListener(new PathsecondNodeCacheListener() {\n\t\t\t@Override\n\t\t\tpublic void childEvent(CuratorFramework cf, PathsecondNodeCacheEvent event) throws Exception {\n\t\t\t\tswitch (event.getType()) {\n\t\t\t\tcase CHILD_ADDED:\n\t\t\t\t\tSystem.out.println(\"CHILD_ADDED :\" + event.getData().getPath());\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHILD_UPDATED:\n\t\t\t\t\tSystem.out.println(\"CHILD_UPDATED :\" + event.getData().getPath());\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHILD_REMOVED:\n\t\t\t\t\tSystem.out.println(\"CHILD_REMOVED :\" + event.getData().getPath());\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t//创建本身节点不发生变化\n\t\tcf.create().forPath(\"/firstNode\", \"init\".getBytes());\n\t\t\n\t\t//添加子节点\n\t\tThread.sleep(1000);\n\t\tcf.create().forPath(\"/firstNode/secondNode\", \"secondNode内容\".getBytes());\n\t\tThread.sleep(1000);\n\t\tcf.create().forPath(\"/firstNode/thirdNode\", \"thirdNode内容\".getBytes());\n\t\t\n\t\t//修改子节点\n\t\tThread.sleep(1000);\n\t\tcf.setData().forPath(\"/firstNode/secondNode\", \"secondNode更新内容\".getBytes());\n\t\t\n\t\t//删除子节点\n\t\tThread.sleep(1000);\n\t\tcf.delete().forPath(\"/firstNode/thirdNode\");\t\t\n\t\t\n\t\t//删除本身节点\n\t\tThread.sleep(1000);\n\t\tcf.delete().deletingsecondNodeIfNeeded().forPath(\"/firstNode\");\n\t\t\n\t\tThread.sleep(Integer.MAX_VALUE);\n\t\tcache.close();\n\t\tcf.close();\n\t}\n\n## curator在分布式方面的应用\n\n1. 分布式锁 InterProcessMutex\n\n   \t\tpublic static void main(String[] args) throws Exception {\n   \t\t\t//1 重试策略：初试时间为1s 重试10次\n   \t\t\tRetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 10);\n   \t\t\t//2 通过工厂创建连接\n   \t\t\tCuratorFramework cf = CuratorFrameworkFactory.builder()\n   \t\t\t\t\t\t.connectString(\"127.0.0.1:2181\")\n   \t\t\t\t\t\t.sessionTimeoutMs(5000)\n   \t\t\t\t\t\t.retryPolicy(retryPolicy)\n   \t\t\t\t\t\t.build();\n   \t\t\t//3 开启连接\n   \t\t\tcf.start();\n   \t\t\t//4 分布式锁\n   \t\t\tfinal InterProcessMutex lock = new InterProcessMutex(cf, \"/firstNode\");\n   \t\t\tfor(int i = 0; i < 10; i++){\n   \t\t\t\tnew Thread(new Runnable() {\n   \t\t\t\t\t@Override\n   \t\t\t\t\tpublic void run() {\n   \t\t\t\t\t\ttry {\n   \t\t\t\t\t\t\t//加锁\n   \t\t\t\t\t\t\tlock.acquire();\n   \t\t\t\t\t\t\tSimpleDateFormat sdf = new SimpleDateFormat(\"HH:mm:ss|SSS\");\n   \t\t\t\t\t\t\tSystem.err.println(sdf);\n   \t\t\t\t\t\t} catch (Exception e) {\n   \t\t\t\t\t\t\te.printStackTrace();\n   \t\t\t\t\t\t} finally {\n   \t\t\t\t\t\t\ttry {\n   \t\t\t\t\t\t\t\tlock.release();\n   \t\t\t\t\t\t\t} catch (Exception e) {\n   \t\t\t\t\t\t\t\te.printStackTrace();\n   \t\t\t\t\t\t\t}\n   \t\t\t\t\t\t}\n   \t\t\t\t\t}\n   \t\t\t\t},\"t\" + i).start();\n   \t\t\t}\n   \t\t\tThread.sleep(100000);\n   \t\t\tcf.close();\n   \t\t}\n\n`InterProcessMutex 与 Semaphore semaphore=new Semaphore(1);功能相似`\n\n1. DistributedDoubleBarrier\n\n   \tpublic static void main(String[] args) throws Exception {\n   \t\tfor(int i = 0; i < 5; i++){\n   \t\t\tnew Thread(new Runnable() {\n   \t\t\t\t@Override\n   \t\t\t\tpublic void run() {\n   \t\t\t\t\ttry {\n   \t\t\t\t\t\tRetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 10);\n   \t\t\t\t\t\tCuratorFramework cf = CuratorFrameworkFactory.builder()\n   \t\t\t\t\t\t\t\t\t.connectString(\"127.0.0.1:2181\")\n   \t\t\t\t\t\t\t\t\t.retryPolicy(retryPolicy)\n   \t\t\t\t\t\t\t\t\t.build();\n   \t\t\t\t\t\tcf.start();\n   \t\t\t\t\t\tDistributedDoubleBarrier barrier = new DistributedDoubleBarrier(cf, \"/firstNode\", 5);\n   \t\t\t\t\t\tThread.sleep(1000 * (new Random()).nextInt(3)); \n   \t\t\t\t\t\tSystem.out.println(Thread.currentThread().getName() + \"已经准备\");\n   \t\t\t\t\t\tbarrier.enter();\n   \t\t\t\t\t\tSystem.out.println(\"同时开始运行...\");\n   \t\t\t\t\t\tThread.sleep(1000 * (new Random()).nextInt(3));\n   \t\t\t\t\t\tSystem.out.println(Thread.currentThread().getName() + \"运行完毕\");\n   \t\t\t\t\t\tbarrier.leave();\n   \t\t\t\t\t\tSystem.out.println(\"同时退出运行...\");\n   \t\t\t\t\t} catch (Exception e) {\n   \t\t\t\t\t\te.printStackTrace();\n   \t\t\t\t\t}\n   \t\t\t\t}\n   \t\t\t},\"t\" + i).start();\n   \t\t}\n   \t}\n\n`DistributedDoubleBarrier 与 CyclicBarrier cyclicBarrier=new CyclicBarrier(n);功能相似`\n\n1. DistributedBarrier\n\n   \tpublic static void main(String[] args) throws Exception {\n   \t\tfor(int i = 0; i < 5; i++){\n   \t\t\tnew Thread(new Runnable() {\n   \t\t\t\t@Override\n   \t\t\t\tpublic void run() {\n   \t\t\t\t\ttry {\n   \t\t\t\t\t\tRetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 10);\n   \t\t\t\t\t\tCuratorFramework cf = CuratorFrameworkFactory.builder()\n   \t\t\t\t\t\t\t\t\t.connectString(\"127.0.0.1:2181\")\n   \t\t\t\t\t\t\t\t\t.sessionTimeoutMs(5000)\n   \t\t\t\t\t\t\t\t\t.retryPolicy(retryPolicy)\n   \t\t\t\t\t\t\t\t\t.build();\n   \t\t\t\t\t\tcf.start();\n   \t\t\t\t\t\tDistributedBarrier barrier = new DistributedBarrier(cf, \"/firstNode\");\n   \t\t\t\t\t\tSystem.out.println(Thread.currentThread().getName() + \"设置barrier!\");\n   \t\t\t\t\t\tbarrier.setBarrier();\t\t//设置\n   \t\t\t\t\t\tbarrier.waitOnBarrier();\t//等待\n   \t\t\t\t\t\tSystem.out.println(\"---------开始执行程序----------\");\n   \t\t\t\t\t} catch (Exception e) {\n   \t\t\t\t\t\te.printStackTrace();\n   \t\t\t\t\t}\n   \t\t\t\t}\n   \t\t\t},\"t\" + i).start();\n   \t\t}\n\n   \t\tThread.sleep(5000);\n   \t\t\n   \t\tRetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 10);\n   \t\tCuratorFramework cf = CuratorFrameworkFactory.builder()\n   \t\t\t\t\t.connectString(CONNECT_ADDR)\n   \t\t\t\t\t.sessionTimeoutMs(SESSION_OUTTIME)\n   \t\t\t\t\t.retryPolicy(retryPolicy)\n   \t\t\t\t\t.build();\n   \t\tcf.start();\n   \t\tDistributedBarrier barrier = new DistributedBarrier(cf, \"/firstNode\");\n   \t\tbarrier.removeBarrier();\t//释放\n   \t}\n\n`DistributedBarrier 与 CountDownLatch countDownLatch=new CountDownLatch(1);功能相似`\n\n1. DistributedAtomicInteger 分布式原子性\n\n   \tpublic static void main(String[] args) throws Exception {\n   \t\t//1 重试策略：初试时间为1s 重试10次\n   \t\tRetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 10);\n   \t\t//2 通过工厂创建连接\n   \t\tCuratorFramework cf = CuratorFrameworkFactory.builder()\n   \t\t\t\t\t.connectString(\"127.0.0.1:2181\")\n   \t\t\t\t\t.sessionTimeoutMs(5000)\n   \t\t\t\t\t.retryPolicy(retryPolicy)\n   \t\t\t\t\t.build();\n   \t\t//3 开启连接\n   \t\tcf.start();\n   \t\tcf.delete().forPath(\"/firstNode\");\n   \t\t\n\n   \t\t//4 使用DistributedAtomicInteger\n   \t\tDistributedAtomicInteger atomicIntger = \n   \t\t\t\tnew DistributedAtomicInteger(cf, \"/firstNode\", new RetryNTimes(3, 1000));\n   \t\t\n   \t\tAtomicValue<Integer> value = atomicIntger.add(1);\n   \t\tSystem.out.println(value.succeeded());\n   \t\tSystem.out.println(value.postValue());\t//最新值\n   \t\tSystem.out.println(value.preValue());\t//原始值\n   \t\t\n   \t}\n\n\n1. 可以实现类“发布、订阅”功能\n\n   PathsecondNodeCache cache = new PathsecondNodeCache(cf, \"topic\", true);\n   cache.start(StartMode.POST_INITIALIZED_EVENT);\n   cache.getListenable().addListener(new PathsecondNodeCacheListener() ｛｝\n   //离线在上线，也可以收到 期间的事件。\n\n**`curator 也是基于官方API封装，其语法支持链式编程，API更贴合开发人员思维，特别在分布式并发方面相当给力，建议使用curator。`**\n\n## maven坐标\n\n\t\t<dependency>\n\t\t    <groupId>org.apache.zookeeper</groupId>\n\t\t    <artifactId>zookeeper</artifactId>\n\t\t    <version>3.5.3-beta</version>\n\t\t    <type>pom</type>\n\t\t</dependency>\n\t\t\n\t\t\n\t\t<dependency>\n\t\t    <groupId>com.101tec</groupId>\n\t\t    <artifactId>zkclient</artifactId>\n\t\t    <version>0.9</version>\n\t\t</dependency>\n\n\n\t\t<dependency>\n\t\t    <groupId>org.apache.curator</groupId>\n\t\t    <artifactId>curator-framework</artifactId>\n\t\t    <version>4.0.0</version>\n\t\t</dependency>\n\t\t<dependency>\n\t\t    <groupId>org.apache.curator</groupId>\n\t\t    <artifactId>curator-recipes</artifactId>\n\t\t    <version>4.0.0</version>\n\t\t</dependency>\n\t\t]()","slug":"zookeeper初步学习","published":1,"updated":"2024-11-27T03:40:43.069Z","_id":"cm3zc7fkp0006l8u6566c68js","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"Zookeeper简介\"><a href=\"#Zookeeper简介\" class=\"headerlink\" title=\"Zookeeper简介\"></a>Zookeeper简介</h2><pre><code>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等。Zookeeper是hadoop的一个子项目，其发展历程无需赘述。在分布式应用中，由于工程师不能很好地使用锁机制，以及基于消息的协调机制不适合在某些应用中使用，因此需要有一种可靠的、可扩展的、分布式的、可配置的协调机制来统一系统的状态。\n</code></pre>\n<hr>\n<h2 id=\"Zookeeper的基本概念\"><a href=\"#Zookeeper的基本概念\" class=\"headerlink\" title=\"Zookeeper的基本概念\"></a>Zookeeper的基本概念</h2><p><strong><code>1.角色</code></strong><br>Zookeeper中的角色主要有以下三类，如下表所示：</p>\n<p><img src=\"/../images/zk/zk_1.jpg\"></p>\n<p><strong><code>2.特色</code></strong></p>\n<ol>\n<li>最终一致性：client不论连接到哪个Server，展示给它都是同一个视图，这是zookeeper最重要的性能。</li>\n<li>可靠性：具有简单、健壮、良好的性能，如果消息m被到一台服务器接受，那么它将被所有的服务器接受。</li>\n<li></li>\n</ol>\n<p>实时性：Zookeeper保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。但由于网络延时等原因，Zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()<br>接口。</p>\n<ol start=\"4\">\n<li>等待无关（wait-free）：慢的或者失效的client不得干预快速的client的请求，使得每个client都能有效的等待。</li>\n<li>原子性：更新只能成功或者失败，没有中间状态。</li>\n<li>顺序性：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。</li>\n</ol>\n<p><strong><code>3.工作原理</code></strong></p>\n<p>Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。</p>\n<p><strong><code>3.数据模型</code></strong></p>\n<ol>\n<li><p>层次化的目录结构，命名符合常规文件系统规范</p>\n</li>\n<li><p>每个节点在zookeeper中叫做znode,并且其有一个唯一的路径标识</p>\n</li>\n<li><p>节点Znode可以包含数据和子节点，但是EPHEMERAL类型的节点不能有子节点</p>\n</li>\n<li><p>Znode中的数据可以有多个版本，比如某一个路径下存有多个数据版本，那么查询这个路径下的数据就需要带上版本</p>\n</li>\n<li><p>Znode有两种类型，短暂的（ephemeral）和持久的（persistent）</p>\n</li>\n<li><p>Znode的类型在创建时确定并且之后不能再修改</p>\n</li>\n<li><p>短暂znode的客户端会话结束时，zookeeper会将该短暂znode删除，短暂znode不可以有子节点</p>\n</li>\n<li><p>持久znode不依赖于客户端会话，只有当客户端明确要删除该持久znode时才会被删除</p>\n</li>\n<li><p>Znode有四种形式的目录节点，PERSISTENT、PERSISTENT_SEQUENTIAL、EPHEMERAL、EPHEMERAL_SEQUENTIAL</p>\n</li>\n<li><p>数据只能存字节数组</p>\n<p>每个znode由3部分组成:</p>\n<ol>\n<li>stat. 此为状态信息, 描述该znode的版本, 权限等信息.</li>\n<li>data. 与该znode关联的数据.</li>\n<li>secondNode. 该znode下的子节点.</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"Zookeeper原生api列子\"><a href=\"#Zookeeper原生api列子\" class=\"headerlink\" title=\"Zookeeper原生api列子\"></a>Zookeeper原生api列子</h2><pre><code>public static void main(String[] args) throws Exception&#123;\n    /** zookeeper地址 */\n    final String CONNECT_ADDR = &quot;192.168.80.88:2181,192.168.80.87:2181,192.168.80.86:2181&quot;;\n    /** session超时时间 */\n    final int SESSION_OUTTIME = 2000;//ms \n    /** 信号量，阻塞程序执行，用于等待zookeeper连接成功，发送成功信号 */\n    final CountDownLatch connectedSemaphore = new CountDownLatch(1);\n    ZooKeeper zk = new ZooKeeper(CONNECT_ADDR, SESSION_OUTTIME, new Watcher()&#123;\n        @Override\n        public void process(WatchedEvent event) &#123;\n            //获取事件的状态\n            KeeperState keeperState = event.getState();\n            EventType eventType = event.getType();\n            //如果是建立连接\n            if(KeeperState.SyncConnected == keeperState)&#123;\n                if(EventType.None == eventType)&#123;\n                    //如果建立连接成功，则发送信号量，让后续阻塞程序向下执行\n                    connectedSemaphore.countDown();\n                    System.out.println(&quot;zk 建立连接&quot;);\n                &#125;\n            &#125;\n        &#125;\n    &#125;);\n    //进行阻塞\n    connectedSemaphore.await();\n    \n    //创建父节点\n    zk.create(&quot;/firstNode&quot;, &quot;firstNode&quot;.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n    \n    //创建子节点\n    zk.create(&quot;/firstNode/secondNode&quot;, &quot;secondNode data&quot;.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n    \n    //获取节点洗信息\n    byte[] data = zk.getData(&quot;/firstNode&quot;, true, null);\n    System.out.println(new String(data));\n    System.out.println(zk.getsecondNode(&quot;/firstNode&quot;, true));\n    \n    //修改节点的值\n    zk.setData(&quot;/firstNode&quot;, &quot;modify data root&quot;.getBytes(), -1);\n    byte[] data2 = zk.getData(&quot;/firstNode&quot;, true, null);\n    System.out.println(new String(data2));\t\t\n    \n    //判断节点是否存在\n    System.out.println(zk.exists(&quot;/firstNode/secondNode&quot;, true));\n    //删除节点\n    zk.delete(&quot;/firstNode/secondNode&quot;, -1);\n    System.out.println(zk.exists(&quot;/firstNode/secondNode&quot;, true));\n    \n    zk.close();\n&#125;\n\nstate=-112 会话超时状态\nstate= -113　认证失败状态\nstate=  1 连接建立中\nstate= 2 (暂时不清楚如何理解这个状态,ZOO_ASSOCIATING_STATE)\nstate=3 连接已建立状态\nstate= 999 无连接状态\n\n\ntype=1 创建节点事件\ntype=2 删除节点事件\ntype=3 更改节点事件\ntype=4 子节点列表变化事件\ntype= -1 会话session事件\ntype=-2 监控被移除事件\n</code></pre>\n<p>对父节点的变更以及孙节点的变更都不会触发watcher，而对watcher本身节点以及子节点的变更会触发watcher，watcher是一次行需要重复注册，具体参照下表。<br><img src=\"/../images/zk/zk_wa.png\"></p>\n<h2 id=\"zkclient列子\"><a href=\"#zkclient列子\" class=\"headerlink\" title=\"zkclient列子\"></a>zkclient列子</h2><pre><code>public static void main(String[] args) throws Exception &#123;\n    final String CONNECT_ADDR = &quot;127.0.0.1:2181&quot;;\n    ZkClient zkc = new ZkClient(new ZkConnection(CONNECT_ADDR), 5000);\n\n    // 对父节点添加监听子节点变化。\n    zkc.subscribeChildChanges(&quot;/node&quot;, new IZkChildListener() &#123;\n        @Override\n        public void handleChildChange(String parentPath, List&lt;String&gt; currentChilds) throws Exception &#123;\n            System.out.println(&quot;parentPath: &quot; + parentPath);\n            System.out.println(&quot;currentChilds: &quot; + currentChilds);\n        &#125;\n    &#125;);\n    zkc.deleteRecursive(&quot;/node&quot;);\n    Thread.sleep(3000);\n\n    zkc.createPersistent(&quot;/node&quot;);\n    Thread.sleep(1000);\n\n    zkc.createPersistent(&quot;/node&quot; + &quot;/&quot; + &quot;node1&quot;, &quot;node1内容&quot;);\n    Thread.sleep(1000);\n\n    zkc.createPersistent(&quot;/node&quot; + &quot;/&quot; + &quot;node2&quot;, &quot;node2内容&quot;);\n    Thread.sleep(1000);\n\n    zkc.delete(&quot;/node/node2&quot;);\n    Thread.sleep(1000);\n\n    zkc.delete(&quot;/node/node2/node3&quot;);\n    Thread.sleep(1000);\n\n    zkc.deleteRecursive(&quot;/node&quot;);\n\n&#125;\n</code></pre>\n<p>相比原生Api</p>\n<ol>\n<li><p>zkclient是在官方API上进行封装使用更简洁。</p>\n</li>\n<li><p>zkclient可以递归的创建节点、递归的删除节点 没办法创建数据</p>\n</li>\n<li><p>watcher 的改进避免重复注册监听</p>\n<ol>\n<li>subscribeChildChanges只监听本节点或直接子节点创建、删除。</li>\n<li>subscribeDataChanges 只监听本节点或直接子节点创建、删除、数据的改变。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"curator列子\"><a href=\"#curator列子\" class=\"headerlink\" title=\"curator列子\"></a>curator列子</h2><pre><code>public static void main(String[] args) throws Exception &#123;\n    final String CONNECT_ADDR = &quot;127.0.0.1:2181&quot;;\n    final int SESSION_OUTTIME = 5000;\n    //1 重试策略：初试时间为1s 重试10次\n    RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 10);\n    //2 通过工厂创建连接\n    CuratorFramework cf = CuratorFrameworkFactory.builder()\n                .connectString(CONNECT_ADDR)\n                .sessionTimeoutMs(SESSION_OUTTIME)\n                .retryPolicy(retryPolicy)\n                .build();\n    \n    //3 建立连接\n    cf.start();\n    //4 建立一个cache缓存\n    final NodeCache cache = new NodeCache(cf, &quot;/firstNode&quot;, false);\n    cache.start(true);\n    //触发事件为创建节点和更新节点，在删除节点的时候并不触发此操作。\n    cache.getListenable().addListener(new NodeCacheListener() &#123; \n        @Override\n        public void nodeChanged() throws Exception &#123;\n            System.out.println(&quot;路径为：&quot; + cache.getCurrentData().getPath());\n            System.out.println(&quot;数据为：&quot; + new String(cache.getCurrentData().getData()));\n            System.out.println(&quot;状态为：&quot; + cache.getCurrentData().getStat());\n        &#125;\n    &#125;);\n    \n    Thread.sleep(1000);\n    cf.create().forPath(&quot;/firstNode&quot;, &quot;123&quot;.getBytes());\n    \n    Thread.sleep(1000);\n    cf.setData().forPath(&quot;/firstNode&quot;, &quot;456&quot;.getBytes());\n    \n    Thread.sleep(1000);\n    cf.delete().forPath(&quot;/firstNode&quot;);\n    \n    Thread.sleep(Integer.MAX_VALUE);\n    cache.close();\n    cf.close();\n&#125;\n\n\n\npublic static void main(String[] args) throws Exception &#123;\n     final String CONNECT_ADDR = &quot;127.0.0.1:2181&quot;;\n     final int SESSION_OUTTIME = 5000;\n    //1 重试策略：初试时间为1s 重试10次\n    RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 10);\n    //2 通过工厂创建连接\n    CuratorFramework cf = CuratorFrameworkFactory.builder()\n                .connectString(CONNECT_ADDR)\n                .sessionTimeoutMs(SESSION_OUTTIME)\n                .retryPolicy(retryPolicy)\n                .build();\n    //3 建立连接\n    cf.start();\n    //4 建立一个PathsecondNodeCache缓存,第三个参数为是否接受节点数据内容 如果为false则不接受\n    PathsecondNodeCache cache = new PathsecondNodeCache(cf, &quot;/firstNode&quot;, true);\n    //5 在初始化的时候就进行缓存监听\n    cache.start(StartMode.POST_INITIALIZED_EVENT);\n    //监听子节点 新建、修改、删除\n    cache.getListenable().addListener(new PathsecondNodeCacheListener() &#123;\n        @Override\n        public void childEvent(CuratorFramework cf, PathsecondNodeCacheEvent event) throws Exception &#123;\n            switch (event.getType()) &#123;\n            case CHILD_ADDED:\n                System.out.println(&quot;CHILD_ADDED :&quot; + event.getData().getPath());\n                break;\n            case CHILD_UPDATED:\n                System.out.println(&quot;CHILD_UPDATED :&quot; + event.getData().getPath());\n                break;\n            case CHILD_REMOVED:\n                System.out.println(&quot;CHILD_REMOVED :&quot; + event.getData().getPath());\n                break;\n            default:\n                break;\n            &#125;\n        &#125;\n    &#125;);\n\n    //创建本身节点不发生变化\n    cf.create().forPath(&quot;/firstNode&quot;, &quot;init&quot;.getBytes());\n    \n    //添加子节点\n    Thread.sleep(1000);\n    cf.create().forPath(&quot;/firstNode/secondNode&quot;, &quot;secondNode内容&quot;.getBytes());\n    Thread.sleep(1000);\n    cf.create().forPath(&quot;/firstNode/thirdNode&quot;, &quot;thirdNode内容&quot;.getBytes());\n    \n    //修改子节点\n    Thread.sleep(1000);\n    cf.setData().forPath(&quot;/firstNode/secondNode&quot;, &quot;secondNode更新内容&quot;.getBytes());\n    \n    //删除子节点\n    Thread.sleep(1000);\n    cf.delete().forPath(&quot;/firstNode/thirdNode&quot;);\t\t\n    \n    //删除本身节点\n    Thread.sleep(1000);\n    cf.delete().deletingsecondNodeIfNeeded().forPath(&quot;/firstNode&quot;);\n    \n    Thread.sleep(Integer.MAX_VALUE);\n    cache.close();\n    cf.close();\n&#125;\n</code></pre>\n<h2 id=\"curator在分布式方面的应用\"><a href=\"#curator在分布式方面的应用\" class=\"headerlink\" title=\"curator在分布式方面的应用\"></a>curator在分布式方面的应用</h2><ol>\n<li><p>分布式锁 InterProcessMutex</p>\n<pre><code>    public static void main(String[] args) throws Exception &#123;\n        //1 重试策略：初试时间为1s 重试10次\n        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 10);\n        //2 通过工厂创建连接\n        CuratorFramework cf = CuratorFrameworkFactory.builder()\n                    .connectString(&quot;127.0.0.1:2181&quot;)\n                    .sessionTimeoutMs(5000)\n                    .retryPolicy(retryPolicy)\n                    .build();\n        //3 开启连接\n        cf.start();\n        //4 分布式锁\n        final InterProcessMutex lock = new InterProcessMutex(cf, &quot;/firstNode&quot;);\n        for(int i = 0; i &lt; 10; i++)&#123;\n            new Thread(new Runnable() &#123;\n                @Override\n                public void run() &#123;\n                    try &#123;\n                        //加锁\n                        lock.acquire();\n                        SimpleDateFormat sdf = new SimpleDateFormat(&quot;HH:mm:ss|SSS&quot;);\n                        System.err.println(sdf);\n                    &#125; catch (Exception e) &#123;\n                        e.printStackTrace();\n                    &#125; finally &#123;\n                        try &#123;\n                            lock.release();\n                        &#125; catch (Exception e) &#123;\n                            e.printStackTrace();\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;,&quot;t&quot; + i).start();\n        &#125;\n        Thread.sleep(100000);\n        cf.close();\n    &#125;\n</code></pre>\n</li>\n</ol>\n<p><code>InterProcessMutex 与 Semaphore semaphore=new Semaphore(1);功能相似</code></p>\n<ol>\n<li><p>DistributedDoubleBarrier</p>\n<pre><code>public static void main(String[] args) throws Exception &#123;\n    for(int i = 0; i &lt; 5; i++)&#123;\n        new Thread(new Runnable() &#123;\n            @Override\n            public void run() &#123;\n                try &#123;\n                    RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 10);\n                    CuratorFramework cf = CuratorFrameworkFactory.builder()\n                                .connectString(&quot;127.0.0.1:2181&quot;)\n                                .retryPolicy(retryPolicy)\n                                .build();\n                    cf.start();\n                    DistributedDoubleBarrier barrier = new DistributedDoubleBarrier(cf, &quot;/firstNode&quot;, 5);\n                    Thread.sleep(1000 * (new Random()).nextInt(3)); \n                    System.out.println(Thread.currentThread().getName() + &quot;已经准备&quot;);\n                    barrier.enter();\n                    System.out.println(&quot;同时开始运行...&quot;);\n                    Thread.sleep(1000 * (new Random()).nextInt(3));\n                    System.out.println(Thread.currentThread().getName() + &quot;运行完毕&quot;);\n                    barrier.leave();\n                    System.out.println(&quot;同时退出运行...&quot;);\n                &#125; catch (Exception e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;,&quot;t&quot; + i).start();\n    &#125;\n&#125;\n</code></pre>\n</li>\n</ol>\n<p><code>DistributedDoubleBarrier 与 CyclicBarrier cyclicBarrier=new CyclicBarrier(n);功能相似</code></p>\n<ol>\n<li><p>DistributedBarrier</p>\n<pre><code>public static void main(String[] args) throws Exception &#123;\n    for(int i = 0; i &lt; 5; i++)&#123;\n        new Thread(new Runnable() &#123;\n            @Override\n            public void run() &#123;\n                try &#123;\n                    RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 10);\n                    CuratorFramework cf = CuratorFrameworkFactory.builder()\n                                .connectString(&quot;127.0.0.1:2181&quot;)\n                                .sessionTimeoutMs(5000)\n                                .retryPolicy(retryPolicy)\n                                .build();\n                    cf.start();\n                    DistributedBarrier barrier = new DistributedBarrier(cf, &quot;/firstNode&quot;);\n                    System.out.println(Thread.currentThread().getName() + &quot;设置barrier!&quot;);\n                    barrier.setBarrier();\t\t//设置\n                    barrier.waitOnBarrier();\t//等待\n                    System.out.println(&quot;---------开始执行程序----------&quot;);\n                &#125; catch (Exception e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;,&quot;t&quot; + i).start();\n    &#125;\n\n    Thread.sleep(5000);\n    \n    RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 10);\n    CuratorFramework cf = CuratorFrameworkFactory.builder()\n                .connectString(CONNECT_ADDR)\n                .sessionTimeoutMs(SESSION_OUTTIME)\n                .retryPolicy(retryPolicy)\n                .build();\n    cf.start();\n    DistributedBarrier barrier = new DistributedBarrier(cf, &quot;/firstNode&quot;);\n    barrier.removeBarrier();\t//释放\n&#125;\n</code></pre>\n</li>\n</ol>\n<p><code>DistributedBarrier 与 CountDownLatch countDownLatch=new CountDownLatch(1);功能相似</code></p>\n<ol>\n<li><p>DistributedAtomicInteger 分布式原子性</p>\n<pre><code>public static void main(String[] args) throws Exception &#123;\n    //1 重试策略：初试时间为1s 重试10次\n    RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 10);\n    //2 通过工厂创建连接\n    CuratorFramework cf = CuratorFrameworkFactory.builder()\n                .connectString(&quot;127.0.0.1:2181&quot;)\n                .sessionTimeoutMs(5000)\n                .retryPolicy(retryPolicy)\n                .build();\n    //3 开启连接\n    cf.start();\n    cf.delete().forPath(&quot;/firstNode&quot;);\n    \n\n    //4 使用DistributedAtomicInteger\n    DistributedAtomicInteger atomicIntger = \n            new DistributedAtomicInteger(cf, &quot;/firstNode&quot;, new RetryNTimes(3, 1000));\n    \n    AtomicValue&lt;Integer&gt; value = atomicIntger.add(1);\n    System.out.println(value.succeeded());\n    System.out.println(value.postValue());\t//最新值\n    System.out.println(value.preValue());\t//原始值\n    \n&#125;\n</code></pre>\n</li>\n<li><p>可以实现类“发布、订阅”功能</p>\n<p>PathsecondNodeCache cache &#x3D; new PathsecondNodeCache(cf, “topic”, true);<br>cache.start(StartMode.POST_INITIALIZED_EVENT);<br>cache.getListenable().addListener(new PathsecondNodeCacheListener() ｛｝<br>&#x2F;&#x2F;离线在上线，也可以收到 期间的事件。</p>\n</li>\n</ol>\n<p><strong><code>curator 也是基于官方API封装，其语法支持链式编程，API更贴合开发人员思维，特别在分布式并发方面相当给力，建议使用curator。</code></strong></p>\n<h2 id=\"maven坐标\"><a href=\"#maven坐标\" class=\"headerlink\" title=\"maven坐标\"></a>maven坐标</h2><pre><code>    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;\n        &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;\n        &lt;version&gt;3.5.3-beta&lt;/version&gt;\n        &lt;type&gt;pom&lt;/type&gt;\n    &lt;/dependency&gt;\n    \n    \n    &lt;dependency&gt;\n        &lt;groupId&gt;com.101tec&lt;/groupId&gt;\n        &lt;artifactId&gt;zkclient&lt;/artifactId&gt;\n        &lt;version&gt;0.9&lt;/version&gt;\n    &lt;/dependency&gt;\n\n\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;\n        &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;\n        &lt;version&gt;4.0.0&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;\n        &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;\n        &lt;version&gt;4.0.0&lt;/version&gt;\n    &lt;/dependency&gt;\n    ]()\n</code></pre>\n","more":"<h2 id=\"Zookeeper简介\"><a href=\"#Zookeeper简介\" class=\"headerlink\" title=\"Zookeeper简介\"></a>Zookeeper简介</h2><pre><code>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等。Zookeeper是hadoop的一个子项目，其发展历程无需赘述。在分布式应用中，由于工程师不能很好地使用锁机制，以及基于消息的协调机制不适合在某些应用中使用，因此需要有一种可靠的、可扩展的、分布式的、可配置的协调机制来统一系统的状态。\n</code></pre>\n<hr>\n<h2 id=\"Zookeeper的基本概念\"><a href=\"#Zookeeper的基本概念\" class=\"headerlink\" title=\"Zookeeper的基本概念\"></a>Zookeeper的基本概念</h2><p><strong><code>1.角色</code></strong><br>Zookeeper中的角色主要有以下三类，如下表所示：</p>\n<p><img src=\"/../images/zk/zk_1.jpg\"></p>\n<p><strong><code>2.特色</code></strong></p>\n<ol>\n<li>最终一致性：client不论连接到哪个Server，展示给它都是同一个视图，这是zookeeper最重要的性能。</li>\n<li>可靠性：具有简单、健壮、良好的性能，如果消息m被到一台服务器接受，那么它将被所有的服务器接受。</li>\n<li></li>\n</ol>\n<p>实时性：Zookeeper保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。但由于网络延时等原因，Zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()<br>接口。</p>\n<ol start=\"4\">\n<li>等待无关（wait-free）：慢的或者失效的client不得干预快速的client的请求，使得每个client都能有效的等待。</li>\n<li>原子性：更新只能成功或者失败，没有中间状态。</li>\n<li>顺序性：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。</li>\n</ol>\n<p><strong><code>3.工作原理</code></strong></p>\n<p>Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。</p>\n<p><strong><code>3.数据模型</code></strong></p>\n<ol>\n<li><p>层次化的目录结构，命名符合常规文件系统规范</p>\n</li>\n<li><p>每个节点在zookeeper中叫做znode,并且其有一个唯一的路径标识</p>\n</li>\n<li><p>节点Znode可以包含数据和子节点，但是EPHEMERAL类型的节点不能有子节点</p>\n</li>\n<li><p>Znode中的数据可以有多个版本，比如某一个路径下存有多个数据版本，那么查询这个路径下的数据就需要带上版本</p>\n</li>\n<li><p>Znode有两种类型，短暂的（ephemeral）和持久的（persistent）</p>\n</li>\n<li><p>Znode的类型在创建时确定并且之后不能再修改</p>\n</li>\n<li><p>短暂znode的客户端会话结束时，zookeeper会将该短暂znode删除，短暂znode不可以有子节点</p>\n</li>\n<li><p>持久znode不依赖于客户端会话，只有当客户端明确要删除该持久znode时才会被删除</p>\n</li>\n<li><p>Znode有四种形式的目录节点，PERSISTENT、PERSISTENT_SEQUENTIAL、EPHEMERAL、EPHEMERAL_SEQUENTIAL</p>\n</li>\n<li><p>数据只能存字节数组</p>\n<p>每个znode由3部分组成:</p>\n<ol>\n<li>stat. 此为状态信息, 描述该znode的版本, 权限等信息.</li>\n<li>data. 与该znode关联的数据.</li>\n<li>secondNode. 该znode下的子节点.</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"Zookeeper原生api列子\"><a href=\"#Zookeeper原生api列子\" class=\"headerlink\" title=\"Zookeeper原生api列子\"></a>Zookeeper原生api列子</h2><pre><code>public static void main(String[] args) throws Exception&#123;\n    /** zookeeper地址 */\n    final String CONNECT_ADDR = &quot;192.168.80.88:2181,192.168.80.87:2181,192.168.80.86:2181&quot;;\n    /** session超时时间 */\n    final int SESSION_OUTTIME = 2000;//ms \n    /** 信号量，阻塞程序执行，用于等待zookeeper连接成功，发送成功信号 */\n    final CountDownLatch connectedSemaphore = new CountDownLatch(1);\n    ZooKeeper zk = new ZooKeeper(CONNECT_ADDR, SESSION_OUTTIME, new Watcher()&#123;\n        @Override\n        public void process(WatchedEvent event) &#123;\n            //获取事件的状态\n            KeeperState keeperState = event.getState();\n            EventType eventType = event.getType();\n            //如果是建立连接\n            if(KeeperState.SyncConnected == keeperState)&#123;\n                if(EventType.None == eventType)&#123;\n                    //如果建立连接成功，则发送信号量，让后续阻塞程序向下执行\n                    connectedSemaphore.countDown();\n                    System.out.println(&quot;zk 建立连接&quot;);\n                &#125;\n            &#125;\n        &#125;\n    &#125;);\n    //进行阻塞\n    connectedSemaphore.await();\n    \n    //创建父节点\n    zk.create(&quot;/firstNode&quot;, &quot;firstNode&quot;.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n    \n    //创建子节点\n    zk.create(&quot;/firstNode/secondNode&quot;, &quot;secondNode data&quot;.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n    \n    //获取节点洗信息\n    byte[] data = zk.getData(&quot;/firstNode&quot;, true, null);\n    System.out.println(new String(data));\n    System.out.println(zk.getsecondNode(&quot;/firstNode&quot;, true));\n    \n    //修改节点的值\n    zk.setData(&quot;/firstNode&quot;, &quot;modify data root&quot;.getBytes(), -1);\n    byte[] data2 = zk.getData(&quot;/firstNode&quot;, true, null);\n    System.out.println(new String(data2));\t\t\n    \n    //判断节点是否存在\n    System.out.println(zk.exists(&quot;/firstNode/secondNode&quot;, true));\n    //删除节点\n    zk.delete(&quot;/firstNode/secondNode&quot;, -1);\n    System.out.println(zk.exists(&quot;/firstNode/secondNode&quot;, true));\n    \n    zk.close();\n&#125;\n\nstate=-112 会话超时状态\nstate= -113　认证失败状态\nstate=  1 连接建立中\nstate= 2 (暂时不清楚如何理解这个状态,ZOO_ASSOCIATING_STATE)\nstate=3 连接已建立状态\nstate= 999 无连接状态\n\n\ntype=1 创建节点事件\ntype=2 删除节点事件\ntype=3 更改节点事件\ntype=4 子节点列表变化事件\ntype= -1 会话session事件\ntype=-2 监控被移除事件\n</code></pre>\n<p>对父节点的变更以及孙节点的变更都不会触发watcher，而对watcher本身节点以及子节点的变更会触发watcher，watcher是一次行需要重复注册，具体参照下表。<br><img src=\"/../images/zk/zk_wa.png\"></p>\n<h2 id=\"zkclient列子\"><a href=\"#zkclient列子\" class=\"headerlink\" title=\"zkclient列子\"></a>zkclient列子</h2><pre><code>public static void main(String[] args) throws Exception &#123;\n    final String CONNECT_ADDR = &quot;127.0.0.1:2181&quot;;\n    ZkClient zkc = new ZkClient(new ZkConnection(CONNECT_ADDR), 5000);\n\n    // 对父节点添加监听子节点变化。\n    zkc.subscribeChildChanges(&quot;/node&quot;, new IZkChildListener() &#123;\n        @Override\n        public void handleChildChange(String parentPath, List&lt;String&gt; currentChilds) throws Exception &#123;\n            System.out.println(&quot;parentPath: &quot; + parentPath);\n            System.out.println(&quot;currentChilds: &quot; + currentChilds);\n        &#125;\n    &#125;);\n    zkc.deleteRecursive(&quot;/node&quot;);\n    Thread.sleep(3000);\n\n    zkc.createPersistent(&quot;/node&quot;);\n    Thread.sleep(1000);\n\n    zkc.createPersistent(&quot;/node&quot; + &quot;/&quot; + &quot;node1&quot;, &quot;node1内容&quot;);\n    Thread.sleep(1000);\n\n    zkc.createPersistent(&quot;/node&quot; + &quot;/&quot; + &quot;node2&quot;, &quot;node2内容&quot;);\n    Thread.sleep(1000);\n\n    zkc.delete(&quot;/node/node2&quot;);\n    Thread.sleep(1000);\n\n    zkc.delete(&quot;/node/node2/node3&quot;);\n    Thread.sleep(1000);\n\n    zkc.deleteRecursive(&quot;/node&quot;);\n\n&#125;\n</code></pre>\n<p>相比原生Api</p>\n<ol>\n<li><p>zkclient是在官方API上进行封装使用更简洁。</p>\n</li>\n<li><p>zkclient可以递归的创建节点、递归的删除节点 没办法创建数据</p>\n</li>\n<li><p>watcher 的改进避免重复注册监听</p>\n<ol>\n<li>subscribeChildChanges只监听本节点或直接子节点创建、删除。</li>\n<li>subscribeDataChanges 只监听本节点或直接子节点创建、删除、数据的改变。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"curator列子\"><a href=\"#curator列子\" class=\"headerlink\" title=\"curator列子\"></a>curator列子</h2><pre><code>public static void main(String[] args) throws Exception &#123;\n    final String CONNECT_ADDR = &quot;127.0.0.1:2181&quot;;\n    final int SESSION_OUTTIME = 5000;\n    //1 重试策略：初试时间为1s 重试10次\n    RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 10);\n    //2 通过工厂创建连接\n    CuratorFramework cf = CuratorFrameworkFactory.builder()\n                .connectString(CONNECT_ADDR)\n                .sessionTimeoutMs(SESSION_OUTTIME)\n                .retryPolicy(retryPolicy)\n                .build();\n    \n    //3 建立连接\n    cf.start();\n    //4 建立一个cache缓存\n    final NodeCache cache = new NodeCache(cf, &quot;/firstNode&quot;, false);\n    cache.start(true);\n    //触发事件为创建节点和更新节点，在删除节点的时候并不触发此操作。\n    cache.getListenable().addListener(new NodeCacheListener() &#123; \n        @Override\n        public void nodeChanged() throws Exception &#123;\n            System.out.println(&quot;路径为：&quot; + cache.getCurrentData().getPath());\n            System.out.println(&quot;数据为：&quot; + new String(cache.getCurrentData().getData()));\n            System.out.println(&quot;状态为：&quot; + cache.getCurrentData().getStat());\n        &#125;\n    &#125;);\n    \n    Thread.sleep(1000);\n    cf.create().forPath(&quot;/firstNode&quot;, &quot;123&quot;.getBytes());\n    \n    Thread.sleep(1000);\n    cf.setData().forPath(&quot;/firstNode&quot;, &quot;456&quot;.getBytes());\n    \n    Thread.sleep(1000);\n    cf.delete().forPath(&quot;/firstNode&quot;);\n    \n    Thread.sleep(Integer.MAX_VALUE);\n    cache.close();\n    cf.close();\n&#125;\n\n\n\npublic static void main(String[] args) throws Exception &#123;\n     final String CONNECT_ADDR = &quot;127.0.0.1:2181&quot;;\n     final int SESSION_OUTTIME = 5000;\n    //1 重试策略：初试时间为1s 重试10次\n    RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 10);\n    //2 通过工厂创建连接\n    CuratorFramework cf = CuratorFrameworkFactory.builder()\n                .connectString(CONNECT_ADDR)\n                .sessionTimeoutMs(SESSION_OUTTIME)\n                .retryPolicy(retryPolicy)\n                .build();\n    //3 建立连接\n    cf.start();\n    //4 建立一个PathsecondNodeCache缓存,第三个参数为是否接受节点数据内容 如果为false则不接受\n    PathsecondNodeCache cache = new PathsecondNodeCache(cf, &quot;/firstNode&quot;, true);\n    //5 在初始化的时候就进行缓存监听\n    cache.start(StartMode.POST_INITIALIZED_EVENT);\n    //监听子节点 新建、修改、删除\n    cache.getListenable().addListener(new PathsecondNodeCacheListener() &#123;\n        @Override\n        public void childEvent(CuratorFramework cf, PathsecondNodeCacheEvent event) throws Exception &#123;\n            switch (event.getType()) &#123;\n            case CHILD_ADDED:\n                System.out.println(&quot;CHILD_ADDED :&quot; + event.getData().getPath());\n                break;\n            case CHILD_UPDATED:\n                System.out.println(&quot;CHILD_UPDATED :&quot; + event.getData().getPath());\n                break;\n            case CHILD_REMOVED:\n                System.out.println(&quot;CHILD_REMOVED :&quot; + event.getData().getPath());\n                break;\n            default:\n                break;\n            &#125;\n        &#125;\n    &#125;);\n\n    //创建本身节点不发生变化\n    cf.create().forPath(&quot;/firstNode&quot;, &quot;init&quot;.getBytes());\n    \n    //添加子节点\n    Thread.sleep(1000);\n    cf.create().forPath(&quot;/firstNode/secondNode&quot;, &quot;secondNode内容&quot;.getBytes());\n    Thread.sleep(1000);\n    cf.create().forPath(&quot;/firstNode/thirdNode&quot;, &quot;thirdNode内容&quot;.getBytes());\n    \n    //修改子节点\n    Thread.sleep(1000);\n    cf.setData().forPath(&quot;/firstNode/secondNode&quot;, &quot;secondNode更新内容&quot;.getBytes());\n    \n    //删除子节点\n    Thread.sleep(1000);\n    cf.delete().forPath(&quot;/firstNode/thirdNode&quot;);\t\t\n    \n    //删除本身节点\n    Thread.sleep(1000);\n    cf.delete().deletingsecondNodeIfNeeded().forPath(&quot;/firstNode&quot;);\n    \n    Thread.sleep(Integer.MAX_VALUE);\n    cache.close();\n    cf.close();\n&#125;\n</code></pre>\n<h2 id=\"curator在分布式方面的应用\"><a href=\"#curator在分布式方面的应用\" class=\"headerlink\" title=\"curator在分布式方面的应用\"></a>curator在分布式方面的应用</h2><ol>\n<li><p>分布式锁 InterProcessMutex</p>\n<pre><code>    public static void main(String[] args) throws Exception &#123;\n        //1 重试策略：初试时间为1s 重试10次\n        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 10);\n        //2 通过工厂创建连接\n        CuratorFramework cf = CuratorFrameworkFactory.builder()\n                    .connectString(&quot;127.0.0.1:2181&quot;)\n                    .sessionTimeoutMs(5000)\n                    .retryPolicy(retryPolicy)\n                    .build();\n        //3 开启连接\n        cf.start();\n        //4 分布式锁\n        final InterProcessMutex lock = new InterProcessMutex(cf, &quot;/firstNode&quot;);\n        for(int i = 0; i &lt; 10; i++)&#123;\n            new Thread(new Runnable() &#123;\n                @Override\n                public void run() &#123;\n                    try &#123;\n                        //加锁\n                        lock.acquire();\n                        SimpleDateFormat sdf = new SimpleDateFormat(&quot;HH:mm:ss|SSS&quot;);\n                        System.err.println(sdf);\n                    &#125; catch (Exception e) &#123;\n                        e.printStackTrace();\n                    &#125; finally &#123;\n                        try &#123;\n                            lock.release();\n                        &#125; catch (Exception e) &#123;\n                            e.printStackTrace();\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;,&quot;t&quot; + i).start();\n        &#125;\n        Thread.sleep(100000);\n        cf.close();\n    &#125;\n</code></pre>\n</li>\n</ol>\n<p><code>InterProcessMutex 与 Semaphore semaphore=new Semaphore(1);功能相似</code></p>\n<ol>\n<li><p>DistributedDoubleBarrier</p>\n<pre><code>public static void main(String[] args) throws Exception &#123;\n    for(int i = 0; i &lt; 5; i++)&#123;\n        new Thread(new Runnable() &#123;\n            @Override\n            public void run() &#123;\n                try &#123;\n                    RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 10);\n                    CuratorFramework cf = CuratorFrameworkFactory.builder()\n                                .connectString(&quot;127.0.0.1:2181&quot;)\n                                .retryPolicy(retryPolicy)\n                                .build();\n                    cf.start();\n                    DistributedDoubleBarrier barrier = new DistributedDoubleBarrier(cf, &quot;/firstNode&quot;, 5);\n                    Thread.sleep(1000 * (new Random()).nextInt(3)); \n                    System.out.println(Thread.currentThread().getName() + &quot;已经准备&quot;);\n                    barrier.enter();\n                    System.out.println(&quot;同时开始运行...&quot;);\n                    Thread.sleep(1000 * (new Random()).nextInt(3));\n                    System.out.println(Thread.currentThread().getName() + &quot;运行完毕&quot;);\n                    barrier.leave();\n                    System.out.println(&quot;同时退出运行...&quot;);\n                &#125; catch (Exception e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;,&quot;t&quot; + i).start();\n    &#125;\n&#125;\n</code></pre>\n</li>\n</ol>\n<p><code>DistributedDoubleBarrier 与 CyclicBarrier cyclicBarrier=new CyclicBarrier(n);功能相似</code></p>\n<ol>\n<li><p>DistributedBarrier</p>\n<pre><code>public static void main(String[] args) throws Exception &#123;\n    for(int i = 0; i &lt; 5; i++)&#123;\n        new Thread(new Runnable() &#123;\n            @Override\n            public void run() &#123;\n                try &#123;\n                    RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 10);\n                    CuratorFramework cf = CuratorFrameworkFactory.builder()\n                                .connectString(&quot;127.0.0.1:2181&quot;)\n                                .sessionTimeoutMs(5000)\n                                .retryPolicy(retryPolicy)\n                                .build();\n                    cf.start();\n                    DistributedBarrier barrier = new DistributedBarrier(cf, &quot;/firstNode&quot;);\n                    System.out.println(Thread.currentThread().getName() + &quot;设置barrier!&quot;);\n                    barrier.setBarrier();\t\t//设置\n                    barrier.waitOnBarrier();\t//等待\n                    System.out.println(&quot;---------开始执行程序----------&quot;);\n                &#125; catch (Exception e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;,&quot;t&quot; + i).start();\n    &#125;\n\n    Thread.sleep(5000);\n    \n    RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 10);\n    CuratorFramework cf = CuratorFrameworkFactory.builder()\n                .connectString(CONNECT_ADDR)\n                .sessionTimeoutMs(SESSION_OUTTIME)\n                .retryPolicy(retryPolicy)\n                .build();\n    cf.start();\n    DistributedBarrier barrier = new DistributedBarrier(cf, &quot;/firstNode&quot;);\n    barrier.removeBarrier();\t//释放\n&#125;\n</code></pre>\n</li>\n</ol>\n<p><code>DistributedBarrier 与 CountDownLatch countDownLatch=new CountDownLatch(1);功能相似</code></p>\n<ol>\n<li><p>DistributedAtomicInteger 分布式原子性</p>\n<pre><code>public static void main(String[] args) throws Exception &#123;\n    //1 重试策略：初试时间为1s 重试10次\n    RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 10);\n    //2 通过工厂创建连接\n    CuratorFramework cf = CuratorFrameworkFactory.builder()\n                .connectString(&quot;127.0.0.1:2181&quot;)\n                .sessionTimeoutMs(5000)\n                .retryPolicy(retryPolicy)\n                .build();\n    //3 开启连接\n    cf.start();\n    cf.delete().forPath(&quot;/firstNode&quot;);\n    \n\n    //4 使用DistributedAtomicInteger\n    DistributedAtomicInteger atomicIntger = \n            new DistributedAtomicInteger(cf, &quot;/firstNode&quot;, new RetryNTimes(3, 1000));\n    \n    AtomicValue&lt;Integer&gt; value = atomicIntger.add(1);\n    System.out.println(value.succeeded());\n    System.out.println(value.postValue());\t//最新值\n    System.out.println(value.preValue());\t//原始值\n    \n&#125;\n</code></pre>\n</li>\n<li><p>可以实现类“发布、订阅”功能</p>\n<p>PathsecondNodeCache cache &#x3D; new PathsecondNodeCache(cf, “topic”, true);<br>cache.start(StartMode.POST_INITIALIZED_EVENT);<br>cache.getListenable().addListener(new PathsecondNodeCacheListener() ｛｝<br>&#x2F;&#x2F;离线在上线，也可以收到 期间的事件。</p>\n</li>\n</ol>\n<p><strong><code>curator 也是基于官方API封装，其语法支持链式编程，API更贴合开发人员思维，特别在分布式并发方面相当给力，建议使用curator。</code></strong></p>\n<h2 id=\"maven坐标\"><a href=\"#maven坐标\" class=\"headerlink\" title=\"maven坐标\"></a>maven坐标</h2><pre><code>    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;\n        &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;\n        &lt;version&gt;3.5.3-beta&lt;/version&gt;\n        &lt;type&gt;pom&lt;/type&gt;\n    &lt;/dependency&gt;\n    \n    \n    &lt;dependency&gt;\n        &lt;groupId&gt;com.101tec&lt;/groupId&gt;\n        &lt;artifactId&gt;zkclient&lt;/artifactId&gt;\n        &lt;version&gt;0.9&lt;/version&gt;\n    &lt;/dependency&gt;\n\n\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;\n        &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;\n        &lt;version&gt;4.0.0&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;\n        &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;\n        &lt;version&gt;4.0.0&lt;/version&gt;\n    &lt;/dependency&gt;\n    ]()\n</code></pre>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cm3zaz9c00001tgu6ada21hmp","category_id":"cm3ygho88000whsu67izoaqb2","_id":"cm3zaz9c30008tgu67dt7h9k8"},{"post_id":"cm3zaz9c10003tgu64howgfaj","category_id":"cm3ygho88000whsu67izoaqb2","_id":"cm3zaz9c3000btgu65wi4g41a"},{"post_id":"cm3zaz9c20005tgu63va4ehvo","category_id":"cm3ygho88000whsu67izoaqb2","_id":"cm3zaz9c4000etgu69bts4buy"},{"post_id":"cm3zaz9c4000gtgu68l73d21l","category_id":"cm3ygho8h0034hsu68s7a18uz","_id":"cm3zaz9c6000ptgu6a3po1zxs"},{"post_id":"cm3zaz9c80012tgu66de3b47z","category_id":"cm3ygho88000whsu67izoaqb2","_id":"cm3zaz9c9001ctgu6d58taw00"},{"post_id":"cm3zaz9c9001etgu676wjby5x","category_id":"cm3ygho8e0026hsu60tqpezdt","_id":"cm3zaz9cb001otgu6d9pvha9z"},{"post_id":"cm3zaz9cc001xtgu6ehl0bmz4","category_id":"cm3ygho88000whsu67izoaqb2","_id":"cm3zaz9cd0022tgu65vfu8xmp"},{"post_id":"cm3zaz9cc001ytgu68f0v4u40","category_id":"cm3ygho8g002ohsu6bvul6ei2","_id":"cm3zaz9cd0024tgu6g8o9erqq"},{"post_id":"cm3zb0p5u0000kku675p1155d","category_id":"cm3ygho8h0030hsu6ba29ccx7","_id":"cm3zb0p5v0002kku69e3ictay"},{"post_id":"cm3zaz9cd0020tgu6cvfw2rxs","category_id":"cm3zb30x000025cu667370u97","_id":"cm3zb30x100035cu6923u6lvo"},{"post_id":"cm3zaz9bx0000tgu6205z3lbj","category_id":"cm3zb3au400055cu611q4caar","_id":"cm3zb3au400065cu62imc100f"},{"post_id":"cm3z7jir900001gu65vmyc2az","category_id":"cm3zb3nwb000a5cu66zmt4zre","_id":"cm3zb3nwc000b5cu633qgfbvu"},{"post_id":"cm3zaz9c20007tgu687gnbwqk","category_id":"cm3ygho800002hsu68rrkagtl","_id":"cm3zb42b6000f5cu6fyrd7o6t"},{"post_id":"cm3zaz9c5000itgu63dl8eyh2","category_id":"cm3ygho800002hsu68rrkagtl","_id":"cm3zb4jsw000j5cu6bheu58a9"},{"post_id":"cm3z9ugxj00044ou68da19syv","category_id":"cm3ygho800002hsu68rrkagtl","_id":"cm3zb4mwl000l5cu61w0jgrsa"},{"post_id":"cm3zaz9c3000atgu6dw5feo6e","category_id":"cm3zb30x000025cu667370u97","_id":"cm3zb50gi000n5cu6gecu6mwo"},{"post_id":"cm3zaz9c3000dtgu69arp9t5x","category_id":"cm3zb58ei000p5cu6darv430y","_id":"cm3zb58ei000q5cu68r9y2gso"},{"post_id":"cm3zaz9c7000rtgu68k6b89fw","category_id":"cm3zb58ei000p5cu6darv430y","_id":"cm3zb5z3r000s5cu6ax0v9wrz"},{"post_id":"cm3zaz9c6000ntgu63rl7f1o7","category_id":"cm3zb58ei000p5cu6darv430y","_id":"cm3zb5z3r000v5cu6fhq2cqyw"},{"post_id":"cm3zaz9c7000wtgu60poz6tww","category_id":"cm3zb58ei000p5cu6darv430y","_id":"cm3zb5z3r000w5cu68ldzgssb"},{"post_id":"cm3zaz9c6000ltgu6cdqk7y1i","category_id":"cm3zb58ei000p5cu6darv430y","_id":"cm3zb5z46000y5cu6g2v4dr75"},{"post_id":"cm3zaz9c8000ztgu64mke1hth","category_id":"cm3zb58ei000p5cu6darv430y","_id":"cm3zb63s800105cu64imjcx8c"},{"post_id":"cm3zaz9c80015tgu68c9odqb2","category_id":"cm3zb58ei000p5cu6darv430y","_id":"cm3zb66ge00125cu61krh7194"},{"post_id":"cm3zaz9c7000ttgu6c6fl5h73","category_id":"cm3zb58ei000p5cu6darv430y","_id":"cm3zb69mp00145cu6e48iaixy"},{"post_id":"cm3zaz9c90018tgu66ki1awf3","category_id":"cm3ygho88000whsu67izoaqb2","_id":"cm3zb7rnx001b5cu66wdn5juj"},{"post_id":"cm3zaz9c9001btgu6htozetxl","category_id":"cm3ygho88000whsu67izoaqb2","_id":"cm3zb87s5001h5cu661mxcpio"},{"post_id":"cm3zc6m570000l8u68t5g4kz2","category_id":"cm3ygho88000whsu67izoaqb2","_id":"cm3zc6m590002l8u6buauh24b"},{"post_id":"cm3zc73hv0003l8u6gjje2qnt","category_id":"cm3ygho8d001yhsu6911veq6y","_id":"cm3zc73hv0005l8u60tbg4ed8"},{"post_id":"cm3zc7fkp0006l8u6566c68js","category_id":"cm3ygho8g002whsu6g3dz64gk","_id":"cm3zc7fkp0008l8u60tj7e9y5"}],"PostTag":[{"post_id":"cm3zaz9c4000gtgu68l73d21l","tag_id":"cm3ygho8i003dhsu60flsfslo","_id":"cm3zaz9c5000ktgu6fgsr9nyc"},{"post_id":"cm3zaz9c9001etgu676wjby5x","tag_id":"cm3ygho8e0028hsu651xd20bn","_id":"cm3zaz9ca001mtgu61ea40gap"},{"post_id":"cm3zaz9cc001ytgu68f0v4u40","tag_id":"cm3ygho8g002thsu6drnc9pu2","_id":"cm3zaz9cd0021tgu6dsmwg41n"},{"post_id":"cm3zaz9cd0020tgu6cvfw2rxs","tag_id":"cm3ygho810003hsu614mx2a1g","_id":"cm3zaz9cd0023tgu6fogy2yzv"},{"post_id":"cm3zb0p5u0000kku675p1155d","tag_id":"cm3ygho8h003bhsu6h54tgpss","_id":"cm3zb0p5v0001kku606qe5axl"},{"post_id":"cm3zaz9bx0000tgu6205z3lbj","tag_id":"cm3zb3dpf00075cu6c3pb9rdl","_id":"cm3zb3dph00085cu61lshguw6"},{"post_id":"cm3z7jir900001gu65vmyc2az","tag_id":"cm3zb3qu4000c5cu65th3a1sp","_id":"cm3zb3qu4000d5cu6h7cb4bfk"},{"post_id":"cm3zaz9c20007tgu687gnbwqk","tag_id":"cm3zb4ahu000g5cu65u3gcfdj","_id":"cm3zb4ahv000h5cu6bynx3p24"},{"post_id":"cm3zaz9c5000itgu63dl8eyh2","tag_id":"cm3zb4ahu000g5cu65u3gcfdj","_id":"cm3zb4jsw000i5cu6fwpz5tc7"},{"post_id":"cm3z9ugxj00044ou68da19syv","tag_id":"cm3zb4ahu000g5cu65u3gcfdj","_id":"cm3zb4mwl000k5cu66trpgqb8"},{"post_id":"cm3zaz9c3000atgu6dw5feo6e","tag_id":"cm3zb50gi000m5cu64gx7atw6","_id":"cm3zb50gi000o5cu60f3y5zu0"},{"post_id":"cm3zaz9c10003tgu64howgfaj","tag_id":"cm3zb3dpf00075cu6c3pb9rdl","_id":"cm3zb6flp00155cu69ut9dz4b"},{"post_id":"cm3zaz9c00001tgu6ada21hmp","tag_id":"cm3zb75nc00165cu6h4o42ub8","_id":"cm3zb75nd00175cu64qhz2bjt"},{"post_id":"cm3zaz9c80012tgu66de3b47z","tag_id":"cm3zb7jd900185cu625wqb364","_id":"cm3zb7jd900195cu667j5cg1w"},{"post_id":"cm3zaz9c90018tgu66ki1awf3","tag_id":"cm3zb7w44001c5cu66l9zcx53","_id":"cm3zb7w44001d5cu68gn9e84z"},{"post_id":"cm3zaz9c20005tgu63va4ehvo","tag_id":"cm3zb8216001e5cu6hexsg6z1","_id":"cm3zb8217001f5cu6fcb0hvf7"},{"post_id":"cm3zaz9c9001btgu6htozetxl","tag_id":"cm3zb8a13001i5cu63rv2c0ap","_id":"cm3zb8a13001j5cu6evxr7uaz"},{"post_id":"cm3zaz9cc001xtgu6ehl0bmz4","tag_id":"cm3ygho8c001thsu6dj8qhvh9","_id":"cm3zb9jte001p5cu694r0h38c"},{"post_id":"cm3zaz9c3000dtgu69arp9t5x","tag_id":"cm3ygho85000khsu6438l4379","_id":"cm3zbba2b0000pcu6c8j9gi71"},{"post_id":"cm3zaz9c6000ntgu63rl7f1o7","tag_id":"cm3ygho85000khsu6438l4379","_id":"cm3zbba2c0001pcu6f7d053v9"},{"post_id":"cm3zaz9c8000ztgu64mke1hth","tag_id":"cm3ygho85000khsu6438l4379","_id":"cm3zbba2p0002pcu69v22h5be"},{"post_id":"cm3zaz9c7000rtgu68k6b89fw","tag_id":"cm3ygho85000khsu6438l4379","_id":"cm3zbba2p0003pcu6869zffs6"},{"post_id":"cm3zaz9c7000wtgu60poz6tww","tag_id":"cm3ygho85000khsu6438l4379","_id":"cm3zbba2q0004pcu6909rfvv1"},{"post_id":"cm3zaz9c80015tgu68c9odqb2","tag_id":"cm3ygho85000khsu6438l4379","_id":"cm3zbba2q0005pcu64wju77i9"},{"post_id":"cm3zaz9c6000ltgu6cdqk7y1i","tag_id":"cm3ygho85000khsu6438l4379","_id":"cm3zbba350006pcu62vosaxbm"},{"post_id":"cm3zaz9c7000ttgu6c6fl5h73","tag_id":"cm3ygho85000khsu6438l4379","_id":"cm3zbbr7d0007pcu61h83d9q1"},{"post_id":"cm3zc6m570000l8u68t5g4kz2","tag_id":"cm3ygho8g002xhsu64nuqd9ku","_id":"cm3zc6m590001l8u61bwqh5ac"},{"post_id":"cm3zc73hv0003l8u6gjje2qnt","tag_id":"cm3ygho8g002phsu6fgxf72be","_id":"cm3zc73hv0004l8u66rqd1sof"},{"post_id":"cm3zc7fkp0006l8u6566c68js","tag_id":"cm3ygho8h0031hsu6h8aybab9","_id":"cm3zc7fkp0007l8u69izkdmar"}],"Tag":[{"name":"java","_id":"cm3ygho810003hsu614mx2a1g"},{"name":"mysql","_id":"cm3ygho85000khsu6438l4379"},{"name":"task","_id":"cm3ygho89000xhsu6g6hgetrc"},{"name":"bean","_id":"cm3ygho8c001thsu6dj8qhvh9"},{"name":"ActiveMQ","_id":"cm3ygho8d0020hsu6hrfx3egb"},{"name":"redis","_id":"cm3ygho8e0028hsu651xd20bn"},{"name":"spring","_id":"cm3ygho8f002fhsu6f70h15cq"},{"name":"rocketmq","_id":"cm3ygho8g002phsu6fgxf72be"},{"name":"分布式事务","_id":"cm3ygho8g002thsu6drnc9pu2"},{"name":"aop","_id":"cm3ygho8g002xhsu64nuqd9ku"},{"name":"zookeeper","_id":"cm3ygho8h0031hsu6h8aybab9"},{"name":"controller","_id":"cm3ygho8h0035hsu6cy8oetxx"},{"name":"interceptor","_id":"cm3ygho8h0038hsu65jvy2qr4"},{"name":"mybatis","_id":"cm3ygho8h003bhsu6h54tgpss"},{"name":"js","_id":"cm3ygho8i003dhsu60flsfslo"},{"name":"JAVA","_id":"cm3z9p88900024ou67kdnegv2"},{"name":"工具","_id":"cm3z9x22w0000jou6dl4t6oe2"},{"name":"工具[hexo使用.md](hexo%CA%B9%D3%C3.md)","_id":"cm3z9x8p00002jou6h94u1ui1"},{"name":"-mysql","_id":"cm3zaz9c4000htgu64gilbir4"},{"name":"-java","_id":"cm3zaz9c6000otgu63c6o9jmw"},{"name":"activemq","_id":"cm3zaz9ca001gtgu6dpnagrsn"},{"name":"mq","_id":"cm3zaz9cb001ptgu61pp26cih"},{"name":"sping","_id":"cm3zaz9cc001ztgu642qjf071"},{"name":"mvc","_id":"cm3zb3dpf00075cu6c3pb9rdl"},{"name":"hexo","_id":"cm3zb3qu4000c5cu65th3a1sp"},{"name":"基础知识","_id":"cm3zb4ahu000g5cu65u3gcfdj"},{"name":"面试","_id":"cm3zb50gi000m5cu64gx7atw6"},{"name":"事务","_id":"cm3zb75nc00165cu6h4o42ub8"},{"name":"单元测试","_id":"cm3zb7jd900185cu625wqb364"},{"name":"定时任务","_id":"cm3zb7w44001c5cu66l9zcx53"},{"name":"扩展","_id":"cm3zb8216001e5cu6hexsg6z1"},{"name":"整合","_id":"cm3zb8a13001i5cu63rv2c0ap"}]}}